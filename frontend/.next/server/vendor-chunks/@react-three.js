"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-776716bd.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useInstanceHandle),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useStore),\n/* harmony export */   D: () => (/* binding */ useThree),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useFrame),\n/* harmony export */   G: () => (/* binding */ useGraph),\n/* harmony export */   H: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createPointerEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createEvents),\n/* harmony export */   g: () => (/* binding */ context),\n/* harmony export */   h: () => (/* binding */ createPortal),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ reconciler),\n/* harmony export */   k: () => (/* binding */ applyProps),\n/* harmony export */   l: () => (/* binding */ dispose),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ addEffect),\n/* harmony export */   p: () => (/* binding */ addAfterEffect),\n/* harmony export */   q: () => (/* binding */ addTail),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ flushSync),\n/* harmony export */   w: () => (/* binding */ getRootState),\n/* harmony export */   x: () => (/* binding */ act),\n/* harmony export */   y: () => (/* binding */ buildGraph),\n/* harmony export */   z: () => (/* binding */ roots)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance.isBufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance.isMaterial) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                parentInstance.dispatchEvent({\n                    type: \"childadded\",\n                    child\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // @ts-expect-error\n                // Remove interactivity on the initial root\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(findInitialRoot(child), child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                const callback = ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                };\n                // Schedule async at runtime, flush sync in testing\n                if (typeof IS_REACT_ACT_ENVIRONMENT === \"undefined\") {\n                    (0,scheduler__WEBPACK_IMPORTED_MODULE_4__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_4__.unstable_IdlePriority, callback);\n                } else {\n                    callback();\n                }\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers on the initial root\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = findInitialRoot(newInstance).getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, make it no-op\n    const handleTextInstance = ()=>{};\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_3___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container on the initial root\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                findInitialRoot(instance).getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-expect-error\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\r\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\r\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\r\n * The current THREE.ColorManagement instance, if present.\r\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\r\n * Returns instance root state\r\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n/**\r\n * Returns the instances initial (outmost) root\r\n */ function findInitialRoot(child) {\n    let root = child.__r3f.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n/**\r\n * Collects nodes and materials from a THREE.Object3D.\r\n */ function buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    const localState = instance.__r3f;\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f;\n        // Bail out on primitive object\n        if ((_instance$__r3f = instance.__r3f) != null && _instance$__r3f.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\nconst __DEV__ = typeof process !== \"undefined\" && \"development\" !== \"production\";\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f2;\n    // Filter equals, events and reserved props\n    const localState = instance.__r3f;\n    const root = localState == null ? void 0 : localState.root;\n    const rootState = root == null ? void 0 : root.getState == null ? void 0 : root.getState();\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState == null ? void 0 : localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-expect-error\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent && localState) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.\n            // Loosen to unminified names, ignoring descendents.\n            // https://github.com/pmndrs/react-three-fiber/issues/2856\n            // TODO: fix upstream and remove in v9\n            (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                var _targetProp;\n                const isColor = (_targetProp = targetProp) == null ? void 0 : _targetProp.isColor;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && rootState && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            var _currentInstance$key;\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if ((_currentInstance$key = currentInstance[key]) != null && _currentInstance$key.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_5__.UnsignedByteType && rootState) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState && localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Get the initial root state's internals\n        const internal = findInitialRoot(instance).getState().internal;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = internal.interaction.indexOf(instance);\n        if (index > -1) internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f3, _instance$__r3f3$root;\n    const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target.isVector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_5__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let useFrameInProgress = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        useFrameInProgress = true;\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        useFrameInProgress = false;\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState(), frames));\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        if (frames > 1) {\n            // legacy support for people using frames parameters\n            // Increase frames, do not go higher than 60\n            state.internal.frames = Math.min(60, state.internal.frames + frames);\n        } else {\n            if (useFrameInProgress) {\n                //called from within a useFrame, it means the user wants an additional frame\n                state.internal.frames = 2;\n            } else {\n                //the user need a new frame, no need to increment further than 1\n                state.internal.frames = 1;\n            }\n        }\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        invalidate,\n        advance\n    };\n}\n/**\r\n * Exposes an object's {@link LocalState}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        let loader = memoizedLoaders.get(Proto);\n        if (!loader) {\n            loader = new Proto();\n            memoizedLoaders.set(Proto, loader);\n        }\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n    };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\r\n * Removes a loaded asset from cache.\r\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_5__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    const defaultStyle = typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement;\n    if (defaultSize) {\n        const { width, height, top, left, updateStyle = defaultStyle } = defaultSize;\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle\n        };\n    } else if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle: defaultStyle\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n            updateStyle: defaultStyle\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_5__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_5__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_5__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) {\n                        applyProps(camera, cameraOptions);\n                        // Preserve user-defined frustum if possible\n                        // https://github.com/pmndrs/react-three-fiber/issues/3160\n                        if (\"aspect\" in cameraOptions || \"left\" in cameraOptions || \"right\" in cameraOptions || \"bottom\" in cameraOptions || \"top\" in cameraOptions) {\n                            camera.manual = true;\n                            camera.updateProjectionMatrix();\n                        }\n                    }\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions != null && sceneOptions.isScene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_5__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_5__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_5__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_5__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            if (!configured) {\n                // Set color space and tonemapping preferences, once\n                const LinearEncoding = 3000;\n                const sRGBEncoding = 3001;\n                applyProps(gl, {\n                    outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                    toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_5__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_5__.ACESFilmicToneMapping\n                });\n            }\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(context.Provider, {\n        value: store,\n        children: children\n    });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Portal, {\n        children: children,\n        container: container,\n        state: state\n    }, container.uuid);\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_5__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            usePortalStore.destroy();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: reconciler.createPortal(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(context.Provider, {\n            value: usePortalStore,\n            children: children\n        }), usePortalStore, null)\n    });\n}\n/**\r\n * Force React to flush any updates inside the provided callback synchronously and immediately.\r\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\r\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\r\n * having to revert to a non-React solution.\r\n */ function flushSync(fn) {\n    // `flushSync` implementation only takes one argument. I don't know what's up with the type declaration for it.\n    return reconciler.flushSync(fn, undefined);\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = createEvents(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLTc3NjcxNmJkLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNtRztBQUNyRztBQUMyQjtBQUNOO0FBQ1I7QUFDbUM7QUFFN0UsSUFBSWUsYUFBYSxXQUFXLEdBQUVDLE9BQU9DLE1BQU0sQ0FBQztJQUMxQ0MsV0FBVztBQUNiO0FBRUEsTUFBTUMsWUFBWSxDQUFDO0FBQ25CLE1BQU1DLFNBQVNDLENBQUFBLFVBQVcsS0FBS0wsT0FBT00sTUFBTSxDQUFDSCxXQUFXRTtBQUN4RCxTQUFTRSxlQUFlQyxNQUFNLEVBQUVDLGlCQUFpQjtJQUMvQyxTQUFTQyxlQUFlQyxJQUFJLEVBQUUsRUFDNUJDLE9BQU8sRUFBRSxFQUNUQyxNQUFNLEVBQ04sR0FBR0MsT0FDSixFQUFFQyxJQUFJO1FBQ0wsSUFBSUMsT0FBTyxDQUFDLEVBQUVMLElBQUksQ0FBQyxFQUFFLENBQUNNLFdBQVcsR0FBRyxFQUFFTixLQUFLTyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3JELElBQUlDO1FBQ0osSUFBSVIsU0FBUyxhQUFhO1lBQ3hCLElBQUlHLE1BQU1NLE1BQU0sS0FBS0MsV0FBVyxNQUFNLElBQUlDLE1BQU07WUFDaEQsTUFBTUYsU0FBU04sTUFBTU0sTUFBTTtZQUMzQkQsV0FBV0ksUUFBUUgsUUFBUTtnQkFDekJUO2dCQUNBSTtnQkFDQUY7Z0JBQ0FXLFdBQVc7WUFDYjtRQUNGLE9BQU87WUFDTCxNQUFNQyxTQUFTdEIsU0FBUyxDQUFDYSxLQUFLO1lBQzlCLElBQUksQ0FBQ1MsUUFBUTtnQkFDWCxNQUFNLElBQUlILE1BQU0sQ0FBQyxLQUFLLEVBQUVOLEtBQUssNEpBQTRKLENBQUM7WUFDNUw7WUFFQSxvREFBb0Q7WUFDcEQsSUFBSSxDQUFDVSxNQUFNQyxPQUFPLENBQUNmLE9BQU8sTUFB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SUFBSW1OO2dCQUNKam9CLE9BQU84TyxPQUFPLENBQUMsQ0FBQ21aLG9CQUFvQnhTLE9BQU96TyxRQUFRLEtBQUssT0FBT2loQixvQkFBb0IsRUFBRSxFQUFFdGtCLE9BQU8sQ0FBQyxDQUFDLENBQUMzQyxNQUFNc1MsTUFBTTtvQkFDM0csSUFBSW1DLFVBQVVBLE9BQU9xRixTQUFTLFlBQVlvTixhQUFhO3dCQUNyRCxNQUFNLENBQUNILFVBQVUsR0FBR2QsVUFBVSxDQUFDam1CLEtBQUs7d0JBQ3BDeVUsT0FBT3FGLFNBQVMsQ0FBQytJLG1CQUFtQixDQUFDa0UsV0FBV3pVO29CQUNsRDtnQkFDRjtnQkFDQTNILElBQUlLLENBQUFBLFFBQVU7d0JBQ1p5SixRQUFROzRCQUNOLEdBQUd6SixNQUFNeUosTUFBTTs0QkFDZnFGLFdBQVd6Wjt3QkFDYjtvQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRStsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1aXNvdW5kLWFnZW50Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L2V2ZW50cy03NzY3MTZiZC5lc20uanM/MDhkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEZWZhdWx0RXZlbnRQcmlvcml0eSwgQ29udGludW91c0V2ZW50UHJpb3JpdHksIERpc2NyZXRlRXZlbnRQcmlvcml0eSwgQ29uY3VycmVudFJvb3QgfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cyc7XG5pbXBvcnQgY3JlYXRlIGZyb20gJ3p1c3RhbmQnO1xuaW1wb3J0IHsgc3VzcGVuZCwgcHJlbG9hZCwgY2xlYXIgfSBmcm9tICdzdXNwZW5kLXJlYWN0JztcbmltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgUmVjb25jaWxlciBmcm9tICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCB7IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssIHVuc3RhYmxlX0lkbGVQcmlvcml0eSB9IGZyb20gJ3NjaGVkdWxlcic7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IGV4dGVuZCA9IG9iamVjdHMgPT4gdm9pZCBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihfcm9vdHMsIF9nZXRFdmVudFByaW9yaXR5KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHtcbiAgICBhcmdzID0gW10sXG4gICAgYXR0YWNoLFxuICAgIC4uLnByb3BzXG4gIH0sIHJvb3QpIHtcbiAgICBsZXQgbmFtZSA9IGAke3R5cGVbMF0udG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSl9YDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICBpZiAocHJvcHMub2JqZWN0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIVwiKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHByb3BzLm9iamVjdDtcbiAgICAgIGluc3RhbmNlID0gcHJlcGFyZShvYmplY3QsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFIzRjogJHtuYW1lfSBpcyBub3QgcGFydCBvZiB0aGUgVEhSRUUgbmFtZXNwYWNlISBEaWQgeW91IGZvcmdldCB0byBleHRlbmQ/IFNlZTogaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL29iamVjdHMjdXNpbmctM3JkLXBhcnR5LW9iamVjdHMtZGVjbGFyYXRpdmVseWApO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgIC8vIEluc3RhbmNpYXRlIG5ldyBvYmplY3QsIGxpbmsgaXQgdG8gdGhlIHJvb3RcbiAgICAgIC8vIEFwcGVuZCBtZW1vaXplZCBwcm9wcyB3aXRoIGFyZ3Mgc28gaXQncyBub3QgZm9yZ290dGVuXG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUobmV3IHRhcmdldCguLi5hcmdzKSwge1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290LFxuICAgICAgICBhdHRhY2gsXG4gICAgICAgIC8vIFNhdmUgYXJncyBpbiBjYXNlIHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgbGF0ZXIgZm9yIEhNUlxuICAgICAgICBtZW1vaXplZFByb3BzOiB7XG4gICAgICAgICAgYXJnc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICBpZiAoaW5zdGFuY2UuX19yM2YuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5pc0J1ZmZlckdlb21ldHJ5KSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnZ2VvbWV0cnknO2Vsc2UgaWYgKGluc3RhbmNlLmlzTWF0ZXJpYWwpIGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9ICdtYXRlcmlhbCc7XG4gICAgfVxuXG4gICAgLy8gSXQgc2hvdWxkIE5PVCBjYWxsIG9uVXBkYXRlIG9uIG9iamVjdCBpbnN0YW5jaWF0aW9uLCBiZWNhdXNlIGl0IGhhc24ndCBiZWVuIGFkZGVkIHRvIHRoZVxuICAgIC8vIHZpZXcgeWV0LiBJZiB0aGUgY2FsbGJhY2sgcmVsaWVzIG9uIHJlZmVyZW5jZXMgZm9yIGluc3RhbmNlLCB0aGV5IHdvbid0IGJlIHJlYWR5IHlldCwgdGhpcyBpc1xuICAgIC8vIHdoeSBpdCBwYXNzZXMgXCJ0cnVlXCIgaGVyZVxuICAgIC8vIFRoZXJlIGlzIG5vIHJlYXNvbiB0byBhcHBseSBwcm9wcyB0byBpbmplY3RzXG4gICAgaWYgKG5hbWUgIT09ICdpbmplY3QnKSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIHByb3BzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmLCBfcGFyZW50SW5zdGFuY2UkX19yM2Y7XG4gICAgICAvLyBUaGUgYXR0YWNoIGF0dHJpYnV0ZSBpbXBsaWVzIHRoYXQgdGhlIG9iamVjdCBhdHRhY2hlcyBpdHNlbGYgb24gdGhlIHBhcmVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICAvLyBhZGQgaW4gdGhlIHVzdWFsIHBhcmVudC1jaGlsZCB3YXlcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuYWRkKGNoaWxkKTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBpcyBmb3IgYW55dGhpbmcgdGhhdCB1c2VkIGF0dGFjaCwgYW5kIGZvciBub24tT2JqZWN0M0RzIHRoYXQgZG9uJ3QgZ2V0IGF0dGFjaGVkIHRvIHByb3BzO1xuICAgICAgLy8gdGhhdCBpcywgYW55dGhpbmcgdGhhdCdzIGEgY2hpbGQgaW4gUmVhY3QgYnV0IG5vdCBhIGNoaWxkIGluIHRoZSBzY2VuZWdyYXBoLlxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmLm9iamVjdHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLl9fcjNmKSBwcmVwYXJlKGNoaWxkLCB7fSk7XG4gICAgICBjaGlsZC5fX3IzZi5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIHVwZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmMiwgX3BhcmVudEluc3RhbmNlJF9fcjNmMjtcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjIuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2FkZGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2NoaWxkYWRkZWQnLFxuICAgICAgICAgIGNoaWxkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN0U2libGluZ3MgPSBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbi5maWx0ZXIoc2libGluZyA9PiBzaWJsaW5nICE9PSBjaGlsZCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVzdFNpYmxpbmdzLmluZGV4T2YoYmVmb3JlQ2hpbGQpO1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbiA9IFsuLi5yZXN0U2libGluZ3Muc2xpY2UoMCwgaW5kZXgpLCBjaGlsZCwgLi4ucmVzdFNpYmxpbmdzLnNsaWNlKGluZGV4KV07XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYWRkZWQpIChfcGFyZW50SW5zdGFuY2UkX19yM2YyID0gcGFyZW50SW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcGFyZW50SW5zdGFuY2UkX19yM2YyLm9iamVjdHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLl9fcjNmKSBwcmVwYXJlKGNoaWxkLCB7fSk7XG4gICAgICBjaGlsZC5fX3IzZi5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIHVwZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVJlY3Vyc2l2ZShhcnJheSwgcGFyZW50LCBkaXNwb3NlID0gZmFsc2UpIHtcbiAgICBpZiAoYXJyYXkpIFsuLi5hcnJheV0uZm9yRWFjaChjaGlsZCA9PiByZW1vdmVDaGlsZChwYXJlbnQsIGNoaWxkLCBkaXNwb3NlKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBkaXNwb3NlKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX3BhcmVudEluc3RhbmNlJF9fcjNmMywgX2NoaWxkJF9fcjNmMywgX2NoaWxkJF9fcjNmNTtcbiAgICAgIC8vIENsZWFyIHRoZSBwYXJlbnQgcmVmZXJlbmNlXG4gICAgICBpZiAoY2hpbGQuX19yM2YpIGNoaWxkLl9fcjNmLnBhcmVudCA9IG51bGw7XG4gICAgICAvLyBSZW1vdmUgY2hpbGQgZnJvbSB0aGUgcGFyZW50cyBvYmplY3RzXG4gICAgICBpZiAoKF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgIT0gbnVsbCAmJiBfcGFyZW50SW5zdGFuY2UkX19yM2YzLm9iamVjdHMpIHBhcmVudEluc3RhbmNlLl9fcjNmLm9iamVjdHMgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzLmZpbHRlcih4ID0+IHggIT09IGNoaWxkKTtcbiAgICAgIC8vIFJlbW92ZSBhdHRhY2htZW50XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZjMgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YzLmF0dGFjaCkge1xuICAgICAgICBkZXRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgdmFyIF9jaGlsZCRfX3IzZjQ7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZShjaGlsZCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgLy8gUmVtb3ZlIGludGVyYWN0aXZpdHkgb24gdGhlIGluaXRpYWwgcm9vdFxuICAgICAgICBpZiAoKF9jaGlsZCRfX3IzZjQgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2Y0LnJvb3QpIHtcbiAgICAgICAgICByZW1vdmVJbnRlcmFjdGl2aXR5KGZpbmRJbml0aWFsUm9vdChjaGlsZCksIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBvYmplY3RzIHRvIGJhaWwgb3V0IG9mIHJlY3Vyc2l2ZSBkaXNwb3NlIGFsdG9nZXRoZXIgYnkgcGFzc2luZyBkaXNwb3NlPXtudWxsfVxuICAgICAgLy8gTmV2ZXIgZGlzcG9zZSBvZiBwcmltaXRpdmVzIGJlY2F1c2UgdGhlaXIgc3RhdGUgbWF5IGJlIGtlcHQgb3V0c2lkZSBvZiBSZWFjdCFcbiAgICAgIC8vIEluIG9yZGVyIGZvciBhbiBvYmplY3QgdG8gYmUgYWJsZSB0byBkaXNwb3NlIGl0IGhhcyB0byBoYXZlXG4gICAgICAvLyAgIC0gYSBkaXNwb3NlIG1ldGhvZCxcbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSAvPlxuICAgICAgLy8gICAtIGl0IGNhbm5vdCBiZSBhIFRIUkVFLlNjZW5lLCBiZWNhdXNlIHRocmVlIGhhcyBicm9rZW4gaXQncyBvd24gYXBpXG4gICAgICAvL1xuICAgICAgLy8gU2luY2UgZGlzcG9zYWwgaXMgcmVjdXJzaXZlLCB3ZSBjYW4gY2hlY2sgdGhlIG9wdGlvbmFsIGRpc3Bvc2UgYXJnLCB3aGljaCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgICAgLy8gd2hlbiB0aGUgcmVjb25jaWxlciBjYWxscyBpdCwgYnV0IHRoZW4gY2Fycnkgb3VyIG93biBjaGVjayByZWN1cnNpdmVseVxuICAgICAgY29uc3QgaXNQcmltaXRpdmUgPSAoX2NoaWxkJF9fcjNmNSA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmNS5wcmltaXRpdmU7XG4gICAgICBjb25zdCBzaG91bGREaXNwb3NlID0gIWlzUHJpbWl0aXZlICYmIChkaXNwb3NlID09PSB1bmRlZmluZWQgPyBjaGlsZC5kaXNwb3NlICE9PSBudWxsIDogZGlzcG9zZSk7XG5cbiAgICAgIC8vIFJlbW92ZSBuZXN0ZWQgY2hpbGQgb2JqZWN0cy4gUHJpbWl0aXZlcyBzaG91bGQgbm90IGhhdmUgb2JqZWN0cyBhbmQgY2hpbGRyZW4gdGhhdCBhcmVcbiAgICAgIC8vIGF0dGFjaGVkIHRvIHRoZW0gZGVjbGFyYXRpdmVseSAuLi5cbiAgICAgIGlmICghaXNQcmltaXRpdmUpIHtcbiAgICAgICAgdmFyIF9jaGlsZCRfX3IzZjY7XG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZSgoX2NoaWxkJF9fcjNmNiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmNi5vYmplY3RzLCBjaGlsZCwgc2hvdWxkRGlzcG9zZSk7XG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShjaGlsZC5jaGlsZHJlbiwgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlc1xuICAgICAgZGVsZXRlIGNoaWxkLl9fcjNmO1xuXG4gICAgICAvLyBEaXNwb3NlIGl0ZW0gd2hlbmV2ZXIgdGhlIHJlY29uY2lsZXIgZmVlbHMgbGlrZSBpdFxuICAgICAgaWYgKHNob3VsZERpc3Bvc2UgJiYgY2hpbGQuZGlzcG9zZSAmJiBjaGlsZC50eXBlICE9PSAnU2NlbmUnKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNjaGVkdWxlIGFzeW5jIGF0IHJ1bnRpbWUsIGZsdXNoIHN5bmMgaW4gdGVzdGluZ1xuICAgICAgICBpZiAodHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHVuc3RhYmxlX0lkbGVQcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICAgIGNvbnN0IHBhcmVudCA9IChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZi5wYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgICBjb25zdCBuZXdJbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCBpbnN0YW5jZS5fX3IzZi5yb290KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzEzNDhcbiAgICAvLyBXaGVuIGFyZ3MgY2hhbmdlIHRoZSBpbnN0YW5jZSBoYXMgdG8gYmUgcmUtY29uc3RydWN0ZWQsIHdoaWNoIHRoZW5cbiAgICAvLyBmb3JjZXMgcjNmIHRvIHJlLXBhcmVudCB0aGUgY2hpbGRyZW4gYW5kIG5vbi1zY2VuZSBvYmplY3RzXG4gICAgaWYgKGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fX3IzZikgYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLmNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5fX3IzZik7XG4gICAgfVxuICAgIGluc3RhbmNlLl9fcjNmLm9iamVjdHMuZm9yRWFjaChjaGlsZCA9PiBhcHBlbmRDaGlsZChuZXdJbnN0YW5jZSwgY2hpbGQpKTtcbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gW107XG4gICAgaWYgKCFpbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCkge1xuICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChuZXdJbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIG5ld0luc3RhbmNlLl9fcjNmLmF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdJbnN0YW5jZSk7XG5cbiAgICAvLyBSZS1iaW5kIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICBpZiAobmV3SW5zdGFuY2UucmF5Y2FzdCAmJiBuZXdJbnN0YW5jZS5fX3IzZi5ldmVudENvdW50KSB7XG4gICAgICBjb25zdCByb290U3RhdGUgPSBmaW5kSW5pdGlhbFJvb3QobmV3SW5zdGFuY2UpLmdldFN0YXRlKCk7XG4gICAgICByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChuZXdJbnN0YW5jZSk7XG4gICAgfVxuICAgIFtmaWJlciwgZmliZXIuYWx0ZXJuYXRlXS5mb3JFYWNoKGZpYmVyID0+IHtcbiAgICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgaWYgKGZpYmVyLnJlZikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZmliZXIucmVmID09PSAnZnVuY3Rpb24nKSBmaWJlci5yZWYobmV3SW5zdGFuY2UpO2Vsc2UgZmliZXIucmVmLmN1cnJlbnQgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gRG9uJ3QgaGFuZGxlIHRleHQgaW5zdGFuY2VzLCBtYWtlIGl0IG5vLW9wXG4gIGNvbnN0IGhhbmRsZVRleHRJbnN0YW5jZSA9ICgpID0+IHt9O1xuICBjb25zdCByZWNvbmNpbGVyID0gUmVjb25jaWxlcih7XG4gICAgY3JlYXRlSW5zdGFuY2UsXG4gICAgcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQsXG4gICAgYXBwZW5kSW5pdGlhbENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBpbnNlcnRCZWZvcmUsXG4gICAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgICBpc1ByaW1hcnlSZW5kZXJlcjogZmFsc2UsXG4gICAgc3VwcG9ydHNQZXJzaXN0ZW5jZTogZmFsc2UsXG4gICAgc3VwcG9ydHNIeWRyYXRpb246IGZhbHNlLFxuICAgIG5vVGltZW91dDogLTEsXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcblxuICAgICAgLy8gRG9uJ3QgYXBwZW5kIHRvIHVubW91bnRlZCBjb250YWluZXJcbiAgICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmU7XG4gICAgICBpZiAoIXNjZW5lLl9fcjNmKSByZXR1cm47XG5cbiAgICAgIC8vIExpbmsgY3VycmVudCByb290IHRvIHRoZSBkZWZhdWx0IHNjZW5lXG4gICAgICBzY2VuZS5fX3IzZi5yb290ID0gY29udGFpbmVyO1xuICAgICAgYXBwZW5kQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcbiAgICAgIHJlbW92ZUNoaWxkKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLCBjaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcbiAgICAgIGluc2VydEJlZm9yZShzY2VuZSwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGdldFJvb3RIb3N0Q29udGV4dDogKCkgPT4gbnVsbCxcbiAgICBnZXRDaGlsZEhvc3RDb250ZXh0OiBwYXJlbnRIb3N0Q29udGV4dCA9PiBwYXJlbnRIb3N0Q29udGV4dCxcbiAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YyIDoge307XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4gICAgICAvLyBSZXR1cm5pbmcgdHJ1ZSB3aWxsIHRyaWdnZXIgY29tbWl0TW91bnRcbiAgICAgIHJldHVybiBCb29sZWFuKGxvY2FsU3RhdGUuaGFuZGxlcnMpO1xuICAgIH0sXG4gICAgcHJlcGFyZVVwZGF0ZShpbnN0YW5jZSwgX3R5cGUsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjM7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YzIDoge307XG5cbiAgICAgIC8vIENyZWF0ZSBkaWZmLXNldHNcbiAgICAgIGlmIChsb2NhbFN0YXRlLnByaW1pdGl2ZSAmJiBuZXdQcm9wcy5vYmplY3QgJiYgbmV3UHJvcHMub2JqZWN0ICE9PSBpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gW3RydWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRhdGEgb2JqZWN0LCBsZXQncyBleHRyYWN0IGNyaXRpY2FsIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzTmV3ID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNOLFxuICAgICAgICAgIC4uLnJlc3ROZXdcbiAgICAgICAgfSA9IG5ld1Byb3BzO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJnczogYXJnc09sZCA9IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBjTyxcbiAgICAgICAgICAuLi5yZXN0T2xkXG4gICAgICAgIH0gPSBvbGRQcm9wcztcblxuICAgICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzTmV3KSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IHRoZSBhcmdzIHByb3AgbXVzdCBiZSBhbiBhcnJheSEnKTtcblxuICAgICAgICAvLyBJZiBpdCBoYXMgbmV3IHByb3BzIG9yIGFyZ3VtZW50cywgdGhlbiBpdCBuZWVkcyB0byBiZSByZS1pbnN0YW50aWF0ZWRcbiAgICAgICAgaWYgKGFyZ3NOZXcuc29tZSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSAhPT0gYXJnc09sZFtpbmRleF0pKSByZXR1cm4gW3RydWVdO1xuICAgICAgICAvLyBDcmVhdGUgYSBkaWZmLXNldCwgZmxhZyBpZiB0aGVyZSBhcmUgYW55IGNoYW5nZXNcbiAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZQcm9wcyhpbnN0YW5jZSwgcmVzdE5ldywgcmVzdE9sZCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkaWZmLmNoYW5nZXMubGVuZ3RoKSByZXR1cm4gW2ZhbHNlLCBkaWZmXTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZG8gbm90IHRvdWNoIHRoZSBpbnN0YW5jZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgW3JlY29uc3RydWN0LCBkaWZmXSwgdHlwZSwgX29sZFByb3BzLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICAgIC8vIFJlY29uc3RydWN0IHdoZW4gYXJncyBvciA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSBoYXZlIGNoYW5nZXNcbiAgICAgIGlmIChyZWNvbnN0cnVjdCkgc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcik7XG4gICAgICAvLyBPdGhlcndpc2UganVzdCBvdmVyd3JpdGUgcHJvcHNcbiAgICAgIGVsc2UgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkaWZmKTtcbiAgICB9LFxuICAgIGNvbW1pdE1vdW50KGluc3RhbmNlLCBfdHlwZSwgX3Byb3BzLCBfaW50KSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNDtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgZXZlbnRzIGFyZSBvbmx5IGFkZGVkIG9uY2UgdG8gdGhlIGNlbnRyYWwgY29udGFpbmVyIG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmNCA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNCA6IHt9O1xuICAgICAgaWYgKGluc3RhbmNlLnJheWNhc3QgJiYgbG9jYWxTdGF0ZS5oYW5kbGVycyAmJiBsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgZmluZEluaXRpYWxSb290KGluc3RhbmNlKS5nZXRTdGF0ZSgpLmludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UHVibGljSW5zdGFuY2U6IGluc3RhbmNlID0+IGluc3RhbmNlLFxuICAgIHByZXBhcmVGb3JDb21taXQ6ICgpID0+IG51bGwsXG4gICAgcHJlcGFyZVBvcnRhbE1vdW50OiBjb250YWluZXIgPT4gcHJlcGFyZShjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSksXG4gICAgcmVzZXRBZnRlckNvbW1pdDogKCkgPT4ge30sXG4gICAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6ICgpID0+IGZhbHNlLFxuICAgIGNsZWFyQ29udGFpbmVyOiAoKSA9PiBmYWxzZSxcbiAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y1O1xuICAgICAgLy8gRGV0YWNoIHdoaWxlIHRoZSBpbnN0YW5jZSBpcyBoaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNSA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNSA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBkZXRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCkgaW5zdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjY7XG4gICAgICAvLyBSZS1hdHRhY2ggd2hlbiB0aGUgaW5zdGFuY2UgaXMgdW5oaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNiA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBhdHRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCAmJiBwcm9wcy52aXNpYmxlID09IG51bGwgfHwgcHJvcHMudmlzaWJsZSkgaW5zdGFuY2UudmlzaWJsZSA9IHRydWU7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgY3JlYXRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIHVuaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkxNjM1Njg3NFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBnZXRDdXJyZW50RXZlbnRQcmlvcml0eTogKCkgPT4gX2dldEV2ZW50UHJpb3JpdHkgPyBfZ2V0RXZlbnRQcmlvcml0eSgpIDogRGVmYXVsdEV2ZW50UHJpb3JpdHksXG4gICAgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBhZnRlckFjdGl2ZUluc3RhbmNlQmx1cjogKCkgPT4ge30sXG4gICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlOiAoKSA9PiB7fSxcbiAgICBub3c6IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXMuZnVuKHBlcmZvcm1hbmNlLm5vdykgPyBwZXJmb3JtYW5jZS5ub3cgOiBpcy5mdW4oRGF0ZS5ub3cpID8gRGF0ZS5ub3cgOiAoKSA9PiAwLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkyMDg4MzUwM1xuICAgIHNjaGVkdWxlVGltZW91dDogaXMuZnVuKHNldFRpbWVvdXQpID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZCxcbiAgICBjYW5jZWxUaW1lb3V0OiBpcy5mdW4oY2xlYXJUaW1lb3V0KSA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByZWNvbmNpbGVyLFxuICAgIGFwcGx5UHJvcHM6IGFwcGx5UHJvcHMkMVxuICB9O1xufVxuXG52YXIgX3dpbmRvdyRkb2N1bWVudCwgX3dpbmRvdyRuYXZpZ2F0b3I7XG4vKipcclxuICogUmV0dXJucyBgdHJ1ZWAgd2l0aCBjb3JyZWN0IFRTIHR5cGUgaW5mZXJlbmNlIGlmIGFuIG9iamVjdCBoYXMgYSBjb25maWd1cmFibGUgY29sb3Igc3BhY2UgKHNpbmNlIHIxNTIpLlxyXG4gKi9cbmNvbnN0IGhhc0NvbG9yU3BhY2UgPSBvYmplY3QgPT4gJ2NvbG9yU3BhY2UnIGluIG9iamVjdCB8fCAnb3V0cHV0Q29sb3JTcGFjZScgaW4gb2JqZWN0O1xuLyoqXHJcbiAqIFRoZSBjdXJyZW50IFRIUkVFLkNvbG9yTWFuYWdlbWVudCBpbnN0YW5jZSwgaWYgcHJlc2VudC5cclxuICovXG5jb25zdCBnZXRDb2xvck1hbmFnZW1lbnQgPSAoKSA9PiB7XG4gIHZhciBfQ29sb3JNYW5hZ2VtZW50O1xuICByZXR1cm4gKF9Db2xvck1hbmFnZW1lbnQgPSBjYXRhbG9ndWUuQ29sb3JNYW5hZ2VtZW50KSAhPSBudWxsID8gX0NvbG9yTWFuYWdlbWVudCA6IG51bGw7XG59O1xuY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcblxuLyoqXHJcbiAqIEFuIFNTUi1mcmllbmRseSB1c2VMYXlvdXRFZmZlY3QuXHJcbiAqXHJcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAqIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXHJcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDkyN1xyXG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF93aW5kb3ckZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQpICE9IG51bGwgJiYgX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50IHx8ICgoX3dpbmRvdyRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRuYXZpZ2F0b3IucHJvZHVjdCkgPT09ICdSZWFjdE5hdGl2ZScpID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlTXV0YWJsZUNhbGxiYWNrKGZuKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihmbik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAocmVmLmN1cnJlbnQgPSBmbiksIFtmbl0pO1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuRXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSAoKSA9PiAoe1xuICBlcnJvcjogdHJ1ZVxufSk7XG5jb25zdCBERUZBVUxUID0gJ19fZGVmYXVsdCc7XG5jb25zdCBERUZBVUxUUyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlzRGlmZlNldCA9IGRlZiA9PiBkZWYgJiYgISFkZWYubWVtb2l6ZWQgJiYgISFkZWYuY2hhbmdlcztcbmZ1bmN0aW9uIGNhbGN1bGF0ZURwcihkcHIpIHtcbiAgdmFyIF93aW5kb3ckZGV2aWNlUGl4ZWxSYTtcbiAgLy8gRXJyIG9uIHRoZSBzaWRlIG9mIHByb2dyZXNzIGJ5IGFzc3VtaW5nIDJ4IGRwciBpZiB3ZSBjYW4ndCBkZXRlY3QgaXRcbiAgLy8gVGhpcyB3aWxsIGhhcHBlbiBpbiB3b3JrZXJzIHdoZXJlIHdpbmRvdyBpcyBkZWZpbmVkIGJ1dCBkcHIgaXNuJ3QuXG4gIGNvbnN0IHRhcmdldCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSAhPSBudWxsID8gX3dpbmRvdyRkZXZpY2VQaXhlbFJhIDogMiA6IDE7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRwcikgPyBNYXRoLm1pbihNYXRoLm1heChkcHJbMF0sIHRhcmdldCksIGRwclsxXSkgOiBkcHI7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGluc3RhbmNlIHJvb3Qgc3RhdGVcclxuICovXG5jb25zdCBnZXRSb290U3RhdGUgPSBvYmogPT4ge1xuICB2YXIgX3IzZjtcbiAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5yb290LmdldFN0YXRlKCk7XG59O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5zdGFuY2VzIGluaXRpYWwgKG91dG1vc3QpIHJvb3RcclxuICovXG5mdW5jdGlvbiBmaW5kSW5pdGlhbFJvb3QoY2hpbGQpIHtcbiAgbGV0IHJvb3QgPSBjaGlsZC5fX3IzZi5yb290O1xuICB3aGlsZSAocm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdCkgcm9vdCA9IHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3Q7XG4gIHJldHVybiByb290O1xufVxuLy8gQSBjb2xsZWN0aW9uIG9mIGNvbXBhcmUgZnVuY3Rpb25zXG5jb25zdCBpcyA9IHtcbiAgb2JqOiBhID0+IGEgPT09IE9iamVjdChhKSAmJiAhaXMuYXJyKGEpICYmIHR5cGVvZiBhICE9PSAnZnVuY3Rpb24nLFxuICBmdW46IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbicsXG4gIHN0cjogYSA9PiB0eXBlb2YgYSA9PT0gJ3N0cmluZycsXG4gIG51bTogYSA9PiB0eXBlb2YgYSA9PT0gJ251bWJlcicsXG4gIGJvbzogYSA9PiB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nLFxuICB1bmQ6IGEgPT4gYSA9PT0gdm9pZCAwLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSB8fCBpcy5ib28oYSkpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzT2JqID0gaXMub2JqKGEpO1xuICAgIGlmIChpc09iaiAmJiBvYmplY3RzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNBcnIgPSBpcy5hcnIoYSk7XG4gICAgaWYgKGlzQXJyICYmIGFycmF5cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIC8vIEFycmF5IG9yIE9iamVjdCwgc2hhbGxvdyBjb21wYXJlIGZpcnN0IHRvIHNlZSBpZiBpdCdzIGEgbWF0Y2hcbiAgICBpZiAoKGlzQXJyIHx8IGlzT2JqKSAmJiBhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBMYXN0IHJlc29ydCwgZ28gdGhyb3VnaCBrZXlzXG4gICAgbGV0IGk7XG4gICAgLy8gQ2hlY2sgaWYgYSBoYXMgYWxsIHRoZSBrZXlzIG9mIGJcbiAgICBmb3IgKGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIHZhbHVlcyBiZXR3ZWVuIGtleXMgbWF0Y2hcbiAgICBpZiAoaXNPYmogJiYgYXJyYXlzID09PSAnc2hhbGxvdycgJiYgb2JqZWN0cyA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmICghaXMuZXF1KGFbaV0sIGJbaV0sIHtcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBvYmplY3RzOiAncmVmZXJlbmNlJ1xuICAgICAgfSkpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBpIGlzIHVuZGVmaW5lZFxuICAgIGlmIChpcy51bmQoaSkpIHtcbiAgICAgIC8vIElmIGJvdGggYXJyYXlzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNBcnIgJiYgYS5sZW5ndGggPT09IDAgJiYgYi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gSWYgYm90aCBvYmplY3RzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNPYmogJiYgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKGIpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBPdGhlcndpc2UgbWF0Y2ggdGhlbSBieSB2YWx1ZVxuICAgICAgaWYgKGEgIT09IGIpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBDb2xsZWN0cyBub2RlcyBhbmQgbWF0ZXJpYWxzIGZyb20gYSBUSFJFRS5PYmplY3QzRC5cclxuICovXG5mdW5jdGlvbiBidWlsZEdyYXBoKG9iamVjdCkge1xuICBjb25zdCBkYXRhID0ge1xuICAgIG5vZGVzOiB7fSxcbiAgICBtYXRlcmlhbHM6IHt9XG4gIH07XG4gIGlmIChvYmplY3QpIHtcbiAgICBvYmplY3QudHJhdmVyc2Uob2JqID0+IHtcbiAgICAgIGlmIChvYmoubmFtZSkgZGF0YS5ub2Rlc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgICBpZiAob2JqLm1hdGVyaWFsICYmICFkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0pIGRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSA9IG9iai5tYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gRGlzcG9zZXMgYW4gb2JqZWN0IGFuZCBhbGwgaXRzIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGRpc3Bvc2Uob2JqKSB7XG4gIGlmIChvYmouZGlzcG9zZSAmJiBvYmoudHlwZSAhPT0gJ1NjZW5lJykgb2JqLmRpc3Bvc2UoKTtcbiAgZm9yIChjb25zdCBwIGluIG9iaikge1xuICAgIHAuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogcC5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIG9ialtwXTtcbiAgfVxufVxuXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgc2NlbmUgY2FycmllcyBhIHNtYWxsIExvY2FsU3RhdGUgZGVzY3JpcHRvclxuZnVuY3Rpb24gcHJlcGFyZShvYmplY3QsIHN0YXRlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0O1xuICBpbnN0YW5jZS5fX3IzZiA9IHtcbiAgICB0eXBlOiAnJyxcbiAgICByb290OiBudWxsLFxuICAgIHByZXZpb3VzQXR0YWNoOiBudWxsLFxuICAgIG1lbW9pemVkUHJvcHM6IHt9LFxuICAgIGV2ZW50Q291bnQ6IDAsXG4gICAgaGFuZGxlcnM6IHt9LFxuICAgIG9iamVjdHM6IFtdLFxuICAgIHBhcmVudDogbnVsbCxcbiAgICAuLi5zdGF0ZVxuICB9O1xuICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZShpbnN0YW5jZSwga2V5KSB7XG4gIGxldCB0YXJnZXQgPSBpbnN0YW5jZTtcbiAgaWYgKGtleS5pbmNsdWRlcygnLScpKSB7XG4gICAgY29uc3QgZW50cmllcyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxhc3QgPSBlbnRyaWVzLnBvcCgpO1xuICAgIHRhcmdldCA9IGVudHJpZXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5OiBsYXN0XG4gICAgfTtcbiAgfSBlbHNlIHJldHVybiB7XG4gICAgdGFyZ2V0LFxuICAgIGtleVxuICB9O1xufVxuXG4vLyBDaGVja3MgaWYgYSBkYXNoLWNhc2VkIHN0cmluZyBlbmRzIHdpdGggYW4gaW50ZWdlclxuY29uc3QgSU5ERVhfUkVHRVggPSAvLVxcZCskLztcbmZ1bmN0aW9uIGF0dGFjaChwYXJlbnQsIGNoaWxkLCB0eXBlKSB7XG4gIGlmIChpcy5zdHIodHlwZSkpIHtcbiAgICAvLyBJZiBhdHRhY2hpbmcgaW50byBhbiBhcnJheSAoZm9vLTApLCBjcmVhdGUgb25lXG4gICAgaWYgKElOREVYX1JFR0VYLnRlc3QodHlwZSkpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSB0eXBlLnJlcGxhY2UoSU5ERVhfUkVHRVgsICcnKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXlcbiAgICAgIH0gPSByZXNvbHZlKHBhcmVudCwgcm9vdCk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pKSB0YXJnZXRba2V5XSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHR5cGUpO1xuICAgIGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoID0gdGFyZ2V0W2tleV07XG4gICAgdGFyZ2V0W2tleV0gPSBjaGlsZDtcbiAgfSBlbHNlIGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoID0gdHlwZShwYXJlbnQsIGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGRldGFjaChwYXJlbnQsIGNoaWxkLCB0eXBlKSB7XG4gIHZhciBfY2hpbGQkX19yM2YsIF9jaGlsZCRfX3IzZjI7XG4gIGlmIChpcy5zdHIodHlwZSkpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHR5cGUpO1xuICAgIGNvbnN0IHByZXZpb3VzID0gY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2g7XG4gICAgLy8gV2hlbiB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIHVuZGVmaW5lZCwgaXQgbWVhbnMgdGhlIHZhbHVlIHdhcyBuZXZlciBzZXQgdG8gYmVnaW4gd2l0aFxuICAgIGlmIChwcmV2aW91cyA9PT0gdW5kZWZpbmVkKSBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgLy8gT3RoZXJ3aXNlIHNldCB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICBlbHNlIHRhcmdldFtrZXldID0gcHJldmlvdXM7XG4gIH0gZWxzZSAoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2ggPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZi5wcmV2aW91c0F0dGFjaChwYXJlbnQsIGNoaWxkKTtcbiAgKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2NoaWxkJF9fcjNmMi5wcmV2aW91c0F0dGFjaDtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgYSBzZXQgb2YgY2hhbmdlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gZGlmZlByb3BzKGluc3RhbmNlLCB7XG4gIGNoaWxkcmVuOiBjTixcbiAga2V5OiBrTixcbiAgcmVmOiByTixcbiAgLi4ucHJvcHNcbn0sIHtcbiAgY2hpbGRyZW46IGNQLFxuICBrZXk6IGtQLFxuICByZWY6IHJQLFxuICAuLi5wcmV2aW91c1xufSA9IHt9LCByZW1vdmUgPSBmYWxzZSkge1xuICBjb25zdCBsb2NhbFN0YXRlID0gaW5zdGFuY2UuX19yM2Y7XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwcm9wcyk7XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcblxuICAvLyBDYXRjaCByZW1vdmVkIHByb3BzLCBwcmVwZW5kIHRoZW0gc28gdGhleSBjYW4gYmUgcmVzZXQgb3IgcmVtb3ZlZFxuICBpZiAocmVtb3ZlKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXlzID0gT2JqZWN0LmtleXMocHJldmlvdXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldmlvdXNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByZXZpb3VzS2V5c1tpXSkpIGVudHJpZXMudW5zaGlmdChbcHJldmlvdXNLZXlzW2ldLCBERUZBVUxUICsgJ3JlbW92ZSddKTtcbiAgICB9XG4gIH1cbiAgZW50cmllcy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICAgIC8vIEJhaWwgb3V0IG9uIHByaW1pdGl2ZSBvYmplY3RcbiAgICBpZiAoKF9pbnN0YW5jZSRfX3IzZiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZi5wcmltaXRpdmUgJiYga2V5ID09PSAnb2JqZWN0JykgcmV0dXJuO1xuICAgIC8vIFdoZW4gcHJvcHMgbWF0Y2ggYmFpbCBvdXRcbiAgICBpZiAoaXMuZXF1KHZhbHVlLCBwcmV2aW91c1trZXldKSkgcmV0dXJuO1xuICAgIC8vIENvbGxlY3QgaGFuZGxlcnMgYW5kIGJhaWwgb3V0XG4gICAgaWYgKC9eb24oUG9pbnRlcnxDbGlja3xEb3VibGVDbGlja3xDb250ZXh0TWVudXxXaGVlbCkvLnRlc3Qoa2V5KSkgcmV0dXJuIGNoYW5nZXMucHVzaChba2V5LCB2YWx1ZSwgdHJ1ZSwgW11dKTtcbiAgICAvLyBTcGxpdCBkYXNoZWQgcHJvcHNcbiAgICBsZXQgZW50cmllcyA9IFtdO1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkgZW50cmllcyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNoYW5nZXMucHVzaChba2V5LCB2YWx1ZSwgZmFsc2UsIGVudHJpZXNdKTtcblxuICAgIC8vIFJlc2V0IHBpZXJjZWQgcHJvcHNcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgICBpZiAocHJvcC5zdGFydHNXaXRoKGAke2tleX0tYCkpIGNoYW5nZXMucHVzaChbcHJvcCwgdmFsdWUsIGZhbHNlLCBwcm9wLnNwbGl0KCctJyldKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtZW1vaXplZCA9IHtcbiAgICAuLi5wcm9wc1xuICB9O1xuICBpZiAobG9jYWxTdGF0ZSAhPSBudWxsICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlICE9IG51bGwgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmFyZ3MpIG1lbW9pemVkLmFyZ3MgPSBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncztcbiAgaWYgKGxvY2FsU3RhdGUgIT0gbnVsbCAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMgJiYgbG9jYWxTdGF0ZSAhPSBudWxsICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2gpIG1lbW9pemVkLmF0dGFjaCA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2g7XG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9O1xufVxuY29uc3QgX19ERVZfXyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgYSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGFwcGx5UHJvcHMkMShpbnN0YW5jZSwgZGF0YSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgLy8gRmlsdGVyIGVxdWFscywgZXZlbnRzIGFuZCByZXNlcnZlZCBwcm9wc1xuICBjb25zdCBsb2NhbFN0YXRlID0gaW5zdGFuY2UuX19yM2Y7XG4gIGNvbnN0IHJvb3QgPSBsb2NhbFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBsb2NhbFN0YXRlLnJvb3Q7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUoKTtcbiAgY29uc3Qge1xuICAgIG1lbW9pemVkLFxuICAgIGNoYW5nZXNcbiAgfSA9IGlzRGlmZlNldChkYXRhKSA/IGRhdGEgOiBkaWZmUHJvcHMoaW5zdGFuY2UsIGRhdGEpO1xuICBjb25zdCBwcmV2SGFuZGxlcnMgPSBsb2NhbFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBsb2NhbFN0YXRlLmV2ZW50Q291bnQ7XG5cbiAgLy8gUHJlcGFyZSBtZW1vaXplZCBwcm9wc1xuICBpZiAoaW5zdGFuY2UuX19yM2YpIGluc3RhbmNlLl9fcjNmLm1lbW9pemVkUHJvcHMgPSBtZW1vaXplZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtrZXksIHZhbHVlLCBpc0V2ZW50LCBrZXlzXSA9IGNoYW5nZXNbaV07XG5cbiAgICAvLyBBbGlhcyAob3V0cHV0KWVuY29kaW5nID0+IChvdXRwdXQpY29sb3JTcGFjZSAoc2luY2UgcjE1MilcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjgyOVxuICAgIGlmIChoYXNDb2xvclNwYWNlKGluc3RhbmNlKSkge1xuICAgICAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgICAgIGNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xuICAgICAgY29uc3QgTGluZWFyU1JHQkNvbG9yU3BhY2UgPSAnc3JnYi1saW5lYXInO1xuICAgICAgaWYgKGtleSA9PT0gJ2VuY29kaW5nJykge1xuICAgICAgICBrZXkgPSAnY29sb3JTcGFjZSc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ291dHB1dEVuY29kaW5nJykge1xuICAgICAgICBrZXkgPSAnb3V0cHV0Q29sb3JTcGFjZSc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBsZXQgdGFyZ2V0UHJvcCA9IGN1cnJlbnRJbnN0YW5jZVtrZXldO1xuXG4gICAgLy8gUmV2b2x2ZSBkYXNoZWQgcHJvcHNcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldFByb3AgPSBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGF0b21pYywgaXQgZm9yY2VzIHVzIHRvIHN3aXRjaCB0aGUgcm9vdFxuICAgICAgaWYgKCEodGFyZ2V0UHJvcCAmJiB0YXJnZXRQcm9wLnNldCkpIHtcbiAgICAgICAgY29uc3QgW25hbWUsIC4uLnJldmVyc2VFbnRyaWVzXSA9IGtleXMucmV2ZXJzZSgpO1xuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSByZXZlcnNlRW50cmllcy5yZXZlcnNlKCkucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICAgICAga2V5ID0gbmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMTIwOVxuICAgIC8vIEhNUi9mYXN0LXJlZnJlc2ggcmVsaWVzIG9uIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCBvdXQgcHJvcHMsIGJ1dCB0aHJlZWpzXG4gICAgLy8gaGFzIG5vIG1lYW5zIHRvIGRvIHRoaXMuIEhlbmNlIHdlIGN1cmF0ZSBhIHNtYWxsIGNvbGxlY3Rpb24gb2YgdmFsdWUtY2xhc3Nlc1xuICAgIC8vIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25zdHJ1Y3Rvci9zZXQgYXJndW1lbnRzXG4gICAgLy8gRm9yIHJlbW92ZWQgcHJvcHMsIHRyeSB0byBzZXQgZGVmYXVsdCB2YWx1ZXMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHZhbHVlID09PSBERUZBVUxUICsgJ3JlbW92ZScpIHtcbiAgICAgIGlmIChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgYmxhbmsgc2xhdGUgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3B5IHRoZSBwYXJ0aWN1bGFyIHBhcmFtZXRlci5cbiAgICAgICAgbGV0IGN0b3IgPSBERUZBVUxUUy5nZXQoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKCFjdG9yKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGN0b3IgPSBuZXcgY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgREVGQVVMVFMuc2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvciwgY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBjdG9yW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIGNvbnN0cnVjdG9yLCBqdXN0IHNldCBpdCB0byAwXG4gICAgICAgIHZhbHVlID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggcG9pbnRlciBldmVudHMgLi4uXG4gICAgaWYgKGlzRXZlbnQgJiYgbG9jYWxTdGF0ZSkge1xuICAgICAgaWYgKHZhbHVlKSBsb2NhbFN0YXRlLmhhbmRsZXJzW2tleV0gPSB2YWx1ZTtlbHNlIGRlbGV0ZSBsb2NhbFN0YXRlLmhhbmRsZXJzW2tleV07XG4gICAgICBsb2NhbFN0YXRlLmV2ZW50Q291bnQgPSBPYmplY3Qua2V5cyhsb2NhbFN0YXRlLmhhbmRsZXJzKS5sZW5ndGg7XG4gICAgfVxuICAgIC8vIFNwZWNpYWwgdHJlYXRtZW50IGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3Igc2V0L2NvcHksIGFuZCBsYXllcnNcbiAgICBlbHNlIGlmICh0YXJnZXRQcm9wICYmIHRhcmdldFByb3Auc2V0ICYmICh0YXJnZXRQcm9wLmNvcHkgfHwgdGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykpIHtcbiAgICAgIC8vIElmIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHRhcmdldFByb3AuZnJvbUFycmF5KSB0YXJnZXRQcm9wLmZyb21BcnJheSh2YWx1ZSk7ZWxzZSB0YXJnZXRQcm9wLnNldCguLi52YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGFnYWluIHRhcmdldC5jb3B5KGNsYXNzKSBuZXh0IC4uLlxuICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcC5jb3B5ICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIChcbiAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIG1heSBicmVhayBzdHJpY3QgaWRlbnRpdHkgY2hlY2tzIGJ5IGR1cGxpY2F0aW5nIHZlcnNpb25zIG9mIHRocmVlLmpzLlxuICAgICAgLy8gTG9vc2VuIHRvIHVubWluaWZpZWQgbmFtZXMsIGlnbm9yaW5nIGRlc2NlbmRlbnRzLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjg1NlxuICAgICAgLy8gVE9ETzogZml4IHVwc3RyZWFtIGFuZCByZW1vdmUgaW4gdjlcbiAgICAgIF9fREVWX18gPyB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yLm5hbWUgPT09IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgOiB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yID09PSB2YWx1ZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGFyZ2V0UHJvcC5jb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vdGhpbmcgZWxzZSBmaXRzLCBqdXN0IHNldCB0aGUgc2luZ2xlIHZhbHVlLCBpZ25vcmUgdW5kZWZpbmVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yNzRcbiAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF90YXJnZXRQcm9wO1xuICAgICAgICBjb25zdCBpc0NvbG9yID0gKF90YXJnZXRQcm9wID0gdGFyZ2V0UHJvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXRQcm9wLmlzQ29sb3I7XG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgYXJyYXkgc2NhbGFyc1xuICAgICAgICBpZiAoIWlzQ29sb3IgJiYgdGFyZ2V0UHJvcC5zZXRTY2FsYXIpIHRhcmdldFByb3Auc2V0U2NhbGFyKHZhbHVlKTtcbiAgICAgICAgLy8gTGF5ZXJzIGhhdmUgbm8gY29weSBmdW5jdGlvbiwgd2UgbXVzdCB0aGVyZWZvcmUgY29weSB0aGUgbWFzayBwcm9wZXJ0eVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzICYmIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSB0YXJnZXRQcm9wLm1hc2sgPSB2YWx1ZS5tYXNrO1xuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBzZXQgLi4uXG4gICAgICAgIGVsc2UgdGFyZ2V0UHJvcC5zZXQodmFsdWUpO1xuICAgICAgICAvLyBGb3IgdmVyc2lvbnMgb2YgdGhyZWUgd2hpY2ggZG9uJ3Qgc3VwcG9ydCBUSFJFRS5Db2xvck1hbmFnZW1lbnQsXG4gICAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIGNvbG9yc1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgICAgaWYgKCFnZXRDb2xvck1hbmFnZW1lbnQoKSAmJiByb290U3RhdGUgJiYgIXJvb3RTdGF0ZS5saW5lYXIgJiYgaXNDb2xvcikgdGFyZ2V0UHJvcC5jb252ZXJ0U1JHQlRvTGluZWFyKCk7XG4gICAgICB9XG4gICAgICAvLyBFbHNlLCBqdXN0IG92ZXJ3cml0ZSB0aGUgdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jdXJyZW50SW5zdGFuY2Uka2V5O1xuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0gPSB2YWx1ZTtcblxuICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgdGV4dHVyZXMsIGZvciBub3cgLi4uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgIGlmICgoX2N1cnJlbnRJbnN0YW5jZSRrZXkgPSBjdXJyZW50SW5zdGFuY2Vba2V5XSkgIT0gbnVsbCAmJiBfY3VycmVudEluc3RhbmNlJGtleS5pc1RleHR1cmUgJiZcbiAgICAgIC8vIHNSR0IgdGV4dHVyZXMgbXVzdCBiZSBSR0JBOCBzaW5jZSByMTM3IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzEyOVxuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0uZm9ybWF0ID09PSBUSFJFRS5SR0JBRm9ybWF0ICYmIGN1cnJlbnRJbnN0YW5jZVtrZXldLnR5cGUgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgJiYgcm9vdFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcbiAgICAgICAgaWYgKGhhc0NvbG9yU3BhY2UodGV4dHVyZSkgJiYgaGFzQ29sb3JTcGFjZShyb290U3RhdGUuZ2wpKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSByb290U3RhdGUuZ2wub3V0cHV0Q29sb3JTcGFjZTtlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSByb290U3RhdGUuZ2wub3V0cHV0RW5jb2Rpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGxvY2FsU3RhdGUgJiYgbG9jYWxTdGF0ZS5wYXJlbnQgJiYgaW5zdGFuY2UucmF5Y2FzdCAmJiBwcmV2SGFuZGxlcnMgIT09IGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgIC8vIEdldCB0aGUgaW5pdGlhbCByb290IHN0YXRlJ3MgaW50ZXJuYWxzXG4gICAgY29uc3QgaW50ZXJuYWwgPSBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWw7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IGludGVybmFsLmludGVyYWN0aW9uLmluZGV4T2YoaW5zdGFuY2UpO1xuICAgIGlmIChpbmRleCA+IC0xKSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChsb2NhbFN0YXRlLmV2ZW50Q291bnQpIGludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgdXBkYXRlIGxpZmVjeWNsZSB3aGVuIGl0IGlzIGJlaW5nIHVwZGF0ZWQsIGJ1dCBvbmx5IHdoZW4gaXQgaXMgcGFydCBvZiB0aGUgc2NlbmUuXG4gIC8vIFNraXAgdXBkYXRlcyB0byB0aGUgYG9uVXBkYXRlYCBwcm9wIGl0c2VsZlxuICBjb25zdCBpc0NpcmN1bGFyID0gY2hhbmdlcy5sZW5ndGggPT09IDEgJiYgY2hhbmdlc1swXVswXSA9PT0gJ29uVXBkYXRlJztcbiAgaWYgKCFpc0NpcmN1bGFyICYmIGNoYW5nZXMubGVuZ3RoICYmIChfaW5zdGFuY2UkX19yM2YyID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmMi5wYXJlbnQpIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2YzLCBfaW5zdGFuY2UkX19yM2YzJHJvb3Q7XG4gIGNvbnN0IHN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5zdGFuY2UkX19yM2YzJHJvb3QgPSBfaW5zdGFuY2UkX19yM2YzLnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YzJHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjMkcm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID09PSAwKSBzdGF0ZS5pbnZhbGlkYXRlKCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uub25VcGRhdGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICBpZiAoIWNhbWVyYS5tYW51YWwpIHtcbiAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgY2FtZXJhLmxlZnQgPSBzaXplLndpZHRoIC8gLTI7XG4gICAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgICBjYW1lcmEuYm90dG9tID0gc2l6ZS5oZWlnaHQgLyAtMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xNzhcbiAgICAvLyBVcGRhdGUgbWF0cml4IHdvcmxkIHNpbmNlIHRoZSByZW5kZXJlciBpcyBhIGZyYW1lIGxhdGVcbiAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlciNnZXRjdXJyZW50ZXZlbnRwcmlvcml0eVxuLy8gR2l2ZXMgUmVhY3QgYSBjbHVlIGFzIHRvIGhvdyBpbXBvcnQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gaXNcbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoKSB7XG4gIHZhciBfZ2xvYmFsU2NvcGUkZXZlbnQ7XG4gIC8vIEdldCBhIGhhbmRsZSB0byB0aGUgY3VycmVudCBnbG9iYWwgc2NvcGUgaW4gd2luZG93IGFuZCB3b3JrZXIgY29udGV4dHMgaWYgYWJsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjQ5M1xuICBjb25zdCBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbiAgaWYgKCFnbG9iYWxTY29wZSkgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICBjb25zdCBuYW1lID0gKF9nbG9iYWxTY29wZSRldmVudCA9IGdsb2JhbFNjb3BlLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbFNjb3BlJGV2ZW50LnR5cGU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnZGJsY2xpY2snOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgY2FzZSAncG9pbnRlcm91dCc6XG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgY2FzZSAncG9pbnRlcmxlYXZlJzpcbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxufVxuXG4vKipcclxuICogUmVsZWFzZSBwb2ludGVyIGNhcHR1cmVzLlxyXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXHJcbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KSB8fCByb290U3RhdGU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKS5zZXQoaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGhpdE9iamVjdCwgYW5kIHRoZSBoaXQuIGhpdE9iamVjdCBpcyB1c2VkIGZvclxuICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZXMsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50ID0ge1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJiBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoaSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFsuLi5oaWdoZXIsIGhpdF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICBjYWxsYmFjayhyYXljYXN0RXZlbnQpO1xuICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQb2ludGVyKGludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGZvciAoY29uc3QgaG92ZXJlZE9iaiBvZiBpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKSB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGggfHwgIWludGVyc2VjdGlvbnMuZmluZChoaXQgPT4gaGl0Lm9iamVjdCA9PT0gaG92ZXJlZE9iai5vYmplY3QgJiYgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvLyBDaGVjayBwcmVzZW5jZSBvZiBoYW5kbGVyc1xuICAgICAgICBpZiAoIShpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpKSByZXR1cm47XG5cbiAgICAgICAgLypcclxuICAgICAgICBNQVlCRSBUT0RPLCBERUxFVEUgSUYgTk9UOiBcclxuICAgICAgICAgIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgY2FwdHVyZWQsIGNhcHR1cmVkIGV2ZW50cyBzaG91bGQgbm90IGhhdmUgaW50ZXJzZWN0cyBydW5uaW5nIGluIHBhcmFsbGVsXHJcbiAgICAgICAgICBCdXQgd291bGRuJ3QgaXQgYmUgYmV0dGVyIHRvIGp1c3QgcmVwbGFjZSBjYXB0dXJlZE1hcCB3aXRoIGEgc2luZ2xlIGVudHJ5P1xyXG4gICAgICAgICAgQWxzbywgYXJlIHdlIE9LIHdpdGggc3RyYWlnaHQgdXAgbWFraW5nIHBpY2tpbmcgdXAgbXVsdGlwbGUgb2JqZWN0cyBpbXBvc3NpYmxlP1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gKGRhdGEgYXMgVGhyZWVFdmVudDxQb2ludGVyRXZlbnQ+KS5wb2ludGVySWQgICAgICAgIFxyXG4gICAgICAgIGlmIChwb2ludGVySWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc3QgY2FwdHVyZWRNZXNoU2V0ID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KHBvaW50ZXJJZClcclxuICAgICAgICAgIGlmIChjYXB0dXJlZE1lc2hTZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlZE1lc2hTZXQuZ2V0KGV2ZW50T2JqZWN0KVxyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZWQgJiYgY2FwdHVyZWQubG9jYWxTdGF0ZS5zdG9wcGVkKSByZXR1cm5cclxuICAgICAgICAgIH1cclxuICAgICAgICB9Ki9cblxuICAgICAgICBpZiAoaXNQb2ludGVyTW92ZSkge1xuICAgICAgICAgIC8vIE1vdmUgZXZlbnQgLi4uXG4gICAgICAgICAgaWYgKGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgfHwgaGFuZGxlcnMub25Qb2ludGVyRW50ZXIgfHwgaGFuZGxlcnMub25Qb2ludGVyT3V0IHx8IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGVudGVyIG9yIG91dCBpcyBwcmVzZW50IHRha2UgY2FyZSBvZiBob3Zlci1zdGF0ZVxuICAgICAgICAgICAgY29uc3QgaWQgPSBtYWtlSWQoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkSXRlbSA9IGludGVybmFsLmhvdmVyZWQuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmICghaG92ZXJlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXNuJ3QgcHJldmlvdXNseSBob3ZlcmVkLCBib29rIGl0IGFuZCBjYWxsIGl0cyBoYW5kbGVyXG4gICAgICAgICAgICAgIGludGVybmFsLmhvdmVyZWQuc2V0KGlkLCBkYXRhKTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3ZlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyT3ZlcihkYXRhKTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyRW50ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyKGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2FzIHByZXZpb3VzbHkgaG92ZXJlZCBhbmQgc3RvcHBlZCwgd2Ugc2hvdWxkbid0IGFsbG93IG90aGVyIGl0ZW1zIHRvIHByb2NlZWRcbiAgICAgICAgICAgICAgZGF0YS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2FsbCBtb3VzZSBtb3ZlXG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTW92ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTW92ZShkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbGwgb3RoZXIgZXZlbnRzIC4uLlxuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgLy8gRm9yd2FyZCBhbGwgZXZlbnRzIGJhY2sgdG8gdGhlaXIgcmVzcGVjdGl2ZSBoYW5kbGVycyB3aXRoIHRoZSBleGNlcHRpb24gb2YgY2xpY2sgZXZlbnRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggbXVzdCB1c2UgdGhlIGluaXRpYWwgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoIWlzQ2xpY2tFdmVudCB8fCBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3RcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgICAvLyBOb3cgY2FsbCB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIG9uUG9pbnRlck1pc3NlZCBvbiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIHBvaW50ZXIgb3Zlci9vdXQgaGFuZGxlcnMsIGJ1dCBub3QgY2xpY2sgYW5kIHdlcmVuJ3QgaGl0XG4gICAgICAgICAgICBpZiAoaXNDbGlja0V2ZW50ICYmIGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYW5kbGVJbnRlcnNlY3RzKGhpdHMsIGV2ZW50LCBkZWx0YSwgb25JbnRlcnNlY3QpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH07XG59XG5cbi8vIEtleXMgdGhhdCBzaG91bGRuJ3QgYmUgY29waWVkIGJldHdlZW4gUjNGIHN0b3Jlc1xuY29uc3QgcHJpdmF0ZUtleXMgPSBbJ3NldCcsICdnZXQnLCAnc2V0U2l6ZScsICdzZXRGcmFtZWxvb3AnLCAnc2V0RHByJywgJ2V2ZW50cycsICdpbnZhbGlkYXRlJywgJ2FkdmFuY2UnLCAnc2l6ZScsICd2aWV3cG9ydCddO1xuY29uc3QgaXNSZW5kZXJlciA9IGRlZiA9PiAhIShkZWYgIT0gbnVsbCAmJiBkZWYucmVuZGVyKTtcbmNvbnN0IGNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKGludmFsaWRhdGUsIGFkdmFuY2UpID0+IHtcbiAgY29uc3Qgcm9vdFN0YXRlID0gY3JlYXRlKChzZXQsIGdldCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCBkZWZhdWx0VGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0ZW1wVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhID0gZ2V0KCkuY2FtZXJhLCB0YXJnZXQgPSBkZWZhdWx0VGFyZ2V0LCBzaXplID0gZ2V0KCkuc2l6ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnRcbiAgICAgIH0gPSBzaXplO1xuICAgICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICBpZiAodGFyZ2V0LmlzVmVjdG9yMykgdGVtcFRhcmdldC5jb3B5KHRhcmdldCk7ZWxzZSB0ZW1wVGFyZ2V0LnNldCguLi50YXJnZXQpO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmEuZ2V0V29ybGRQb3NpdGlvbihwb3NpdGlvbikuZGlzdGFuY2VUbyh0ZW1wVGFyZ2V0KTtcbiAgICAgIGlmIChpc09ydGhvZ3JhcGhpY0NhbWVyYShjYW1lcmEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoIC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IDEsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmb3YgPSBjYW1lcmEuZm92ICogTWF0aC5QSSAvIDE4MDsgLy8gY29udmVydCB2ZXJ0aWNhbCBmb3YgdG8gcmFkaWFuc1xuICAgICAgICBjb25zdCBoID0gMiAqIE1hdGgudGFuKGZvdiAvIDIpICogZGlzdGFuY2U7IC8vIHZpc2libGUgaGVpZ2h0XG4gICAgICAgIGNvbnN0IHcgPSBoICogKHdpZHRoIC8gaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiB3aWR0aCAvIHcsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwZXJmb3JtYW5jZVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2V0UGVyZm9ybWFuY2VDdXJyZW50ID0gY3VycmVudCA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICBjdXJyZW50XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBvaW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHtcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIE1vY2sgb2JqZWN0cyB0aGF0IGhhdmUgdG8gYmUgY29uZmlndXJlZFxuICAgICAgZ2w6IG51bGwsXG4gICAgICBjYW1lcmE6IG51bGwsXG4gICAgICByYXljYXN0ZXI6IG51bGwsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgcHJpb3JpdHk6IDEsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvbm5lY3RlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB4cjogbnVsbCxcbiAgICAgIHNjZW5lOiBudWxsLFxuICAgICAgaW52YWxpZGF0ZTogKGZyYW1lcyA9IDEpID0+IGludmFsaWRhdGUoZ2V0KCksIGZyYW1lcyksXG4gICAgICBhZHZhbmNlOiAodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzKSA9PiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cywgZ2V0KCkpLFxuICAgICAgbGVnYWN5OiBmYWxzZSxcbiAgICAgIGxpbmVhcjogZmFsc2UsXG4gICAgICBmbGF0OiBmYWxzZSxcbiAgICAgIGNvbnRyb2xzOiBudWxsLFxuICAgICAgY2xvY2s6IG5ldyBUSFJFRS5DbG9jaygpLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgZnJhbWVsb29wOiAnYWx3YXlzJyxcbiAgICAgIG9uUG9pbnRlck1pc3NlZDogdW5kZWZpbmVkLFxuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgY3VycmVudDogMSxcbiAgICAgICAgbWluOiAwLjUsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgZGVib3VuY2U6IDIwMCxcbiAgICAgICAgcmVncmVzczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGltZW91dFxuICAgICAgICAgIGlmIChwZXJmb3JtYW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChwZXJmb3JtYW5jZVRpbWVvdXQpO1xuICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBwZXJmb3JtYW5jZVxuICAgICAgICAgIGlmIChzdGF0ZS5wZXJmb3JtYW5jZS5jdXJyZW50ICE9PSBzdGF0ZS5wZXJmb3JtYW5jZS5taW4pIHNldFBlcmZvcm1hbmNlQ3VycmVudChzdGF0ZS5wZXJmb3JtYW5jZS5taW4pO1xuICAgICAgICAgIC8vIEdvIGJhY2sgdG8gdXBwZXIgYm91bmQgcGVyZm9ybWFuY2UgYWZ0ZXIgYSB3aGlsZSB1bmxlc3Mgc29tZXRoaW5nIHJlZ3Jlc3NlcyBtZWFud2hpbGVcbiAgICAgICAgICBwZXJmb3JtYW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFBlcmZvcm1hbmNlQ3VycmVudChnZXQoKS5wZXJmb3JtYW5jZS5tYXgpLCBzdGF0ZS5wZXJmb3JtYW5jZS5kZWJvdW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgaW5pdGlhbERwcjogMCxcbiAgICAgICAgZHByOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGFzcGVjdDogMCxcbiAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgIGZhY3RvcjogMCxcbiAgICAgICAgZ2V0Q3VycmVudFZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKSxcbiAgICAgIHNldFNpemU6ICh3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSwgdG9wLCBsZWZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGdldCgpLmNhbWVyYTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wOiB0b3AgfHwgMCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IHx8IDAsXG4gICAgICAgICAgdXBkYXRlU3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAuLi5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBkZWZhdWx0VGFyZ2V0LCBzaXplKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldERwcjogZHByID0+IHNldChzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2FsY3VsYXRlRHByKGRwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgZHByOiByZXNvbHZlZCxcbiAgICAgICAgICAgIGluaXRpYWxEcHI6IHN0YXRlLnZpZXdwb3J0LmluaXRpYWxEcHIgfHwgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHNldEZyYW1lbG9vcDogKGZyYW1lbG9vcCA9ICdhbHdheXMnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gZ2V0KCkuY2xvY2s7XG5cbiAgICAgICAgLy8gaWYgZnJhbWVsb29wID09PSBcIm5ldmVyXCIgY2xvY2suZWxhcHNlZFRpbWUgaXMgdXBkYXRlZCB1c2luZyBhZHZhbmNlKHRpbWVzdGFtcClcbiAgICAgICAgY2xvY2suc3RvcCgpO1xuICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIGlmIChmcmFtZWxvb3AgIT09ICduZXZlcicpIHtcbiAgICAgICAgICBjbG9jay5zdGFydCgpO1xuICAgICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgICBmcmFtZWxvb3BcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHByZXZpb3VzUm9vdDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIGZyYW1lczogMCxcbiAgICAgICAgbGFzdEV2ZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCksXG4gICAgICAgIGludGVyYWN0aW9uOiBbXSxcbiAgICAgICAgaG92ZXJlZDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgIGluaXRpYWxDbGljazogWzAsIDBdLFxuICAgICAgICBpbml0aWFsSGl0czogW10sXG4gICAgICAgIGNhcHR1cmVkTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZTogKHJlZiwgcHJpb3JpdHksIHN0b3JlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAvLyBJZiB0aGlzIHN1YnNjcmlwdGlvbiB3YXMgZ2l2ZW4gYSBwcmlvcml0eSwgaXQgdGFrZXMgcmVuZGVyaW5nIGludG8gaXRzIG93biBoYW5kc1xuICAgICAgICAgIC8vIEZvciB0aGF0IHJlYXNvbiB3ZSBzd2l0Y2ggb2ZmIGF1dG9tYXRpYyByZW5kZXJpbmcgYW5kIGluY3JlYXNlIHRoZSBtYW51YWwgZmxhZ1xuICAgICAgICAgIC8vIEFzIGxvbmcgYXMgdGhpcyBmbGFnIGlzIHBvc2l0aXZlIHRoZXJlIGNhbiBiZSBubyBpbnRlcm5hbCByZW5kZXJpbmcgYXQgYWxsXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSByZW5kZXIgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgKyAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzLnB1c2goe1xuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBzdG9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIHN1YnNjcmliZXIgYW5kIHNvcnQgbGF5ZXJzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QsIG1lYW5pbmcsXG4gICAgICAgICAgLy8gaGlnaGVzdCBwcmlvcml0eSByZW5kZXJzIGxhc3QgKG9uIHRvcCBvZiB0aGUgb3RoZXIgZnJhbWVzKVxuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgICAgaWYgKGludGVybmFsICE9IG51bGwgJiYgaW50ZXJuYWwuc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgbWFudWFsIGZsYWcgaWYgdGhpcyBzdWJzY3JpcHRpb24gaGFkIGEgcHJpb3JpdHlcbiAgICAgICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSAtIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLmZpbHRlcihzID0+IHMucmVmICE9PSByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByb290U3RhdGU7XG4gIH0pO1xuICBjb25zdCBzdGF0ZSA9IHJvb3RTdGF0ZS5nZXRTdGF0ZSgpO1xuICBsZXQgb2xkU2l6ZSA9IHN0YXRlLnNpemU7XG4gIGxldCBvbGREcHIgPSBzdGF0ZS52aWV3cG9ydC5kcHI7XG4gIGxldCBvbGRDYW1lcmEgPSBzdGF0ZS5jYW1lcmE7XG4gIHJvb3RTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbWVyYSxcbiAgICAgIHNpemUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGdsLFxuICAgICAgc2V0XG4gICAgfSA9IHJvb3RTdGF0ZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gUmVzaXplIGNhbWVyYSBhbmQgcmVuZGVyZXIgb24gY2hhbmdlcyB0byBzaXplIGFuZCBwaXhlbHJhdGlvXG4gICAgaWYgKHNpemUud2lkdGggIT09IG9sZFNpemUud2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IG9sZFNpemUuaGVpZ2h0IHx8IHZpZXdwb3J0LmRwciAhPT0gb2xkRHByKSB7XG4gICAgICB2YXIgX3NpemUkdXBkYXRlU3R5bGU7XG4gICAgICBvbGRTaXplID0gc2l6ZTtcbiAgICAgIG9sZERwciA9IHZpZXdwb3J0LmRwcjtcbiAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgJiByZW5kZXJlclxuICAgICAgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgICBnbC5zZXRQaXhlbFJhdGlvKHZpZXdwb3J0LmRwcik7XG4gICAgICBjb25zdCB1cGRhdGVTdHlsZSA9IChfc2l6ZSR1cGRhdGVTdHlsZSA9IHNpemUudXBkYXRlU3R5bGUpICE9IG51bGwgPyBfc2l6ZSR1cGRhdGVTdHlsZSA6IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wuZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgZ2wuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdXBkYXRlU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3cG9ydCBvbmNlIHRoZSBjYW1lcmEgY2hhbmdlc1xuICAgIGlmIChjYW1lcmEgIT09IG9sZENhbWVyYSkge1xuICAgICAgb2xkQ2FtZXJhID0gY2FtZXJhO1xuICAgICAgLy8gVXBkYXRlIHZpZXdwb3J0XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhKVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbnZhbGlkYXRlIG9uIGFueSBjaGFuZ2VcbiAgcm9vdFN0YXRlLnN1YnNjcmliZShzdGF0ZSA9PiBpbnZhbGlkYXRlKHN0YXRlKSk7XG5cbiAgLy8gUmV0dXJuIHJvb3Qgc3RhdGVcbiAgcmV0dXJuIHJvb3RTdGF0ZTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIHN1YnMpIHtcbiAgY29uc3Qgc3ViID0ge1xuICAgIGNhbGxiYWNrXG4gIH07XG4gIHN1YnMuYWRkKHN1Yik7XG4gIHJldHVybiAoKSA9PiB2b2lkIHN1YnMuZGVsZXRlKHN1Yik7XG59XG5sZXQgaTtcbmxldCBnbG9iYWxFZmZlY3RzID0gbmV3IFNldCgpO1xubGV0IGdsb2JhbEFmdGVyRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxUYWlsRWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkRWZmZWN0XHJcbiAqL1xuY29uc3QgYWRkRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsRWZmZWN0cyk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIGFmdGVyLXJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEFmdGVyRWZmZWN0XHJcbiAqL1xuY29uc3QgYWRkQWZ0ZXJFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxBZnRlckVmZmVjdHMpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRUYWlsXHJcbiAqL1xuY29uc3QgYWRkVGFpbCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbFRhaWxFZmZlY3RzKTtcbmZ1bmN0aW9uIHJ1bihlZmZlY3RzLCB0aW1lc3RhbXApIHtcbiAgaWYgKCFlZmZlY3RzLnNpemUpIHJldHVybjtcbiAgZm9yIChjb25zdCB7XG4gICAgY2FsbGJhY2tcbiAgfSBvZiBlZmZlY3RzLnZhbHVlcygpKSB7XG4gICAgY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hHbG9iYWxFZmZlY3RzKHR5cGUsIHRpbWVzdGFtcCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsQWZ0ZXJFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ3RhaWwnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxUYWlsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgfVxufVxubGV0IHN1YnNjcmliZXJzO1xubGV0IHN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKSB7XG4gIC8vIFJ1biBsb2NhbCBlZmZlY3RzXG4gIGxldCBkZWx0YSA9IHN0YXRlLmNsb2NrLmdldERlbHRhKCk7XG4gIC8vIEluIGZyYW1lbG9vcD0nbmV2ZXInIG1vZGUsIGNsb2NrIHRpbWVzIGFyZSB1cGRhdGVkIHVzaW5nIHRoZSBwcm92aWRlZCB0aW1lc3RhbXBcbiAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJyAmJiB0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgIGRlbHRhID0gdGltZXN0YW1wIC0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2sub2xkVGltZSA9IHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lID0gdGltZXN0YW1wO1xuICB9XG4gIC8vIENhbGwgc3Vic2NyaWJlcnMgKHVzZUZyYW1lKVxuICBzdWJzY3JpYmVycyA9IHN0YXRlLmludGVybmFsLnN1YnNjcmliZXJzO1xuICBmb3IgKGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBzdWJzY3JpcHRpb24ucmVmLmN1cnJlbnQoc3Vic2NyaXB0aW9uLnN0b3JlLmdldFN0YXRlKCksIGRlbHRhLCBmcmFtZSk7XG4gIH1cbiAgLy8gUmVuZGVyIGNvbnRlbnRcbiAgaWYgKCFzdGF0ZS5pbnRlcm5hbC5wcmlvcml0eSAmJiBzdGF0ZS5nbC5yZW5kZXIpIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgc3RhdGUuY2FtZXJhKTtcbiAgLy8gRGVjcmVhc2UgZnJhbWUgY291bnRcbiAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5tYXgoMCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzIC0gMSk7XG4gIHJldHVybiBzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnID8gMSA6IHN0YXRlLmludGVybmFsLmZyYW1lcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvb3Aocm9vdHMpIHtcbiAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgbGV0IHVzZUZyYW1lSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICBsZXQgcmVwZWF0O1xuICBsZXQgZnJhbWU7XG4gIGxldCBzdGF0ZTtcbiAgZnVuY3Rpb24gbG9vcCh0aW1lc3RhbXApIHtcbiAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICByZXBlYXQgPSAwO1xuXG4gICAgLy8gUnVuIGVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBSZW5kZXIgYWxsIHJvb3RzXG4gICAgdXNlRnJhbWVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHtcbiAgICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgICBzdGF0ZSA9IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHRoZSBmcmFtZWxvb3AgaXMgaW52YWxpZGF0ZWQsIGRvIG5vdCBydW4gYW5vdGhlciBmcmFtZVxuICAgICAgaWYgKHN0YXRlLmludGVybmFsLmFjdGl2ZSAmJiAoc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyB8fCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPiAwKSAmJiAhKChfc3RhdGUkZ2wkeHIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIuaXNQcmVzZW50aW5nKSkge1xuICAgICAgICByZXBlYXQgKz0gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVzZUZyYW1lSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gUnVuIGFmdGVyLWVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgbm90aGluZyBpbnZhbGlkYXRlcyBpdFxuICAgIGlmIChyZXBlYXQgPT09IDApIHtcbiAgICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICAgIGZsdXNoR2xvYmFsRWZmZWN0cygndGFpbCcsIHRpbWVzdGFtcCk7XG5cbiAgICAgIC8vIEZsYWcgZW5kIG9mIG9wZXJhdGlvblxuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShzdGF0ZSwgZnJhbWVzID0gMSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHIyO1xuICAgIGlmICghc3RhdGUpIHJldHVybiByb290cy5mb3JFYWNoKHJvb3QgPT4gaW52YWxpZGF0ZShyb290LnN0b3JlLmdldFN0YXRlKCksIGZyYW1lcykpO1xuICAgIGlmICgoX3N0YXRlJGdsJHhyMiA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4cjIuaXNQcmVzZW50aW5nIHx8ICFzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgfHwgc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgaWYgKGZyYW1lcyA+IDEpIHtcbiAgICAgIC8vIGxlZ2FjeSBzdXBwb3J0IGZvciBwZW9wbGUgdXNpbmcgZnJhbWVzIHBhcmFtZXRlcnNcbiAgICAgIC8vIEluY3JlYXNlIGZyYW1lcywgZG8gbm90IGdvIGhpZ2hlciB0aGFuIDYwXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHVzZUZyYW1lSW5Qcm9ncmVzcykge1xuICAgICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiBhIHVzZUZyYW1lLCBpdCBtZWFucyB0aGUgdXNlciB3YW50cyBhbiBhZGRpdGlvbmFsIGZyYW1lXG4gICAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL3RoZSB1c2VyIG5lZWQgYSBuZXcgZnJhbWUsIG5vIG5lZWQgdG8gaW5jcmVtZW50IGZ1cnRoZXIgdGhhbiAxXG4gICAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlbmRlci1sb29wIGlzbid0IGFjdGl2ZSwgc3RhcnQgaXRcbiAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cyA9IHRydWUsIHN0YXRlLCBmcmFtZSkge1xuICAgIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG4gICAgaWYgKCFzdGF0ZSkgZm9yIChjb25zdCByb290IG9mIHJvb3RzLnZhbHVlcygpKSByZW5kZXIkMSh0aW1lc3RhbXAsIHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSk7ZWxzZSByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSk7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiB7XG4gICAgbG9vcCxcbiAgICBpbnZhbGlkYXRlLFxuICAgIGFkdmFuY2VcbiAgfTtcbn1cblxuLyoqXHJcbiAqIEV4cG9zZXMgYW4gb2JqZWN0J3Mge0BsaW5rIExvY2FsU3RhdGV9LlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjdXNlSW5zdGFuY2VIYW5kbGVcclxuICpcclxuICogKipOb3RlKio6IHRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIHRvIHJlYWN0LWludGVybmFsIGZpZWxkcy4gRXhwZWN0IHRoaXMgdG8gY2hhbmdlIHNpZ25pZmljYW50bHkgYmV0d2VlbiB2ZXJzaW9ucy5cclxuICovXG5mdW5jdGlvbiB1c2VJbnN0YW5jZUhhbmRsZShyZWYpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAoaW5zdGFuY2UuY3VycmVudCA9IHJlZi5jdXJyZW50Ll9fcjNmKSwgW3JlZl0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXHJcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXHJcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxyXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cclxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcclxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxyXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBidWlsZEdyYXBoKG9iamVjdCksIFtvYmplY3RdKTtcbn1cbmNvbnN0IG1lbW9pemVkTG9hZGVycyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICByZXR1cm4gZnVuY3Rpb24gKFByb3RvLCAuLi5pbnB1dCkge1xuICAgIC8vIENvbnN0cnVjdCBuZXcgbG9hZGVyIGFuZCBydW4gZXh0ZW5zaW9uc1xuICAgIGxldCBsb2FkZXIgPSBtZW1vaXplZExvYWRlcnMuZ2V0KFByb3RvKTtcbiAgICBpZiAoIWxvYWRlcikge1xuICAgICAgbG9hZGVyID0gbmV3IFByb3RvKCk7XG4gICAgICBtZW1vaXplZExvYWRlcnMuc2V0KFByb3RvLCBsb2FkZXIpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9ucykgZXh0ZW5zaW9ucyhsb2FkZXIpO1xuICAgIC8vIEdvIHRocm91Z2ggdGhlIHVybHMgYW5kIGxvYWQgdGhlbVxuICAgIHJldHVybiBQcm9taXNlLmFsbChpbnB1dC5tYXAoaW5wdXQgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqZWN0KSA9PiBsb2FkZXIubG9hZChpbnB1dCwgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS5zY2VuZSkgT2JqZWN0LmFzc2lnbihkYXRhLCBidWlsZEdyYXBoKGRhdGEuc2NlbmUpKTtcbiAgICAgIHJlcyhkYXRhKTtcbiAgICB9LCBvblByb2dyZXNzLCBlcnJvciA9PiByZWplY3QobmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCAke2lucHV0fTogJHtlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZX1gKSkpKSkpO1xuICB9O1xufVxuLyoqXHJcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgYW5kIGNhY2hlcyBhc3NldHMgd2l0aCBhIHRocmVlIGxvYWRlci5cclxuICpcclxuICogTm90ZTogdGhpcyBob29rJ3MgY2FsbGVyIG11c3QgYmUgd3JhcHBlZCB3aXRoIGBSZWFjdC5TdXNwZW5zZWBcclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlbG9hZGVyXHJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICAvLyBVc2Ugc3VzcGVuc2UgdG8gbG9hZCBhc3luYyBhc3NldHNcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICBjb25zdCByZXN1bHRzID0gc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtQcm90bywgLi4ua2V5c10sIHtcbiAgICBlcXVhbDogaXMuZXF1XG4gIH0pO1xuICAvLyBSZXR1cm4gdGhlIG9iamVjdC9zXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcclxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxyXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBwcmVsb2FkKGxvYWRpbmdGbihleHRlbnNpb25zKSwgW1Byb3RvLCAuLi5rZXlzXSk7XG59O1xuXG4vKipcclxuICogUmVtb3ZlcyBhIGxvYWRlZCBhc3NldCBmcm9tIGNhY2hlLlxyXG4gKi9cbnVzZUxvYWRlci5jbGVhciA9IGZ1bmN0aW9uIChQcm90bywgaW5wdXQpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gY2xlYXIoW1Byb3RvLCAuLi5rZXlzXSk7XG59O1xuXG5jb25zdCByb290cyA9IG5ldyBNYXAoKTtcbmNvbnN0IHtcbiAgaW52YWxpZGF0ZSxcbiAgYWR2YW5jZVxufSA9IGNyZWF0ZUxvb3Aocm9vdHMpO1xuY29uc3Qge1xuICByZWNvbmNpbGVyLFxuICBhcHBseVByb3BzXG59ID0gY3JlYXRlUmVuZGVyZXIocm9vdHMsIGdldEV2ZW50UHJpb3JpdHkpO1xuY29uc3Qgc2hhbGxvd0xvb3NlID0ge1xuICBvYmplY3RzOiAnc2hhbGxvdycsXG4gIHN0cmljdDogZmFsc2Vcbn07XG5jb25zdCBjcmVhdGVSZW5kZXJlckluc3RhbmNlID0gKGdsLCBjYW52YXMpID0+IHtcbiAgY29uc3QgY3VzdG9tUmVuZGVyZXIgPSB0eXBlb2YgZ2wgPT09ICdmdW5jdGlvbicgPyBnbChjYW52YXMpIDogZ2w7XG4gIGlmIChpc1JlbmRlcmVyKGN1c3RvbVJlbmRlcmVyKSkgcmV0dXJuIGN1c3RvbVJlbmRlcmVyO2Vsc2UgcmV0dXJuIG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICBwb3dlclByZWZlcmVuY2U6ICdoaWdoLXBlcmZvcm1hbmNlJyxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgYWxwaGE6IHRydWUsXG4gICAgLi4uZ2xcbiAgfSk7XG59O1xuZnVuY3Rpb24gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgZGVmYXVsdFNpemUpIHtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgaWYgKGRlZmF1bHRTaXplKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGUgPSBkZWZhdWx0U3R5bGVcbiAgICB9ID0gZGVmYXVsdFNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0XG4gICAgfSA9IGNhbnZhcy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB1cGRhdGVTdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vdChjYW52YXMpIHtcbiAgLy8gQ2hlY2sgYWdhaW5zdCBtaXN0YWtlbiB1c2Ugb2YgY3JlYXRlUm9vdFxuICBjb25zdCBwcmV2Um9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBwcmV2RmliZXIgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3QuZmliZXI7XG4gIGNvbnN0IHByZXZTdG9yZSA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5zdG9yZTtcbiAgaWYgKHByZXZSb290KSBjb25zb2xlLndhcm4oJ1IzRi5jcmVhdGVSb290IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIScpO1xuXG4gIC8vIFJlcG9ydCB3aGVuIGFuIGVycm9yIHdhcyBkZXRlY3RlZCBpbiBhIHByZXZpb3VzIHJlbmRlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjI2MVxuICBjb25zdCBsb2dSZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuICAvLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbiAgcmVwb3J0RXJyb3IgOlxuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gQ3JlYXRlIHN0b3JlXG4gIGNvbnN0IHN0b3JlID0gcHJldlN0b3JlIHx8IGNyZWF0ZVN0b3JlKGludmFsaWRhdGUsIGFkdmFuY2UpO1xuICAvLyBDcmVhdGUgcmVuZGVyZXJcbiAgY29uc3QgZmliZXIgPSBwcmV2RmliZXIgfHwgcmVjb25jaWxlci5jcmVhdGVDb250YWluZXIoc3RvcmUsIENvbmN1cnJlbnRSb290LCBudWxsLCBmYWxzZSwgbnVsbCwgJycsIGxvZ1JlY292ZXJhYmxlRXJyb3IsIG51bGwpO1xuICAvLyBNYXAgaXRcbiAgaWYgKCFwcmV2Um9vdCkgcm9vdHMuc2V0KGNhbnZhcywge1xuICAgIGZpYmVyLFxuICAgIHN0b3JlXG4gIH0pO1xuXG4gIC8vIExvY2Fsc1xuICBsZXQgb25DcmVhdGVkO1xuICBsZXQgY29uZmlndXJlZCA9IGZhbHNlO1xuICBsZXQgbGFzdENhbWVyYTtcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmUocHJvcHMgPSB7fSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgZ2w6IGdsQ29uZmlnLFxuICAgICAgICBzaXplOiBwcm9wc1NpemUsXG4gICAgICAgIHNjZW5lOiBzY2VuZU9wdGlvbnMsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWRDYWxsYmFjayxcbiAgICAgICAgc2hhZG93cyA9IGZhbHNlLFxuICAgICAgICBsaW5lYXIgPSBmYWxzZSxcbiAgICAgICAgZmxhdCA9IGZhbHNlLFxuICAgICAgICBsZWdhY3kgPSBmYWxzZSxcbiAgICAgICAgb3J0aG9ncmFwaGljID0gZmFsc2UsXG4gICAgICAgIGZyYW1lbG9vcCA9ICdhbHdheXMnLFxuICAgICAgICBkcHIgPSBbMSwgMl0sXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RPcHRpb25zLFxuICAgICAgICBjYW1lcmE6IGNhbWVyYU9wdGlvbnMsXG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSA9IHByb3BzO1xuICAgICAgbGV0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gU2V0IHVwIHJlbmRlcmVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCBnbCA9IHN0YXRlLmdsO1xuICAgICAgaWYgKCFzdGF0ZS5nbCkgc3RhdGUuc2V0KHtcbiAgICAgICAgZ2w6IGdsID0gY3JlYXRlUmVuZGVyZXJJbnN0YW5jZShnbENvbmZpZywgY2FudmFzKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCB1cCByYXljYXN0ZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IHJheWNhc3RlciA9IHN0YXRlLnJheWNhc3RlcjtcbiAgICAgIGlmICghcmF5Y2FzdGVyKSBzdGF0ZS5zZXQoe1xuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCByYXljYXN0ZXIgb3B0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gPSByYXljYXN0T3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghaXMuZXF1KG9wdGlvbnMsIHJheWNhc3Rlciwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWlzLmVxdShwYXJhbXMsIHJheWNhc3Rlci5wYXJhbXMsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIC4uLnJheWNhc3Rlci5wYXJhbXMsXG4gICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjYW1lcmEsIGRvbid0IG92ZXJ3cml0ZSBhbnkgdXNlci1zZXQgc3RhdGVcbiAgICAgIGlmICghc3RhdGUuY2FtZXJhIHx8IHN0YXRlLmNhbWVyYSA9PT0gbGFzdENhbWVyYSAmJiAhaXMuZXF1KGxhc3RDYW1lcmEsIGNhbWVyYU9wdGlvbnMsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgbGFzdENhbWVyYSA9IGNhbWVyYU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzQ2FtZXJhID0gY2FtZXJhT3B0aW9ucyBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgwLCAwLCAwLCAwLCAwLjEsIDEwMDApIDogbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCAwLCAwLjEsIDEwMDApO1xuICAgICAgICBpZiAoIWlzQ2FtZXJhKSB7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSA1O1xuICAgICAgICAgIGlmIChjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICBhcHBseVByb3BzKGNhbWVyYSwgY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB1c2VyLWRlZmluZWQgZnJ1c3R1bSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzE2MFxuICAgICAgICAgICAgaWYgKCdhc3BlY3QnIGluIGNhbWVyYU9wdGlvbnMgfHwgJ2xlZnQnIGluIGNhbWVyYU9wdGlvbnMgfHwgJ3JpZ2h0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdib3R0b20nIGluIGNhbWVyYU9wdGlvbnMgfHwgJ3RvcCcgaW4gY2FtZXJhT3B0aW9ucykge1xuICAgICAgICAgICAgICBjYW1lcmEubWFudWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWx3YXlzIGxvb2sgYXQgY2VudGVyIGJ5IGRlZmF1bHRcbiAgICAgICAgICBpZiAoIXN0YXRlLmNhbWVyYSAmJiAhKGNhbWVyYU9wdGlvbnMgIT0gbnVsbCAmJiBjYW1lcmFPcHRpb25zLnJvdGF0aW9uKSkgY2FtZXJhLmxvb2tBdCgwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIGNhbWVyYVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb25maWd1cmUgcmF5Y2FzdGVyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QteHIvaXNzdWVzLzMwMFxuICAgICAgICByYXljYXN0ZXIuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgc2NlbmUgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS5zY2VuZSkge1xuICAgICAgICBsZXQgc2NlbmU7XG4gICAgICAgIGlmIChzY2VuZU9wdGlvbnMgIT0gbnVsbCAmJiBzY2VuZU9wdGlvbnMuaXNTY2VuZSkge1xuICAgICAgICAgIHNjZW5lID0gc2NlbmVPcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgICAgaWYgKHNjZW5lT3B0aW9ucykgYXBwbHlQcm9wcyhzY2VuZSwgc2NlbmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHNjZW5lOiBwcmVwYXJlKHNjZW5lKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIFhSIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUueHIpIHtcbiAgICAgICAgdmFyIF9nbCR4cjtcbiAgICAgICAgLy8gSGFuZGxlIGZyYW1lIGJlaGF2aW9yIGluIFdlYlhSXG4gICAgICAgIGNvbnN0IGhhbmRsZVhSRnJhbWUgPSAodGltZXN0YW1wLCBmcmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgICAgICAgYWR2YW5jZSh0aW1lc3RhbXAsIHRydWUsIHN0YXRlLCBmcmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVG9nZ2xlIHJlbmRlciBzd2l0Y2hpbmcgb24gc2Vzc2lvblxuICAgICAgICBjb25zdCBoYW5kbGVTZXNzaW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBzdGF0ZS5nbC54ci5lbmFibGVkID0gc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLnNldEFuaW1hdGlvbkxvb3Aoc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nID8gaGFuZGxlWFJGcmFtZSA6IG51bGwpO1xuICAgICAgICAgIGlmICghc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nKSBpbnZhbGlkYXRlKHN0YXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXZWJYUiBzZXNzaW9uIG1hbmFnZXJcbiAgICAgICAgY29uc3QgeHIgPSB7XG4gICAgICAgICAgY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RvcmUuZ2V0U3RhdGUoKS5nbDtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RvcmUuZ2V0U3RhdGUoKS5nbDtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gV2ViWFIgc2Vzc2lvbiBldmVudHNcbiAgICAgICAgaWYgKHR5cGVvZiAoKF9nbCR4ciA9IGdsLnhyKSA9PSBudWxsID8gdm9pZCAwIDogX2dsJHhyLmFkZEV2ZW50TGlzdGVuZXIpID09PSAnZnVuY3Rpb24nKSB4ci5jb25uZWN0KCk7XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgeHJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBzaGFkb3dtYXBcbiAgICAgIGlmIChnbC5zaGFkb3dNYXApIHtcbiAgICAgICAgY29uc3Qgb2xkRW5hYmxlZCA9IGdsLnNoYWRvd01hcC5lbmFibGVkO1xuICAgICAgICBjb25zdCBvbGRUeXBlID0gZ2wuc2hhZG93TWFwLnR5cGU7XG4gICAgICAgIGdsLnNoYWRvd01hcC5lbmFibGVkID0gISFzaGFkb3dzO1xuICAgICAgICBpZiAoaXMuYm9vKHNoYWRvd3MpKSB7XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwO1xuICAgICAgICB9IGVsc2UgaWYgKGlzLnN0cihzaGFkb3dzKSkge1xuICAgICAgICAgIHZhciBfdHlwZXMkc2hhZG93cztcbiAgICAgICAgICBjb25zdCB0eXBlcyA9IHtcbiAgICAgICAgICAgIGJhc2ljOiBUSFJFRS5CYXNpY1NoYWRvd01hcCxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2U6IFRIUkVFLlBDRlNoYWRvd01hcCxcbiAgICAgICAgICAgIHNvZnQ6IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAsXG4gICAgICAgICAgICB2YXJpYW5jZTogVEhSRUUuVlNNU2hhZG93TWFwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IChfdHlwZXMkc2hhZG93cyA9IHR5cGVzW3NoYWRvd3NdKSAhPSBudWxsID8gX3R5cGVzJHNoYWRvd3MgOiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwO1xuICAgICAgICB9IGVsc2UgaWYgKGlzLm9iaihzaGFkb3dzKSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZ2wuc2hhZG93TWFwLCBzaGFkb3dzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkRW5hYmxlZCAhPT0gZ2wuc2hhZG93TWFwLmVuYWJsZWQgfHwgb2xkVHlwZSAhPT0gZ2wuc2hhZG93TWFwLnR5cGUpIGdsLnNoYWRvd01hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhZmVseSBzZXQgY29sb3IgbWFuYWdlbWVudCBpZiBhdmFpbGFibGUuXG4gICAgICAvLyBBdm9pZCBhY2Nlc3NpbmcgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IHRvIHBsYXkgbmljZSB3aXRoIG9sZGVyIHZlcnNpb25zXG4gICAgICBjb25zdCBDb2xvck1hbmFnZW1lbnQgPSBnZXRDb2xvck1hbmFnZW1lbnQoKTtcbiAgICAgIGlmIChDb2xvck1hbmFnZW1lbnQpIHtcbiAgICAgICAgaWYgKCdlbmFibGVkJyBpbiBDb2xvck1hbmFnZW1lbnQpIENvbG9yTWFuYWdlbWVudC5lbmFibGVkID0gIWxlZ2FjeTtlbHNlIGlmICgnbGVnYWN5TW9kZScgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQubGVnYWN5TW9kZSA9IGxlZ2FjeTtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlndXJlZCkge1xuICAgICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzLCBvbmNlXG4gICAgICAgIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICAgICAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgICAgICAgYXBwbHlQcm9wcyhnbCwge1xuICAgICAgICAgIG91dHB1dEVuY29kaW5nOiBsaW5lYXIgPyBMaW5lYXJFbmNvZGluZyA6IHNSR0JFbmNvZGluZyxcbiAgICAgICAgICB0b25lTWFwcGluZzogZmxhdCA/IFRIUkVFLk5vVG9uZU1hcHBpbmcgOiBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xvciBtYW5hZ2VtZW50IHN0YXRlXG4gICAgICBpZiAoc3RhdGUubGVnYWN5ICE9PSBsZWdhY3kpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsZWdhY3lcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5saW5lYXIgIT09IGxpbmVhcikgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxpbmVhclxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmZsYXQgIT09IGZsYXQpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBmbGF0XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBnbCBwcm9wc1xuICAgICAgaWYgKGdsQ29uZmlnICYmICFpcy5mdW4oZ2xDb25maWcpICYmICFpc1JlbmRlcmVyKGdsQ29uZmlnKSAmJiAhaXMuZXF1KGdsQ29uZmlnLCBnbCwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhnbCwgZ2xDb25maWcpO1xuICAgICAgLy8gU3RvcmUgZXZlbnRzIGludGVybmFsbHlcbiAgICAgIGlmIChldmVudHMgJiYgIXN0YXRlLmV2ZW50cy5oYW5kbGVycykgc3RhdGUuc2V0KHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMoc3RvcmUpXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHNpemUsIGFsbG93IGl0IHRvIHRha2Ugb24gY29udGFpbmVyIGJvdW5kcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IHNpemUgPSBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBwcm9wc1NpemUpO1xuICAgICAgaWYgKCFpcy5lcXUoc2l6ZSwgc3RhdGUuc2l6ZSwgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBzdGF0ZS5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBzaXplLnVwZGF0ZVN0eWxlLCBzaXplLnRvcCwgc2l6ZS5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHBpeGVscmF0aW9cbiAgICAgIGlmIChkcHIgJiYgc3RhdGUudmlld3BvcnQuZHByICE9PSBjYWxjdWxhdGVEcHIoZHByKSkgc3RhdGUuc2V0RHByKGRwcik7XG4gICAgICAvLyBDaGVjayBmcmFtZWxvb3BcbiAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgIT09IGZyYW1lbG9vcCkgc3RhdGUuc2V0RnJhbWVsb29wKGZyYW1lbG9vcCk7XG4gICAgICAvLyBDaGVjayBwb2ludGVyIG1pc3NlZFxuICAgICAgaWYgKCFzdGF0ZS5vblBvaW50ZXJNaXNzZWQpIHN0YXRlLnNldCh7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZVxuICAgICAgaWYgKHBlcmZvcm1hbmNlICYmICFpcy5lcXUocGVyZm9ybWFuY2UsIHN0YXRlLnBlcmZvcm1hbmNlLCBzaGFsbG93TG9vc2UpKSBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAuLi5wZXJmb3JtYW5jZVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBsb2NhbHNcbiAgICAgIG9uQ3JlYXRlZCA9IG9uQ3JlYXRlZENhbGxiYWNrO1xuICAgICAgY29uZmlndXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbmRlcihjaGlsZHJlbikge1xuICAgICAgLy8gVGhlIHJvb3QgaGFzIHRvIGJlIGNvbmZpZ3VyZWQgYmVmb3JlIGl0IGNhbiBiZSByZW5kZXJlZFxuICAgICAgaWYgKCFjb25maWd1cmVkKSB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIoIC8qI19fUFVSRV9fKi9qc3goUHJvdmlkZXIsIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkLFxuICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbiwgY2FudmFzLCBjb25maWcpIHtcbiAgY29uc29sZS53YXJuKCdSM0YucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290IGluc3RlYWQhJyk7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gIHJvb3QuY29uZmlndXJlKGNvbmZpZyk7XG4gIHJldHVybiByb290LnJlbmRlcihjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmaXkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0b3JlLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzLCBjYWxsYmFjaykge1xuICBjb25zdCByb290ID0gcm9vdHMuZ2V0KGNhbnZhcyk7XG4gIGNvbnN0IGZpYmVyID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5maWJlcjtcbiAgaWYgKGZpYmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlKSBzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgPSBmYWxzZTtcbiAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCBmaWJlciwgbnVsbCwgKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3N0YXRlJGdsLCBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMsIF9zdGF0ZSRnbDIsIF9zdGF0ZSRnbDM7XG4gICAgICAgICAgICBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IChfc3RhdGUkZ2wkcmVuZGVyTGlzdHMgPSBfc3RhdGUkZ2wucmVuZGVyTGlzdHMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wyID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICAgICAgaWYgKChfc3RhdGUkZ2wzID0gc3RhdGUuZ2wpICE9IG51bGwgJiYgX3N0YXRlJGdsMy54cikgc3RhdGUueHIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGlzcG9zZShzdGF0ZSk7XG4gICAgICAgICAgICByb290cy5kZWxldGUoY2FudmFzKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soY2FudmFzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiAuLi4gKi9cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyLCBzdGF0ZSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChQb3J0YWwsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0sIGNvbnRhaW5lci51dWlkKTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcclxuICAgKiAgaWYgdGhpcyBpcyBvdXIgZW52aXJvbm1lbnQsIHRoZW4gd2UgYXJlIG5vdCBpbiByM2YncyByZW5kZXJlciBidXQgaW4gcmVhY3QtZG9tLCBpdCB3b3VsZCB0cmlnZ2VyXHJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxyXG4gICAqICA8Q2FudmFzPlxyXG4gICAqICAgIHtjcmVhdGVQb3J0YWwoLi4uKX0gKi9cbiAgY29uc3Qge1xuICAgIGV2ZW50cyxcbiAgICBzaXplLFxuICAgIC4uLnJlc3RcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBwcmV2aW91c1Jvb3QgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBbcmF5Y2FzdGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5SYXljYXN0ZXIoKSk7XG4gIGNvbnN0IFtwb2ludGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5WZWN0b3IyKCkpO1xuICBjb25zdCBpbmplY3QgPSBSZWFjdC51c2VDYWxsYmFjaygocm9vdFN0YXRlLCBpbmplY3RTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHtcbiAgICAgIC4uLnJvb3RTdGF0ZVxuICAgIH07IC8vIGFsbCBwcmV2IHN0YXRlIHByb3BzXG5cbiAgICAvLyBPbmx5IHRoZSBmaWVsZHMgb2YgXCJyb290U3RhdGVcIiB0aGF0IGRvIG5vdCBkaWZmZXIgZnJvbSBpbmplY3RTdGF0ZVxuICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICBPYmplY3Qua2V5cyhyb290U3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAgIHByaXZhdGVLZXlzLmluY2x1ZGVzKGtleSkgfHxcbiAgICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgICAgLy8gVW5sZXNzIHRoZSBpbmplY3QgbGF5ZXIgcHJvcHMgaXMgdW5kZWZpbmVkLCB0aGVuIHdlIGtlZXAgdGhlIHJvb3QgbGF5ZXJcbiAgICAgIHJvb3RTdGF0ZVtrZXldICE9PSBpbmplY3RTdGF0ZVtrZXldICYmIGluamVjdFN0YXRlW2tleV0pIHtcbiAgICAgICAgZGVsZXRlIGludGVyc2VjdFtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB2aWV3cG9ydCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5qZWN0U3RhdGUgJiYgc2l6ZSkge1xuICAgICAgY29uc3QgY2FtZXJhID0gaW5qZWN0U3RhdGUuY2FtZXJhO1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVycmlkZSB2aWV3cG9ydCwgaWYgcHJlc2VudFxuICAgICAgdmlld3BvcnQgPSByb290U3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgc2l6ZSk7XG4gICAgICAvLyBVcGRhdGUgdGhlIHBvcnRhbCBjYW1lcmEsIGlmIGl0IGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgbGF5ZXJcbiAgICAgIGlmIChjYW1lcmEgIT09IHJvb3RTdGF0ZS5jYW1lcmEpIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLy8gVGhlIGludGVyc2VjdCBjb25zaXN0cyBvZiB0aGUgcHJldmlvdXMgcm9vdCBzdGF0ZVxuICAgICAgLi4uaW50ZXJzZWN0LFxuICAgICAgLy8gUG9ydGFscyBoYXZlIHRoZWlyIG93biBzY2VuZSwgd2hpY2ggZm9ybXMgdGhlIHJvb3QsIGEgcmF5Y2FzdGVyIGFuZCBhIHBvaW50ZXJcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICAvLyBUaGVpciBwcmV2aW91cyByb290IGlzIHRoZSBsYXllciBiZWZvcmUgaXRcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIC8vIEV2ZW50cywgc2l6ZSBhbmQgdmlld3BvcnQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGluamVjdCBsYXllclxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLihpbmplY3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5qZWN0U3RhdGUuZXZlbnRzKSxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5yb290U3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgLi4udmlld3BvcnRcbiAgICAgIH0sXG4gICAgICAuLi5yZXN0XG4gICAgfTtcbiAgfSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbc3RhdGVdKTtcbiAgY29uc3QgW3VzZVBvcnRhbFN0b3JlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBtaXJyb3JlZCBzdG9yZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIHJvb3Qgd2l0aCBhIGZldyBvdmVycmlkZXMgLi4uXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlKChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC4uLnByZXZpb3VzU3RhdGUsXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIC4uLnJlc3QsXG4gICAgICAvLyBTZXQgYW5kIGdldCByZWZlciB0byB0aGlzIHJvb3Qtc3RhdGVcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIExheWVycyBhcmUgYWxsb3dlZCB0byBvdmVycmlkZSBldmVudHNcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJldmlvdXMgcm9vdC1zdGF0ZSBhbmQgY29weSBjaGFuZ2VzIG92ZXIgdG8gdGhlIG1pcnJvcmVkIHBvcnRhbC1zdGF0ZVxuICAgIGNvbnN0IHVuc3ViID0gcHJldmlvdXNSb290LnN1YnNjcmliZShwcmV2ID0+IHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKHN0YXRlID0+IGluamVjdChwcmV2LCBzdGF0ZSkpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2luamVjdF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKGluamVjdFN0YXRlID0+IGluamVjdChwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSwgaW5qZWN0U3RhdGUpKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtpbmplY3RdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdXNlUG9ydGFsU3RvcmUuZGVzdHJveSgpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IHJlY29uY2lsZXIuY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB1c2VQb3J0YWxTdG9yZSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pLCB1c2VQb3J0YWxTdG9yZSwgbnVsbClcbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBGb3JjZSBSZWFjdCB0byBmbHVzaCBhbnkgdXBkYXRlcyBpbnNpZGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHN5bmNocm9ub3VzbHkgYW5kIGltbWVkaWF0ZWx5LlxyXG4gKiBBbGwgdGhlIHNhbWUgY2F2ZWF0cyBkb2N1bWVudGVkIGZvciByZWFjdC1kb20ncyBgZmx1c2hTeW5jYCBhcHBseSBoZXJlIChzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0LWRvbS9mbHVzaFN5bmMpLlxyXG4gKiBOZXZlcnRoZWxlc3MsIHNvbWV0aW1lcyBvbmUgbmVlZHMgdG8gcmVuZGVyIHN5bmNocm9ub3VzbHksIGZvciBleGFtcGxlIHRvIGtlZXAgRE9NIGFuZCAzRCBjaGFuZ2VzIGluIGxvY2stc3RlcCB3aXRob3V0XHJcbiAqIGhhdmluZyB0byByZXZlcnQgdG8gYSBub24tUmVhY3Qgc29sdXRpb24uXHJcbiAqL1xuZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gIC8vIGBmbHVzaFN5bmNgIGltcGxlbWVudGF0aW9uIG9ubHkgdGFrZXMgb25lIGFyZ3VtZW50LiBJIGRvbid0IGtub3cgd2hhdCdzIHVwIHdpdGggdGhlIHR5cGUgZGVjbGFyYXRpb24gZm9yIGl0LlxuICByZXR1cm4gcmVjb25jaWxlci5mbHVzaFN5bmMoZm4sIHVuZGVmaW5lZCk7XG59XG5yZWNvbmNpbGVyLmluamVjdEludG9EZXZUb29scyh7XG4gIGJ1bmRsZVR5cGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAwIDogMSxcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ0ByZWFjdC10aHJlZS9maWJlcicsXG4gIHZlcnNpb246IFJlYWN0LnZlcnNpb25cbn0pO1xuY29uc3QgYWN0ID0gUmVhY3QudW5zdGFibGVfYWN0O1xuXG5jb25zdCBET01fRVZFTlRTID0ge1xuICBvbkNsaWNrOiBbJ2NsaWNrJywgZmFsc2VdLFxuICBvbkNvbnRleHRNZW51OiBbJ2NvbnRleHRtZW51JywgZmFsc2VdLFxuICBvbkRvdWJsZUNsaWNrOiBbJ2RibGNsaWNrJywgZmFsc2VdLFxuICBvbldoZWVsOiBbJ3doZWVsJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckRvd246IFsncG9pbnRlcmRvd24nLCB0cnVlXSxcbiAgb25Qb2ludGVyVXA6IFsncG9pbnRlcnVwJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckxlYXZlOiBbJ3BvaW50ZXJsZWF2ZScsIHRydWVdLFxuICBvblBvaW50ZXJNb3ZlOiBbJ3BvaW50ZXJtb3ZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckNhbmNlbDogWydwb2ludGVyY2FuY2VsJywgdHJ1ZV0sXG4gIG9uTG9zdFBvaW50ZXJDYXB0dXJlOiBbJ2xvc3Rwb2ludGVyY2FwdHVyZScsIHRydWVdXG59O1xuXG4vKiogRGVmYXVsdCBSM0YgZXZlbnQgbWFuYWdlciBmb3Igd2ViICovXG5mdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnRzKHN0b3JlKSB7XG4gIGNvbnN0IHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH0gPSBjcmVhdGVFdmVudHMoc3RvcmUpO1xuICByZXR1cm4ge1xuICAgIHByaW9yaXR5OiAxLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgY29tcHV0ZShldmVudCwgc3RhdGUsIHByZXZpb3VzKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvNzgyXG4gICAgICAvLyBFdmVudHMgdHJpZ2dlciBvdXRzaWRlIG9mIGNhbnZhcyB3aGVuIG1vdmVkLCB1c2Ugb2Zmc2V0WC9ZIGJ5IGRlZmF1bHQgYW5kIGFsbG93IG92ZXJyaWRlc1xuICAgICAgc3RhdGUucG9pbnRlci5zZXQoZXZlbnQub2Zmc2V0WCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLShldmVudC5vZmZzZXRZIC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICB9LFxuICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkLFxuICAgIGhhbmRsZXJzOiBPYmplY3Qua2V5cyhET01fRVZFTlRTKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tleV06IGhhbmRsZVBvaW50ZXIoa2V5KVxuICAgIH0pLCB7fSksXG4gICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICB2YXIgX2ludGVybmFsJGxhc3RFdmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoKF9pbnRlcm5hbCRsYXN0RXZlbnQgPSBpbnRlcm5hbC5sYXN0RXZlbnQpICE9IG51bGwgJiYgX2ludGVybmFsJGxhc3RFdmVudC5jdXJyZW50ICYmIGV2ZW50cy5oYW5kbGVycykgZXZlbnRzLmhhbmRsZXJzLm9uUG9pbnRlck1vdmUoaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQpO1xuICAgIH0sXG4gICAgY29ubmVjdDogdGFyZ2V0ID0+IHtcbiAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMgPSBldmVudHMuaGFuZGxlcnMpICE9IG51bGwgPyBfZXZlbnRzJGhhbmRsZXJzIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50LCB7XG4gICAgICAgICAgcGFzc2l2ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICB2YXIgX2V2ZW50cyRoYW5kbGVyczI7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKChfZXZlbnRzJGhhbmRsZXJzMiA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMyIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50cy5jb25uZWN0ZWQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgW2V2ZW50TmFtZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgICAgZXZlbnRzLmNvbm5lY3RlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZUluc3RhbmNlSGFuZGxlIGFzIEEsIEJsb2NrIGFzIEIsIHVzZVN0b3JlIGFzIEMsIHVzZVRocmVlIGFzIEQsIEVycm9yQm91bmRhcnkgYXMgRSwgdXNlRnJhbWUgYXMgRiwgdXNlR3JhcGggYXMgRywgdXNlTG9hZGVyIGFzIEgsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgYXMgYSwgY3JlYXRlUm9vdCBhcyBiLCBjcmVhdGVQb2ludGVyRXZlbnRzIGFzIGMsIHVubW91bnRDb21wb25lbnRBdE5vZGUgYXMgZCwgZXh0ZW5kIGFzIGUsIGNyZWF0ZUV2ZW50cyBhcyBmLCBjb250ZXh0IGFzIGcsIGNyZWF0ZVBvcnRhbCBhcyBoLCBpc1JlZiBhcyBpLCByZWNvbmNpbGVyIGFzIGosIGFwcGx5UHJvcHMgYXMgaywgZGlzcG9zZSBhcyBsLCBpbnZhbGlkYXRlIGFzIG0sIGFkdmFuY2UgYXMgbiwgYWRkRWZmZWN0IGFzIG8sIGFkZEFmdGVyRWZmZWN0IGFzIHAsIGFkZFRhaWwgYXMgcSwgcmVuZGVyIGFzIHIsIGZsdXNoR2xvYmFsRWZmZWN0cyBhcyBzLCB0aHJlZVR5cGVzIGFzIHQsIHVzZU11dGFibGVDYWxsYmFjayBhcyB1LCBmbHVzaFN5bmMgYXMgdiwgZ2V0Um9vdFN0YXRlIGFzIHcsIGFjdCBhcyB4LCBidWlsZEdyYXBoIGFzIHksIHJvb3RzIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJUSFJFRSIsIlJlYWN0IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbmN1cnJlbnRSb290IiwiY3JlYXRlIiwic3VzcGVuZCIsInByZWxvYWQiLCJjbGVhciIsImpzeCIsIkZyYWdtZW50IiwiUmVjb25jaWxlciIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJ0aHJlZVR5cGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiY2F0YWxvZ3VlIiwiZXh0ZW5kIiwib2JqZWN0cyIsImFzc2lnbiIsImNyZWF0ZVJlbmRlcmVyIiwiX3Jvb3RzIiwiX2dldEV2ZW50UHJpb3JpdHkiLCJjcmVhdGVJbnN0YW5jZSIsInR5cGUiLCJhcmdzIiwiYXR0YWNoIiwicHJvcHMiLCJyb290IiwibmFtZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnN0YW5jZSIsIm9iamVjdCIsInVuZGVmaW5lZCIsIkVycm9yIiwicHJlcGFyZSIsInByaW1pdGl2ZSIsInRhcmdldCIsIkFycmF5IiwiaXNBcnJheSIsIm1lbW9pemVkUHJvcHMiLCJfX3IzZiIsImlzQnVmZmVyR2VvbWV0cnkiLCJpc01hdGVyaWFsIiwiYXBwbHlQcm9wcyQxIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImNoaWxkIiwiYWRkZWQiLCJfY2hpbGQkX19yM2YiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YiLCJpc09iamVjdDNEIiwiYWRkIiwicHVzaCIsInBhcmVudCIsInVwZGF0ZUluc3RhbmNlIiwiaW52YWxpZGF0ZUluc3RhbmNlIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlQ2hpbGQiLCJfY2hpbGQkX19yM2YyIiwiX3BhcmVudEluc3RhbmNlJF9fcjNmMiIsImRpc3BhdGNoRXZlbnQiLCJyZXN0U2libGluZ3MiLCJjaGlsZHJlbiIsImZpbHRlciIsInNpYmxpbmciLCJpbmRleCIsImluZGV4T2YiLCJyZW1vdmVSZWN1cnNpdmUiLCJhcnJheSIsImRpc3Bvc2UiLCJmb3JFYWNoIiwicmVtb3ZlQ2hpbGQiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YzIiwiX2NoaWxkJF9fcjNmMyIsIl9jaGlsZCRfX3IzZjUiLCJ4IiwiZGV0YWNoIiwiX2NoaWxkJF9fcjNmNCIsInJlbW92ZSIsInJlbW92ZUludGVyYWN0aXZpdHkiLCJmaW5kSW5pdGlhbFJvb3QiLCJpc1ByaW1pdGl2ZSIsInNob3VsZERpc3Bvc2UiLCJfY2hpbGQkX19yM2Y2IiwiY2FsbGJhY2siLCJlIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwic3dpdGNoSW5zdGFuY2UiLCJuZXdQcm9wcyIsImZpYmVyIiwiX2luc3RhbmNlJF9fcjNmIiwibmV3SW5zdGFuY2UiLCJhdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCIsInJheWNhc3QiLCJldmVudENvdW50Iiwicm9vdFN0YXRlIiwiZ2V0U3RhdGUiLCJpbnRlcm5hbCIsImludGVyYWN0aW9uIiwiYWx0ZXJuYXRlIiwic3RhdGVOb2RlIiwicmVmIiwiY3VycmVudCIsImhhbmRsZVRleHRJbnN0YW5jZSIsInJlY29uY2lsZXIiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJzdXBwb3J0c011dGF0aW9uIiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJzdXBwb3J0c1BlcnNpc3RlbmNlIiwic3VwcG9ydHNIeWRyYXRpb24iLCJub1RpbWVvdXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiY29udGFpbmVyIiwic2NlbmUiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsImdldFJvb3RIb3N0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwiX2luc3RhbmNlJF9fcjNmMiIsImxvY2FsU3RhdGUiLCJCb29sZWFuIiwiaGFuZGxlcnMiLCJwcmVwYXJlVXBkYXRlIiwiX3R5cGUiLCJvbGRQcm9wcyIsIl9pbnN0YW5jZSRfX3IzZjMiLCJhcmdzTmV3IiwiY04iLCJyZXN0TmV3IiwiYXJnc09sZCIsImNPIiwicmVzdE9sZCIsInNvbWUiLCJ2YWx1ZSIsImRpZmYiLCJkaWZmUHJvcHMiLCJjaGFuZ2VzIiwibGVuZ3RoIiwiY29tbWl0VXBkYXRlIiwicmVjb25zdHJ1Y3QiLCJfb2xkUHJvcHMiLCJjb21taXRNb3VudCIsIl9wcm9wcyIsIl9pbnQiLCJfaW5zdGFuY2UkX19yM2Y0IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJwcmVwYXJlRm9yQ29tbWl0IiwicHJlcGFyZVBvcnRhbE1vdW50IiwicmVzZXRBZnRlckNvbW1pdCIsInNob3VsZFNldFRleHRDb250ZW50IiwiY2xlYXJDb250YWluZXIiLCJoaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkX19yM2Y1IiwidmlzaWJsZSIsInVuaGlkZUluc3RhbmNlIiwiX2luc3RhbmNlJF9fcjNmNiIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJnZXRDdXJyZW50RXZlbnRQcmlvcml0eSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwibm93IiwicGVyZm9ybWFuY2UiLCJpcyIsImZ1biIsIkRhdGUiLCJzY2hlZHVsZVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsImNsZWFyVGltZW91dCIsImFwcGx5UHJvcHMiLCJfd2luZG93JGRvY3VtZW50IiwiX3dpbmRvdyRuYXZpZ2F0b3IiLCJoYXNDb2xvclNwYWNlIiwiZ2V0Q29sb3JNYW5hZ2VtZW50IiwiX0NvbG9yTWFuYWdlbWVudCIsIkNvbG9yTWFuYWdlbWVudCIsImlzT3J0aG9ncmFwaGljQ2FtZXJhIiwiZGVmIiwiaXNSZWYiLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlTXV0YWJsZUNhbGxiYWNrIiwiZm4iLCJ1c2VSZWYiLCJCbG9jayIsInNldCIsIlByb21pc2UiLCJFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJzdGF0ZSIsImVycm9yIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnIiLCJyZW5kZXIiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJERUZBVUxUIiwiREVGQVVMVFMiLCJNYXAiLCJpc0RpZmZTZXQiLCJtZW1vaXplZCIsImNhbGN1bGF0ZURwciIsImRwciIsIl93aW5kb3ckZGV2aWNlUGl4ZWxSYSIsImRldmljZVBpeGVsUmF0aW8iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Um9vdFN0YXRlIiwiX3IzZiIsInByZXZpb3VzUm9vdCIsImEiLCJhcnIiLCJzdHIiLCJudW0iLCJib28iLCJ1bmQiLCJlcXUiLCJiIiwiYXJyYXlzIiwic3RyaWN0IiwiaXNPYmoiLCJpc0FyciIsImkiLCJrZXlzIiwiYnVpbGRHcmFwaCIsImRhdGEiLCJub2RlcyIsIm1hdGVyaWFscyIsInRyYXZlcnNlIiwibWF0ZXJpYWwiLCJwIiwicHJldmlvdXNBdHRhY2giLCJyZXNvbHZlIiwia2V5IiwiaW5jbHVkZXMiLCJlbnRyaWVzIiwic3BsaXQiLCJsYXN0IiwicG9wIiwicmVkdWNlIiwiYWNjIiwiSU5ERVhfUkVHRVgiLCJ0ZXN0IiwicmVwbGFjZSIsInByZXZpb3VzIiwia04iLCJyTiIsImNQIiwia1AiLCJyUCIsInByZXZpb3VzS2V5cyIsInVuc2hpZnQiLCJwcm9wIiwic3RhcnRzV2l0aCIsIl9fREVWX18iLCJwcm9jZXNzIiwicHJldkhhbmRsZXJzIiwiaXNFdmVudCIsInNSR0JFbmNvZGluZyIsIlNSR0JDb2xvclNwYWNlIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJjdXJyZW50SW5zdGFuY2UiLCJ0YXJnZXRQcm9wIiwicmV2ZXJzZUVudHJpZXMiLCJyZXZlcnNlIiwiY3RvciIsImdldCIsImNvcHkiLCJMYXllcnMiLCJmcm9tQXJyYXkiLCJfdGFyZ2V0UHJvcCIsImlzQ29sb3IiLCJzZXRTY2FsYXIiLCJtYXNrIiwibGluZWFyIiwiY29udmVydFNSR0JUb0xpbmVhciIsIl9jdXJyZW50SW5zdGFuY2Uka2V5IiwiaXNUZXh0dXJlIiwiZm9ybWF0IiwiUkdCQUZvcm1hdCIsIlVuc2lnbmVkQnl0ZVR5cGUiLCJ0ZXh0dXJlIiwiZ2wiLCJjb2xvclNwYWNlIiwib3V0cHV0Q29sb3JTcGFjZSIsImVuY29kaW5nIiwib3V0cHV0RW5jb2RpbmciLCJzcGxpY2UiLCJpc0NpcmN1bGFyIiwiX2luc3RhbmNlJF9fcjNmMyRyb290IiwiZnJhbWVzIiwiaW52YWxpZGF0ZSIsIm9uVXBkYXRlIiwidXBkYXRlQ2FtZXJhIiwiY2FtZXJhIiwic2l6ZSIsIm1hbnVhbCIsImxlZnQiLCJ3aWR0aCIsInJpZ2h0IiwidG9wIiwiaGVpZ2h0IiwiYm90dG9tIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInVwZGF0ZU1hdHJpeFdvcmxkIiwibWFrZUlkIiwiZXZlbnQiLCJldmVudE9iamVjdCIsInV1aWQiLCJpbnN0YW5jZUlkIiwiZ2V0RXZlbnRQcmlvcml0eSIsIl9nbG9iYWxTY29wZSRldmVudCIsImdsb2JhbFNjb3BlIiwic2VsZiIsInJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlIiwiY2FwdHVyZWRNYXAiLCJjYXB0dXJlcyIsInBvaW50ZXJJZCIsImNhcHR1cmVEYXRhIiwiZGVsZXRlIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwic3RvcmUiLCJvIiwiaW5pdGlhbEhpdHMiLCJob3ZlcmVkIiwiY3JlYXRlRXZlbnRzIiwiY2FsY3VsYXRlRGlzdGFuY2UiLCJkeCIsIm9mZnNldFgiLCJpbml0aWFsQ2xpY2siLCJkeSIsIm9mZnNldFkiLCJyb3VuZCIsInNxcnQiLCJmaWx0ZXJQb2ludGVyRXZlbnRzIiwiaW50ZXJzZWN0IiwiZHVwbGljYXRlcyIsIlNldCIsImludGVyc2VjdGlvbnMiLCJldmVudHNPYmplY3RzIiwicmF5Y2FzdGVyIiwiZXZlbnRzIiwiY29tcHV0ZSIsImhhbmRsZVJheWNhc3QiLCJlbmFibGVkIiwiX3N0YXRlJHByZXZpb3VzUm9vdCIsImludGVyc2VjdE9iamVjdCIsImhpdHMiLCJmbGF0TWFwIiwic29ydCIsImFTdGF0ZSIsImJTdGF0ZSIsImRpc3RhbmNlIiwicHJpb3JpdHkiLCJpdGVtIiwiaWQiLCJoYXMiLCJoaXQiLCJfcjNmMiIsInZhbHVlcyIsImludGVyc2VjdGlvbiIsImhhbmRsZUludGVyc2VjdHMiLCJkZWx0YSIsInN0b3BwZWQiLCJwb2ludGVyIiwidW5wcm9qZWN0ZWRQb2ludCIsIlZlY3RvcjMiLCJ5IiwidW5wcm9qZWN0IiwiaGFzUG9pbnRlckNhcHR1cmUiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAyIiwic2V0UG9pbnRlckNhcHR1cmUiLCJleHRyYWN0RXZlbnRQcm9wcyIsInByb3BlcnR5IiwicmF5Y2FzdEV2ZW50IiwicmF5Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FwdHVyZXNGb3JQb2ludGVyIiwiZnJvbSIsImZpbmQiLCJoaWdoZXIiLCJjYW5jZWxQb2ludGVyIiwiY3VycmVudFRhcmdldCIsIm5hdGl2ZUV2ZW50IiwiaG92ZXJlZE9iaiIsIm9uUG9pbnRlck91dCIsIm9uUG9pbnRlckxlYXZlIiwicG9pbnRlck1pc3NlZCIsIm9uUG9pbnRlck1pc3NlZCIsImhhbmRsZVBvaW50ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVFdmVudCIsImxhc3RFdmVudCIsImlzUG9pbnRlck1vdmUiLCJpc0NsaWNrRXZlbnQiLCJtYXAiLCJvbkludGVyc2VjdCIsIm9uUG9pbnRlck92ZXIiLCJvblBvaW50ZXJFbnRlciIsImhvdmVyZWRJdGVtIiwib25Qb2ludGVyTW92ZSIsImhhbmRsZXIiLCJwcml2YXRlS2V5cyIsImlzUmVuZGVyZXIiLCJjb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZVN0b3JlIiwiYWR2YW5jZSIsInBvc2l0aW9uIiwiZGVmYXVsdFRhcmdldCIsInRlbXBUYXJnZXQiLCJnZXRDdXJyZW50Vmlld3BvcnQiLCJpc1ZlY3RvcjMiLCJnZXRXb3JsZFBvc2l0aW9uIiwiZGlzdGFuY2VUbyIsInpvb20iLCJmYWN0b3IiLCJmb3YiLCJQSSIsImgiLCJ0YW4iLCJ3IiwicGVyZm9ybWFuY2VUaW1lb3V0Iiwic2V0UGVyZm9ybWFuY2VDdXJyZW50IiwiVmVjdG9yMiIsImNvbm5lY3RlZCIsInhyIiwidGltZXN0YW1wIiwicnVuR2xvYmFsRWZmZWN0cyIsImxlZ2FjeSIsImZsYXQiLCJjb250cm9scyIsImNsb2NrIiwiQ2xvY2siLCJtb3VzZSIsImZyYW1lbG9vcCIsImRlYm91bmNlIiwicmVncmVzcyIsInVwZGF0ZVN0eWxlIiwidmlld3BvcnQiLCJpbml0aWFsRHByIiwic2V0RXZlbnRzIiwic2V0U2l6ZSIsInNldERwciIsInJlc29sdmVkIiwic2V0RnJhbWVsb29wIiwic3RvcCIsImVsYXBzZWRUaW1lIiwic3RhcnQiLCJhY3RpdmUiLCJjcmVhdGVSZWYiLCJzdWJzY3JpYmVycyIsInN1YnNjcmliZSIsInMiLCJvbGRTaXplIiwib2xkRHByIiwib2xkQ2FtZXJhIiwiX3NpemUkdXBkYXRlU3R5bGUiLCJzZXRQaXhlbFJhdGlvIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJkb21FbGVtZW50IiwiY3JlYXRlU3VicyIsInN1YnMiLCJzdWIiLCJnbG9iYWxFZmZlY3RzIiwiZ2xvYmFsQWZ0ZXJFZmZlY3RzIiwiZ2xvYmFsVGFpbEVmZmVjdHMiLCJhZGRFZmZlY3QiLCJhZGRBZnRlckVmZmVjdCIsImFkZFRhaWwiLCJydW4iLCJlZmZlY3RzIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwic3Vic2NyaXB0aW9uIiwicmVuZGVyJDEiLCJmcmFtZSIsImdldERlbHRhIiwib2xkVGltZSIsImNyZWF0ZUxvb3AiLCJyb290cyIsInJ1bm5pbmciLCJ1c2VGcmFtZUluUHJvZ3Jlc3MiLCJyZXBlYXQiLCJsb29wIiwiX3N0YXRlJGdsJHhyIiwiaXNQcmVzZW50aW5nIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJfc3RhdGUkZ2wkeHIyIiwidXNlSW5zdGFuY2VIYW5kbGUiLCJ1c2VTdG9yZSIsInVzZUNvbnRleHQiLCJ1c2VUaHJlZSIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsInVzZUZyYW1lIiwicmVuZGVyUHJpb3JpdHkiLCJ1c2VHcmFwaCIsInVzZU1lbW8iLCJtZW1vaXplZExvYWRlcnMiLCJXZWFrTWFwIiwibG9hZGluZ0ZuIiwiZXh0ZW5zaW9ucyIsIm9uUHJvZ3Jlc3MiLCJQcm90byIsImlucHV0IiwibG9hZGVyIiwiYWxsIiwicmVzIiwicmVqZWN0IiwibG9hZCIsIm1lc3NhZ2UiLCJ1c2VMb2FkZXIiLCJyZXN1bHRzIiwiZXF1YWwiLCJzaGFsbG93TG9vc2UiLCJjcmVhdGVSZW5kZXJlckluc3RhbmNlIiwiY2FudmFzIiwiY3VzdG9tUmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwicG93ZXJQcmVmZXJlbmNlIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJjb21wdXRlSW5pdGlhbFNpemUiLCJkZWZhdWx0U2l6ZSIsImRlZmF1bHRTdHlsZSIsInBhcmVudEVsZW1lbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJPZmZzY3JlZW5DYW52YXMiLCJjcmVhdGVSb290IiwicHJldlJvb3QiLCJwcmV2RmliZXIiLCJwcmV2U3RvcmUiLCJjb25zb2xlIiwid2FybiIsImxvZ1JlY292ZXJhYmxlRXJyb3IiLCJyZXBvcnRFcnJvciIsImNyZWF0ZUNvbnRhaW5lciIsIm9uQ3JlYXRlZCIsImNvbmZpZ3VyZWQiLCJsYXN0Q2FtZXJhIiwiY29uZmlndXJlIiwiZ2xDb25maWciLCJwcm9wc1NpemUiLCJzY2VuZU9wdGlvbnMiLCJvbkNyZWF0ZWRDYWxsYmFjayIsInNoYWRvd3MiLCJvcnRob2dyYXBoaWMiLCJyYXljYXN0T3B0aW9ucyIsImNhbWVyYU9wdGlvbnMiLCJSYXljYXN0ZXIiLCJwYXJhbXMiLCJvcHRpb25zIiwiaXNDYW1lcmEiLCJDYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsInoiLCJyb3RhdGlvbiIsImxvb2tBdCIsImlzU2NlbmUiLCJTY2VuZSIsIl9nbCR4ciIsImhhbmRsZVhSRnJhbWUiLCJoYW5kbGVTZXNzaW9uQ2hhbmdlIiwic2V0QW5pbWF0aW9uTG9vcCIsImNvbm5lY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzaGFkb3dNYXAiLCJvbGRFbmFibGVkIiwib2xkVHlwZSIsIlBDRlNvZnRTaGFkb3dNYXAiLCJfdHlwZXMkc2hhZG93cyIsInR5cGVzIiwiYmFzaWMiLCJCYXNpY1NoYWRvd01hcCIsInBlcmNlbnRhZ2UiLCJQQ0ZTaGFkb3dNYXAiLCJzb2Z0IiwidmFyaWFuY2UiLCJWU01TaGFkb3dNYXAiLCJuZWVkc1VwZGF0ZSIsImxlZ2FjeU1vZGUiLCJMaW5lYXJFbmNvZGluZyIsInRvbmVNYXBwaW5nIiwiTm9Ub25lTWFwcGluZyIsIkFDRVNGaWxtaWNUb25lTWFwcGluZyIsInVwZGF0ZUNvbnRhaW5lciIsIlByb3ZpZGVyIiwicm9vdEVsZW1lbnQiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImNvbmZpZyIsIl9zdGF0ZSRnbCIsIl9zdGF0ZSRnbCRyZW5kZXJMaXN0cyIsIl9zdGF0ZSRnbDIiLCJfc3RhdGUkZ2wzIiwicmVuZGVyTGlzdHMiLCJmb3JjZUNvbnRleHRMb3NzIiwiY3JlYXRlUG9ydGFsIiwiUG9ydGFsIiwicmVzdCIsInVzZVN0YXRlIiwiaW5qZWN0IiwidXNlQ2FsbGJhY2siLCJpbmplY3RTdGF0ZSIsInVzZVBvcnRhbFN0b3JlIiwicHJldmlvdXNTdGF0ZSIsInVuc3ViIiwicHJldiIsInNldFN0YXRlIiwiZGVzdHJveSIsImZsdXNoU3luYyIsImluamVjdEludG9EZXZUb29scyIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwidmVyc2lvbiIsImFjdCIsInVuc3RhYmxlX2FjdCIsIkRPTV9FVkVOVFMiLCJvbkNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uRG91YmxlQ2xpY2siLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlclVwIiwib25Qb2ludGVyQ2FuY2VsIiwib25Mb3N0UG9pbnRlckNhcHR1cmUiLCJjcmVhdGVQb2ludGVyRXZlbnRzIiwic2V0RnJvbUNhbWVyYSIsInVwZGF0ZSIsIl9pbnRlcm5hbCRsYXN0RXZlbnQiLCJfZXZlbnRzJGhhbmRsZXJzIiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsIl9ldmVudHMkaGFuZGxlcnMyIiwiSFRNTEVsZW1lbnQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsImMiLCJkIiwiZiIsImciLCJqIiwiayIsImwiLCJtIiwibiIsInEiLCJyIiwidCIsInUiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   act: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   advance: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   context: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createPointerEvents: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   events: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   extend: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   flushSync: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   render: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.D)\n/* harmony export */ });\n/* harmony import */ var _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-776716bd.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.c, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                    set: setError,\n                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                        fallback: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                            set: setBlock\n                        }),\n                        children: children\n                    })\n                })\n            }));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        },\n        ...props,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            ref: containerRef,\n            style: {\n                width: \"100%\",\n                height: \"100%\"\n            },\n            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    display: \"block\"\n                },\n                children: fallback\n            })\n        })\n    });\n});\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, {\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n            ...props,\n            ref: ref\n        })\n    });\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb087QUFDeVU7QUFDOWdCO0FBQ0E7QUFDWTtBQUNnQjtBQUNuQjtBQUNKO0FBQ25CO0FBQ007QUFDRztBQUNQO0FBRW5CLE1BQU0yRSxhQUFhLFdBQVcsR0FBRU4sNkNBQWdCLENBQUMsU0FBU1EsT0FBTyxFQUMvREMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxFQUFFLEVBQ0Z0QyxTQUFTM0Msc0RBQW1CLEVBQzVCa0YsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLE9BQU8sRUFDUEMsTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsWUFBWSxFQUNaQyxTQUFTLEVBQ1RDLEdBQUcsRUFDSEMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxlQUFlLEVBQ2ZDLFNBQVMsRUFDVCxHQUFHQyxPQUNKLEVBQUVDLFlBQVk7SUFDYixzREFBc0Q7SUFDdEQsNEVBQTRFO0lBQzVFLHlEQUF5RDtJQUN6RDlCLDBDQUFhLENBQUMsSUFBTWxFLDBEQUFNQSxDQUFDbUUsa0NBQUtBLEdBQUcsRUFBRTtJQUNyQyxNQUFNK0IsU0FBUzVCLDBEQUFnQkE7SUFDL0IsTUFBTSxDQUFDNkIsY0FBY0MsY0FBYyxHQUFHaEMsNkRBQVVBLENBQUM7UUFDL0NpQyxRQUFRO1FBQ1JDLFVBQVU7WUFDUkQsUUFBUTtZQUNSeEIsUUFBUTtRQUNWO1FBQ0EsR0FBR0EsTUFBTTtJQUNYO0lBQ0EsTUFBTTBCLFlBQVlyQyx5Q0FBWSxDQUFDO0lBQy9CLE1BQU11QyxTQUFTdkMseUNBQVksQ0FBQztJQUM1QkEsc0RBQXlCLENBQUM4QixjQUFjLElBQU1PLFVBQVVJLE9BQU87SUFDL0QsTUFBTUMs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dUQsVUFBVTtZQUNWakIsT0FBTztZQUNQQyxRQUFRO1lBQ1JpQixVQUFVO1lBQ1ZIO1lBQ0EsR0FBR3JELEtBQUs7UUFDVjtRQUNBLEdBQUdpQixLQUFLO1FBQ1JwQixVQUFVLFdBQVcsR0FBRUosc0RBQUdBLENBQUMsT0FBTztZQUNoQzZELEtBQUtqQztZQUNMckIsT0FBTztnQkFDTHNDLE9BQU87Z0JBQ1BDLFFBQVE7WUFDVjtZQUNBMUMsVUFBVSxXQUFXLEdBQUVKLHNEQUFHQSxDQUFDLFVBQVU7Z0JBQ25DNkQsS0FBSzdCO2dCQUNMekIsT0FBTztvQkFDTHlELFNBQVM7Z0JBQ1g7Z0JBQ0E1RCxVQUFVQztZQUNaO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUYsU0FBUyxXQUFXLEdBQUVSLDZDQUFnQixDQUFDLFNBQVNzRSxjQUFjekMsS0FBSyxFQUFFcUMsR0FBRztJQUM1RSxPQUFPLFdBQVcsR0FBRTdELHNEQUFHQSxDQUFDRixtREFBYUEsRUFBRTtRQUNyQ00sVUFBVSxXQUFXLEdBQUVKLHNEQUFHQSxDQUFDQyxZQUFZO1lBQ3JDLEdBQUd1QixLQUFLO1lBQ1JxQyxLQUFLQTtRQUNQO0lBQ0Y7QUFDRjtBQUVrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1aXNvdW5kLWFnZW50Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L3JlYWN0LXRocmVlLWZpYmVyLmVzbS5qcz83OWNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY3JlYXRlUG9pbnRlckV2ZW50cywgZSBhcyBleHRlbmQsIHUgYXMgdXNlTXV0YWJsZUNhbGxiYWNrLCBhIGFzIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIGIgYXMgY3JlYXRlUm9vdCwgaSBhcyBpc1JlZiwgRSBhcyBFcnJvckJvdW5kYXJ5LCBCIGFzIEJsb2NrLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUgfSBmcm9tICcuL2V2ZW50cy03NzY3MTZiZC5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyBSZWFjdFRocmVlRmliZXIsIHogYXMgX3Jvb3RzLCB4IGFzIGFjdCwgcCBhcyBhZGRBZnRlckVmZmVjdCwgbyBhcyBhZGRFZmZlY3QsIHEgYXMgYWRkVGFpbCwgbiBhcyBhZHZhbmNlLCBrIGFzIGFwcGx5UHJvcHMsIHkgYXMgYnVpbGRHcmFwaCwgZyBhcyBjb250ZXh0LCBmIGFzIGNyZWF0ZUV2ZW50cywgYyBhcyBjcmVhdGVQb2ludGVyRXZlbnRzLCBoIGFzIGNyZWF0ZVBvcnRhbCwgYiBhcyBjcmVhdGVSb290LCBsIGFzIGRpc3Bvc2UsIGMgYXMgZXZlbnRzLCBlIGFzIGV4dGVuZCwgcyBhcyBmbHVzaEdsb2JhbEVmZmVjdHMsIHYgYXMgZmx1c2hTeW5jLCB3IGFzIGdldFJvb3RTdGF0ZSwgbSBhcyBpbnZhbGlkYXRlLCBqIGFzIHJlY29uY2lsZXIsIHIgYXMgcmVuZGVyLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsIEYgYXMgdXNlRnJhbWUsIEcgYXMgdXNlR3JhcGgsIEEgYXMgdXNlSW5zdGFuY2VIYW5kbGUsIEggYXMgdXNlTG9hZGVyLCBDIGFzIHVzZVN0b3JlLCBEIGFzIHVzZVRocmVlIH0gZnJvbSAnLi9ldmVudHMtNzc2NzE2YmQuZXNtLmpzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB1c2VNZWFzdXJlIGZyb20gJ3JlYWN0LXVzZS1tZWFzdXJlJztcbmltcG9ydCB7IEZpYmVyUHJvdmlkZXIsIHVzZUNvbnRleHRCcmlkZ2UgfSBmcm9tICdpdHMtZmluZSc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAnenVzdGFuZCc7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCAnc2NoZWR1bGVyJztcblxuY29uc3QgQ2FudmFzSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmUoe1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgLi4ucmVzaXplXG4gIH0pO1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IGNhbnZhc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFuZGxlUG9pbnRlck1pc3NlZCA9IHVzZU11dGFibGVDYWxsYmFjayhvblBvaW50ZXJNaXNzZWQpO1xuICBjb25zdCBbYmxvY2ssIHNldEJsb2NrXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgICAgIHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICBnbCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBsaW5lYXIsXG4gICAgICAgIGZsYXQsXG4gICAgICAgIGxlZ2FjeSxcbiAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICBmcmFtZWxvb3AsXG4gICAgICAgIGRwcixcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBzY2VuZSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovanN4KEJyaWRnZSwge1xuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgc2V0OiBzZXRFcnJvcixcbiAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChSZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3goQmxvY2ssIHtcbiAgICAgICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykgcmV0dXJuICgpID0+IHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgfSwgW10pO1xuXG4gIC8vIFdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBub3QgdGhpcyBkaXYsIHdlIG5lZWQgdG8gc2V0IHBvaW50ZXItZXZlbnRzIHRvIG5vbmVcbiAgLy8gT3IgZWxzZSB0aGUgY2FudmFzIHdpbGwgYmxvY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGV2ZW50IHNvdXJjZVxuICBjb25zdCBwb2ludGVyRXZlbnRzID0gZXZlbnRTb3VyY2UgPyAnbm9uZScgOiAnYXV0byc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByZWY6IGRpdlJlZixcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBwb2ludGVyRXZlbnRzLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImNhbnZhc1wiLCB7XG4gICAgICAgIHJlZjogY2FudmFzUmVmLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGZhbGxiYWNrXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufSk7XG5cbi8qKlxyXG4gKiBBIERPTSBjYW52YXMgd2hpY2ggYWNjZXB0cyB0aHJlZWpzIGVsZW1lbnRzIGFzIGNoaWxkcmVuLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9jYW52YXNcclxuICovXG5jb25zdCBDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXNXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRmliZXJQcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KENhbnZhc0ltcGwsIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiByZWZcbiAgICB9KVxuICB9KTtcbn0pO1xuXG5leHBvcnQgeyBDYW52YXMgfTtcbiJdLCJuYW1lcyI6WyJjIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsImUiLCJleHRlbmQiLCJ1IiwidXNlTXV0YWJsZUNhbGxiYWNrIiwiYSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJiIiwiY3JlYXRlUm9vdCIsImkiLCJpc1JlZiIsIkUiLCJFcnJvckJvdW5kYXJ5IiwiQiIsIkJsb2NrIiwiZCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ0IiwiUmVhY3RUaHJlZUZpYmVyIiwieiIsIl9yb290cyIsIngiLCJhY3QiLCJwIiwiYWRkQWZ0ZXJFZmZlY3QiLCJvIiwiYWRkRWZmZWN0IiwicSIsImFkZFRhaWwiLCJuIiwiYWR2YW5jZSIsImsiLCJhcHBseVByb3BzIiwieSIsImJ1aWxkR3JhcGgiLCJnIiwiY29udGV4dCIsImYiLCJjcmVhdGVFdmVudHMiLCJoIiwiY3JlYXRlUG9ydGFsIiwibCIsImRpc3Bvc2UiLCJldmVudHMiLCJzIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwidiIsImZsdXNoU3luYyIsInciLCJnZXRSb290U3RhdGUiLCJtIiwiaW52YWxpZGF0ZSIsImoiLCJyZWNvbmNpbGVyIiwiciIsInJlbmRlciIsIkYiLCJ1c2VGcmFtZSIsIkciLCJ1c2VHcmFwaCIsIkEiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsIkgiLCJ1c2VMb2FkZXIiLCJDIiwidXNlU3RvcmUiLCJEIiwidXNlVGhyZWUiLCJSZWFjdCIsIlRIUkVFIiwidXNlTWVhc3VyZSIsIkZpYmVyUHJvdmlkZXIiLCJ1c2VDb250ZXh0QnJpZGdlIiwianN4IiwiQ2FudmFzSW1wbCIsImZvcndhcmRSZWYiLCJDYW52YXMiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwicmVzaXplIiwic3R5bGUiLCJnbCIsImV2ZW50U291cmNlIiwiZXZlbnRQcmVmaXgiLCJzaGFkb3dzIiwibGluZWFyIiwiZmxhdCIsImxlZ2FjeSIsIm9ydGhvZ3JhcGhpYyIsImZyYW1lbG9vcCIsImRwciIsInBlcmZvcm1hbmNlIiwicmF5Y2FzdGVyIiwiY2FtZXJhIiwic2NlbmUiLCJvblBvaW50ZXJNaXNzZWQiLCJvbkNyZWF0ZWQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsInVzZU1lbW8iLCJCcmlkZ2UiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJSZWN0Iiwic2Nyb2xsIiwiZGVib3VuY2UiLCJjYW52YXNSZWYiLCJ1c2VSZWYiLCJkaXZSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3VycmVudCIsImhhbmRsZVBvaW50ZXJNaXNzZWQiLCJibG9jayIsInNldEJsb2NrIiwidXNlU3RhdGUiLCJlcnJvciIsInNldEVycm9yIiwicm9vdCIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiY29uZmlndXJlIiwic2l6ZSIsImFyZ3MiLCJzdGF0ZSIsImNvbm5lY3QiLCJzZXRFdmVudHMiLCJjb21wdXRlIiwiZXZlbnQiLCJwb2ludGVyIiwic2V0Iiwic2V0RnJvbUNhbWVyYSIsIlN1c3BlbnNlIiwidXNlRWZmZWN0IiwicG9pbnRlckV2ZW50cyIsInJlZiIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJkaXNwbGF5IiwiQ2FudmFzV3JhcHBlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        function push(heap, node) {\n            var index = heap.length;\n            heap.push(node);\n            siftUp(heap, node, index);\n        }\n        function peek(heap) {\n            return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n            if (heap.length === 0) {\n                return null;\n            }\n            var first = heap[0];\n            var last = heap.pop();\n            if (last !== first) {\n                heap[0] = last;\n                siftDown(heap, last, 0);\n            }\n            return first;\n        }\n        function siftUp(heap, node, i) {\n            var index = i;\n            while(index > 0){\n                var parentIndex = index - 1 >>> 1;\n                var parent = heap[parentIndex];\n                if (compare(parent, node) > 0) {\n                    // The parent is larger. Swap positions.\n                    heap[parentIndex] = node;\n                    heap[index] = parent;\n                    index = parentIndex;\n                } else {\n                    // The parent is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function siftDown(heap, node, i) {\n            var index = i;\n            var length = heap.length;\n            var halfLength = length >>> 1;\n            while(index < halfLength){\n                var leftIndex = (index + 1) * 2 - 1;\n                var left = heap[leftIndex];\n                var rightIndex = leftIndex + 1;\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n                if (compare(left, node) < 0) {\n                    if (rightIndex < length && compare(right, left) < 0) {\n                        heap[index] = right;\n                        heap[rightIndex] = node;\n                        index = rightIndex;\n                    } else {\n                        heap[index] = left;\n                        heap[leftIndex] = node;\n                        index = leftIndex;\n                    }\n                } else if (rightIndex < length && compare(right, node) < 0) {\n                    heap[index] = right;\n                    heap[rightIndex] = node;\n                    index = rightIndex;\n                } else {\n                    // Neither child is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function compare(a, b) {\n            // Compare sort index first, then task id.\n            var diff = a.sortIndex - b.sortIndex;\n            return diff !== 0 ? diff : a.id - b.id;\n        }\n        // TODO: Use symbols?\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {}\n        /* eslint-disable no-var */ var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n            var localPerformance = performance;\n            exports.unstable_now = function() {\n                return localPerformance.now();\n            };\n        } else {\n            var localDate = Date;\n            var initialTime = localDate.now();\n            exports.unstable_now = function() {\n                return localDate.now() - initialTime;\n            };\n        } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n        // Math.pow(2, 30) - 1\n        // 0b111111111111111111111111111111\n        var maxSigned31BitInt = 1073741823; // Times out immediately\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5000;\n        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n        var taskQueue = [];\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null; // IE and Node.js + jsdom\n        var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n            // Check for tasks that are no longer delayed and add them to the queue.\n            var timer = peek(timerQueue);\n            while(timer !== null){\n                if (timer.callback === null) {\n                    // Timer was cancelled.\n                    pop(timerQueue);\n                } else if (timer.startTime <= currentTime) {\n                    // Timer fired. Transfer to the task queue.\n                    pop(timerQueue);\n                    timer.sortIndex = timer.expirationTime;\n                    push(taskQueue, timer);\n                } else {\n                    // Remaining timers are pending.\n                    return;\n                }\n                timer = peek(timerQueue);\n            }\n        }\n        function handleTimeout(currentTime) {\n            isHostTimeoutScheduled = false;\n            advanceTimers(currentTime);\n            if (!isHostCallbackScheduled) {\n                if (peek(taskQueue) !== null) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                } else {\n                    var firstTimer = peek(timerQueue);\n                    if (firstTimer !== null) {\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                    }\n                }\n            }\n        }\n        function flushWork(hasTimeRemaining, initialTime) {\n            isHostCallbackScheduled = false;\n            if (isHostTimeoutScheduled) {\n                // We scheduled a timeout but it's no longer needed. Cancel it.\n                isHostTimeoutScheduled = false;\n                cancelHostTimeout();\n            }\n            isPerformingWork = true;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n                if (enableProfiling) {\n                    try {\n                        return workLoop(hasTimeRemaining, initialTime);\n                    } catch (error) {\n                        if (currentTask !== null) {\n                            var currentTime = exports.unstable_now();\n                            markTaskErrored(currentTask, currentTime);\n                            currentTask.isQueued = false;\n                        }\n                        throw error;\n                    }\n                } else {\n                    // No catch in prod code path.\n                    return workLoop(hasTimeRemaining, initialTime);\n                }\n            } finally{\n                currentTask = null;\n                currentPriorityLevel = previousPriorityLevel;\n                isPerformingWork = false;\n            }\n        }\n        function workLoop(hasTimeRemaining, initialTime) {\n            var currentTime = initialTime;\n            advanceTimers(currentTime);\n            currentTask = peek(taskQueue);\n            while(currentTask !== null && !enableSchedulerDebugging){\n                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n                    break;\n                }\n                var callback = currentTask.callback;\n                if (typeof callback === \"function\") {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    var continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = exports.unstable_now();\n                    if (typeof continuationCallback === \"function\") {\n                        currentTask.callback = continuationCallback;\n                    } else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                } else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n            } // Return whether there's additional work\n            if (currentTask !== null) {\n                return true;\n            } else {\n                var firstTimer = peek(timerQueue);\n                if (firstTimer !== null) {\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                }\n                return false;\n            }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                case LowPriority:\n                case IdlePriority:\n                    break;\n                default:\n                    priorityLevel = NormalPriority;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_next(eventHandler) {\n            var priorityLevel;\n            switch(currentPriorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                    // Shift down to normal priority\n                    priorityLevel = NormalPriority;\n                    break;\n                default:\n                    // Anything lower than normal priority should remain at the current level.\n                    priorityLevel = currentPriorityLevel;\n                    break;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_wrapCallback(callback) {\n            var parentPriorityLevel = currentPriorityLevel;\n            return function() {\n                // This is a fork of runWithPriority, inlined for performance.\n                var previousPriorityLevel = currentPriorityLevel;\n                currentPriorityLevel = parentPriorityLevel;\n                try {\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentPriorityLevel = previousPriorityLevel;\n                }\n            };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n            var currentTime = exports.unstable_now();\n            var startTime;\n            if (typeof options === \"object\" && options !== null) {\n                var delay = options.delay;\n                if (typeof delay === \"number\" && delay > 0) {\n                    startTime = currentTime + delay;\n                } else {\n                    startTime = currentTime;\n                }\n            } else {\n                startTime = currentTime;\n            }\n            var timeout;\n            switch(priorityLevel){\n                case ImmediatePriority:\n                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n                    break;\n                case UserBlockingPriority:\n                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n                    break;\n                case IdlePriority:\n                    timeout = IDLE_PRIORITY_TIMEOUT;\n                    break;\n                case LowPriority:\n                    timeout = LOW_PRIORITY_TIMEOUT;\n                    break;\n                case NormalPriority:\n                default:\n                    timeout = NORMAL_PRIORITY_TIMEOUT;\n                    break;\n            }\n            var expirationTime = startTime + timeout;\n            var newTask = {\n                id: taskIdCounter++,\n                callback: callback,\n                priorityLevel: priorityLevel,\n                startTime: startTime,\n                expirationTime: expirationTime,\n                sortIndex: -1\n            };\n            if (startTime > currentTime) {\n                // This is a delayed task.\n                newTask.sortIndex = startTime;\n                push(timerQueue, newTask);\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n                    // All tasks are delayed, and this is the task with the earliest delay.\n                    if (isHostTimeoutScheduled) {\n                        // Cancel an existing timeout.\n                        cancelHostTimeout();\n                    } else {\n                        isHostTimeoutScheduled = true;\n                    } // Schedule a timeout.\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\n                }\n            } else {\n                newTask.sortIndex = expirationTime;\n                push(taskQueue, newTask);\n                // wait until the next time we yield.\n                if (!isHostCallbackScheduled && !isPerformingWork) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                }\n            }\n            return newTask;\n        }\n        function unstable_pauseExecution() {}\n        function unstable_continueExecution() {\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n                isHostCallbackScheduled = true;\n                requestHostCallback(flushWork);\n            }\n        }\n        function unstable_getFirstCallbackNode() {\n            return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n            // remove from the queue because you can't remove arbitrary nodes from an\n            // array based heap, only the first one.)\n            task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n            return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var scheduledHostCallback = null;\n        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n        // thread, like user events. By default, it yields multiple times per frame.\n        // It does not attempt to align with frame boundaries, since most tasks don't\n        // need to be frame aligned; for those that do, use requestAnimationFrame.\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n            var timeElapsed = exports.unstable_now() - startTime;\n            if (timeElapsed < frameInterval) {\n                // The main thread has only been blocked for a really short amount of time;\n                // smaller than a single frame. Don't yield yet.\n                return false;\n            } // The main thread has been blocked for a non-negligible amount of time. We\n            return true;\n        }\n        function requestPaint() {}\n        function forceFrameRate(fps) {\n            if (fps < 0 || fps > 125) {\n                // Using console['error'] to evade Babel and ESLint\n                console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing frame rates higher than 125 fps is not supported\");\n                return;\n            }\n            if (fps > 0) {\n                frameInterval = Math.floor(1000 / fps);\n            } else {\n                // reset the framerate\n                frameInterval = frameYieldMs;\n            }\n        }\n        var performWorkUntilDeadline = function() {\n            if (scheduledHostCallback !== null) {\n                var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n                // has been blocked.\n                startTime = currentTime;\n                var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n                // error can be observed.\n                //\n                // Intentionally not using a try-catch, since that makes some debugging\n                // techniques harder. Instead, if `scheduledHostCallback` errors, then\n                // `hasMoreWork` will remain true, and we'll continue the work loop.\n                var hasMoreWork = true;\n                try {\n                    hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n                } finally{\n                    if (hasMoreWork) {\n                        // If there's more work, schedule the next message event at the end\n                        // of the preceding one.\n                        schedulePerformWorkUntilDeadline();\n                    } else {\n                        isMessageLoopRunning = false;\n                        scheduledHostCallback = null;\n                    }\n                }\n            } else {\n                isMessageLoopRunning = false;\n            } // Yielding to the browser will give it a chance to paint, so we can\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n            // Node.js and old IE.\n            // There's a few reasons for why we prefer setImmediate.\n            //\n            // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n            // (Even though this is a DOM fork of the Scheduler, you could get here\n            // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n            // https://github.com/facebook/react/issues/20756\n            //\n            // But also, it runs earlier which is the semantic we want.\n            // If other browsers ever implement it, it's better to use it.\n            // Although both of these would be inferior to native scheduling.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetImmediate(performWorkUntilDeadline);\n            };\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // DOM and Worker environments.\n            // We prefer MessageChannel because of the 4ms setTimeout clamping.\n            var channel = new MessageChannel();\n            var port = channel.port2;\n            channel.port1.onmessage = performWorkUntilDeadline;\n            schedulePerformWorkUntilDeadline = function() {\n                port.postMessage(null);\n            };\n        } else {\n            // We should only fallback here in non-browser environments.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetTimeout(performWorkUntilDeadline, 0);\n            };\n        }\n        function requestHostCallback(callback) {\n            scheduledHostCallback = callback;\n            if (!isMessageLoopRunning) {\n                isMessageLoopRunning = true;\n                schedulePerformWorkUntilDeadline();\n            }\n        }\n        function requestHostTimeout(callback, ms) {\n            taskTimeoutID = localSetTimeout(function() {\n                callback(exports.unstable_now());\n            }, ms);\n        }\n        function cancelHostTimeout() {\n            localClearTimeout(taskTimeoutID);\n            taskTimeoutID = -1;\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUVPO1FBRVYseUNBQXlDLEdBQ3pDLElBQ0UsT0FBT0MsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQkMsMkJBQTJCLEtBQy9ELFlBQ0Y7WUFDQUQsK0JBQStCQywyQkFBMkIsQ0FBQyxJQUFJQztRQUNqRTtRQUNVLElBQUlDLDJCQUEyQjtRQUN6QyxJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSUMsZUFBZTtRQUVuQixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLElBQUk7WUFDdEIsSUFBSUMsUUFBUUYsS0FBS0csTUFBTTtZQUN2QkgsS0FBS0QsSUFBSSxDQUFDRTtZQUNWRyxPQUFPSixNQUFNQyxNQUFNQztRQUNyQjtRQUNBLFNBQVNHLEtBQUtMLElBQUk7WUFDaEIsT0FBT0EsS0FBS0csTUFBTSxLQUFLLElBQUksT0FBT0gsSUFBSSxDQUFDLEVBQUU7UUFDM0M7UUFDQSxTQUFTTSxJQUFJTixJQUFJO1lBQ2YsSUFBSUEsS0FBS0csTUFBTSxLQUFLLEdBQUc7Z0JBQ3JCLE9BQU87WUFDVDtZQUVBLElBQUlJLFFBQVFQLElBQUksQ0FBQyxFQUFFO1lBQ25CLElBQUlRLE9BQU9SLEtBQUtNLEdBQUc7WUFFbkIsSUFBSUUsU0FBU0QsT0FBTztnQkFDbEJQLElBQUksQ0FBQyxFQUFFLEdBQUdRO2dCQUNWQyxTQUFTVCxNQUFNUSxNQUFNO1lBQ3ZCO1lBRUEsT0FBT0Q7UUFDVDtRQUVBLFNBQVNILE9BQU9KLElBQUksRUFBRUMsSUFBSSxFQUFFUyxDQUFDO1lBQzNCLElBQUlSLFFBQVFRO1lBRVosTUFBT1IsUUFBUSxFQUFHO2dCQUNoQixJQUFJUyxjQUFjVCxRQUFRLE1BQU07Z0JBQ2hDLElBQUlV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LHdDQUF3QyxHQUFHbUU7UUFDM0NuRSxxQ0FBcUMsR0FBR2lFO1FBQ3hDakUscUJBQXFCLEdBQUdxRDtRQUN4QnJELCtCQUErQixHQUFHK0Q7UUFDbEMvRCw2QkFBNkIsR0FBR3lGO1FBQ2hDekYsZ0NBQWdDLEdBQUdtRDtRQUNuQ25ELGlDQUFpQyxHQUFHMEQ7UUFDcEMxRCw0QkFBNEIsR0FBRytDO1FBQy9CL0MsNkJBQTZCLEdBQUdzRDtRQUN0Qix5Q0FBeUMsR0FDbkQsSUFDRSxPQUFPakcsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQjZJLDBCQUEwQixLQUM5RCxZQUNGO1lBQ0E3SSwrQkFBK0I2SSwwQkFBMEIsQ0FBQyxJQUFJM0k7UUFDaEU7SUFFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vpc291bmQtYWdlbnQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcz9iMTE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcbnZhciBlbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmcmFtZVlpZWxkTXMgPSA1O1xuXG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICByZXR1cm4gaGVhcC5sZW5ndGggPT09IDAgPyBudWxsIDogaGVhcFswXTtcbn1cbmZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gIGlmIChoZWFwLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpcnN0ID0gaGVhcFswXTtcbiAgdmFyIGxhc3QgPSBoZWFwLnBvcCgpO1xuXG4gIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgIHNpZnREb3duKGhlYXAsIGxhc3QsIDApO1xuICB9XG5cbiAgcmV0dXJuIGZpcnN0O1xufVxuXG5mdW5jdGlvbiBzaWZ0VXAoaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuXG4gIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleCAtIDEgPj4+IDE7XG4gICAgdmFyIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuXG4gICAgaWYgKGNvbXBhcmUocGFyZW50LCBub2RlKSA+IDApIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgbGFyZ2VyLiBTd2FwIHBvc2l0aW9ucy5cbiAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgIGhlYXBbaW5kZXhdID0gcGFyZW50O1xuICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0RG93bihoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG4gIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcbiAgdmFyIGhhbGZMZW5ndGggPSBsZW5ndGggPj4+IDE7XG5cbiAgd2hpbGUgKGluZGV4IDwgaGFsZkxlbmd0aCkge1xuICAgIHZhciBsZWZ0SW5kZXggPSAoaW5kZXggKyAxKSAqIDIgLSAxO1xuICAgIHZhciBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdO1xuICAgIHZhciByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMTtcbiAgICB2YXIgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdOyAvLyBJZiB0aGUgbGVmdCBvciByaWdodCBub2RlIGlzIHNtYWxsZXIsIHN3YXAgd2l0aCB0aGUgc21hbGxlciBvZiB0aG9zZS5cblxuICAgIGlmIChjb21wYXJlKGxlZnQsIG5vZGUpIDwgMCkge1xuICAgICAgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbGVmdCkgPCAwKSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFwW2luZGV4XSA9IGxlZnQ7XG4gICAgICAgIGhlYXBbbGVmdEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gbGVmdEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBub2RlKSA8IDApIHtcbiAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBjaGlsZCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgLy8gQ29tcGFyZSBzb3J0IGluZGV4IGZpcnN0LCB0aGVuIHRhc2sgaWQuXG4gIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgcmV0dXJuIGRpZmYgIT09IDAgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG59XG5cbi8vIFRPRE86IFVzZSBzeW1ib2xzP1xudmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG52YXIgTm9ybWFsUHJpb3JpdHkgPSAzO1xudmFyIExvd1ByaW9yaXR5ID0gNDtcbnZhciBJZGxlUHJpb3JpdHkgPSA1O1xuXG5mdW5jdGlvbiBtYXJrVGFza0Vycm9yZWQodGFzaywgbXMpIHtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5cbnZhciBoYXNQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxuaWYgKGhhc1BlcmZvcm1hbmNlTm93KSB7XG4gIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgdmFyIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgfTtcbn0gLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxuXG5cbnZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7IC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuXG52YXIgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTsgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcblxudmFyIFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCA9IDI1MDtcbnZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG52YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cbnZhciBJRExFX1BSSU9SSVRZX1RJTUVPVVQgPSBtYXhTaWduZWQzMUJpdEludDsgLy8gVGFza3MgYXJlIHN0b3JlZCBvbiBhIG1pbiBoZWFwXG5cbnZhciB0YXNrUXVldWUgPSBbXTtcbnZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxudmFyIHRhc2tJZENvdW50ZXIgPSAxOyAvLyBQYXVzaW5nIHRoZSBzY2hlZHVsZXIgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG52YXIgY3VycmVudFRhc2sgPSBudWxsO1xudmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jZS5cblxudmFyIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbnZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xudmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTsgLy8gQ2FwdHVyZSBsb2NhbCByZWZlcmVuY2VzIHRvIG5hdGl2ZSBBUElzLCBpbiBjYXNlIGEgcG9seWZpbGwgb3ZlcnJpZGVzIHRoZW0uXG5cbnZhciBsb2NhbFNldFRpbWVvdXQgPSB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiBudWxsO1xudmFyIGxvY2FsQ2xlYXJUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IG51bGw7XG52YXIgbG9jYWxTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyA/IHNldEltbWVkaWF0ZSA6IG51bGw7IC8vIElFIGFuZCBOb2RlLmpzICsganNkb21cblxudmFyIGlzSW5wdXRQZW5kaW5nID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcgIT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZyAhPT0gdW5kZWZpbmVkID8gbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcuYmluZChuYXZpZ2F0b3Iuc2NoZWR1bGluZykgOiBudWxsO1xuXG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIC8vIENoZWNrIGZvciB0YXNrcyB0aGF0IGFyZSBubyBsb25nZXIgZGVsYXllZCBhbmQgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xuICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuXG5cbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgIC8vIFdlIHNjaGVkdWxlZCBhIHRpbWVvdXQgYnV0IGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC4gQ2FuY2VsIGl0LlxuICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICB9XG5cbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgIG1hcmtUYXNrRXJyb3JlZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGluaXRpYWxUaW1lO1xuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG5cbiAgd2hpbGUgKGN1cnJlbnRUYXNrICE9PSBudWxsICYmICEoZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nICkpIHtcbiAgICBpZiAoY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJiAoIWhhc1RpbWVSZW1haW5pbmcgfHwgc2hvdWxkWWllbGRUb0hvc3QoKSkpIHtcbiAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgdmFyIGRpZFVzZXJDYWxsYmFja1RpbWVvdXQgPSBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZTtcblxuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkpIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgfVxuXG4gICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gIH0gLy8gUmV0dXJuIHdoZXRoZXIgdGhlcmUncyBhZGRpdGlvbmFsIHdvcmtcblxuXG4gIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gIHZhciBwcmlvcml0eUxldmVsO1xuXG4gIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgIC8vIFNoaWZ0IGRvd24gdG8gbm9ybWFsIHByaW9yaXR5XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICB2YXIgc3RhcnRUaW1lO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG5cbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgZGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuXG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJRExFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gTE9XX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRpbWVvdXQgPSBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgdGltZW91dDtcbiAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgc29ydEluZGV4OiAtMVxuICB9O1xuXG4gIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBzdGFydFRpbWU7XG4gICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcblxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgLy8gYXJyYXkgYmFzZWQgaGVhcCwgb25seSB0aGUgZmlyc3Qgb25lLilcblxuXG4gIHRhc2suY2FsbGJhY2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufVxuXG52YXIgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbnZhciBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xudmFyIHRhc2tUaW1lb3V0SUQgPSAtMTsgLy8gU2NoZWR1bGVyIHBlcmlvZGljYWxseSB5aWVsZHMgaW4gY2FzZSB0aGVyZSBpcyBvdGhlciB3b3JrIG9uIHRoZSBtYWluXG4vLyB0aHJlYWQsIGxpa2UgdXNlciBldmVudHMuIEJ5IGRlZmF1bHQsIGl0IHlpZWxkcyBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUuXG4vLyBJdCBkb2VzIG5vdCBhdHRlbXB0IHRvIGFsaWduIHdpdGggZnJhbWUgYm91bmRhcmllcywgc2luY2UgbW9zdCB0YXNrcyBkb24ndFxuLy8gbmVlZCB0byBiZSBmcmFtZSBhbGlnbmVkOyBmb3IgdGhvc2UgdGhhdCBkbywgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cblxudmFyIGZyYW1lSW50ZXJ2YWwgPSBmcmFtZVlpZWxkTXM7XG52YXIgc3RhcnRUaW1lID0gLTE7XG5cbmZ1bmN0aW9uIHNob3VsZFlpZWxkVG9Ib3N0KCkge1xuICB2YXIgdGltZUVsYXBzZWQgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lO1xuXG4gIGlmICh0aW1lRWxhcHNlZCA8IGZyYW1lSW50ZXJ2YWwpIHtcbiAgICAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIG9ubHkgYmVlbiBibG9ja2VkIGZvciBhIHJlYWxseSBzaG9ydCBhbW91bnQgb2YgdGltZTtcbiAgICAvLyBzbWFsbGVyIHRoYW4gYSBzaW5nbGUgZnJhbWUuIERvbid0IHlpZWxkIHlldC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBiZWVuIGJsb2NrZWQgZm9yIGEgbm9uLW5lZ2xpZ2libGUgYW1vdW50IG9mIHRpbWUuIFdlXG5cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdFBhaW50KCkge1xuXG59XG5cbmZ1bmN0aW9uIGZvcmNlRnJhbWVSYXRlKGZwcykge1xuICBpZiAoZnBzIDwgMCB8fCBmcHMgPiAxMjUpIHtcbiAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICBjb25zb2xlWydlcnJvciddKCdmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgJyArICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmcHMgPiAwKSB7XG4gICAgZnJhbWVJbnRlcnZhbCA9IE1hdGguZmxvb3IoMTAwMCAvIGZwcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzZXQgdGhlIGZyYW1lcmF0ZVxuICAgIGZyYW1lSW50ZXJ2YWwgPSBmcmFtZVlpZWxkTXM7XG4gIH1cbn1cblxudmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHNjaGVkdWxlZEhvc3RDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7IC8vIEtlZXAgdHJhY2sgb2YgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIG1lYXN1cmUgaG93IGxvbmcgdGhlIG1haW4gdGhyZWFkXG4gICAgLy8gaGFzIGJlZW4gYmxvY2tlZC5cblxuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHZhciBoYXNUaW1lUmVtYWluaW5nID0gdHJ1ZTsgLy8gSWYgYSBzY2hlZHVsZXIgdGFzayB0aHJvd3MsIGV4aXQgdGhlIGN1cnJlbnQgYnJvd3NlciB0YXNrIHNvIHRoZVxuICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAvL1xuICAgIC8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGEgdHJ5LWNhdGNoLCBzaW5jZSB0aGF0IG1ha2VzIHNvbWUgZGVidWdnaW5nXG4gICAgLy8gdGVjaG5pcXVlcyBoYXJkZXIuIEluc3RlYWQsIGlmIGBzY2hlZHVsZWRIb3N0Q2FsbGJhY2tgIGVycm9ycywgdGhlblxuICAgIC8vIGBoYXNNb3JlV29ya2Agd2lsbCByZW1haW4gdHJ1ZSwgYW5kIHdlJ2xsIGNvbnRpbnVlIHRoZSB3b3JrIGxvb3AuXG5cbiAgICB2YXIgaGFzTW9yZVdvcmsgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGhhc01vcmVXb3JrID0gc2NoZWR1bGVkSG9zdENhbGxiYWNrKGhhc1RpbWVSZW1haW5pbmcsIGN1cnJlbnRUaW1lKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGhhc01vcmVXb3JrKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrLCBzY2hlZHVsZSB0aGUgbmV4dCBtZXNzYWdlIGV2ZW50IGF0IHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXG4gICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG59O1xuXG52YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbmlmICh0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gTm9kZS5qcyBhbmQgb2xkIElFLlxuICAvLyBUaGVyZSdzIGEgZmV3IHJlYXNvbnMgZm9yIHdoeSB3ZSBwcmVmZXIgc2V0SW1tZWRpYXRlLlxuICAvL1xuICAvLyBVbmxpa2UgTWVzc2FnZUNoYW5uZWwsIGl0IGRvZXNuJ3QgcHJldmVudCBhIE5vZGUuanMgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG4gIC8vIChFdmVuIHRob3VnaCB0aGlzIGlzIGEgRE9NIGZvcmsgb2YgdGhlIFNjaGVkdWxlciwgeW91IGNvdWxkIGdldCBoZXJlXG4gIC8vIHdpdGggYSBtaXggb2YgTm9kZS5qcyAxNSssIHdoaWNoIGhhcyBhIE1lc3NhZ2VDaGFubmVsLCBhbmQganNkb20uKVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNzU2XG4gIC8vXG4gIC8vIEJ1dCBhbHNvLCBpdCBydW5zIGVhcmxpZXIgd2hpY2ggaXMgdGhlIHNlbWFudGljIHdlIHdhbnQuXG4gIC8vIElmIG90aGVyIGJyb3dzZXJzIGV2ZXIgaW1wbGVtZW50IGl0LCBpdCdzIGJldHRlciB0byB1c2UgaXQuXG4gIC8vIEFsdGhvdWdoIGJvdGggb2YgdGhlc2Ugd291bGQgYmUgaW5mZXJpb3IgdG8gbmF0aXZlIHNjaGVkdWxpbmcuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gRE9NIGFuZCBXb3JrZXIgZW52aXJvbm1lbnRzLlxuICAvLyBXZSBwcmVmZXIgTWVzc2FnZUNoYW5uZWwgYmVjYXVzZSBvZiB0aGUgNG1zIHNldFRpbWVvdXQgY2xhbXBpbmcuXG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIFdlIHNob3VsZCBvbmx5IGZhbGxiYWNrIGhlcmUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEhvc3RDYWxsYmFjayhjYWxsYmFjaykge1xuICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICB0YXNrVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgfSwgbXMpO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxIb3N0VGltZW91dCgpIHtcbiAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCk7XG4gIHRhc2tUaW1lb3V0SUQgPSAtMTtcbn1cblxudmFyIHVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHJlcXVlc3RQYWludDtcbnZhciB1bnN0YWJsZV9Qcm9maWxpbmcgPSAgbnVsbDtcblxuZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gTG93UHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IHVuc3RhYmxlX1Byb2ZpbGluZztcbmV4cG9ydHMudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgPSB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb24gPSB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmb3JjZUZyYW1lUmF0ZTtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbDtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZTtcbmV4cG9ydHMudW5zdGFibGVfbmV4dCA9IHVuc3RhYmxlX25leHQ7XG5leHBvcnRzLnVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uID0gdW5zdGFibGVfcGF1c2VFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHVuc3RhYmxlX3JlcXVlc3RQYWludDtcbmV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrID0gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbmV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gdW5zdGFibGVfd3JhcENhbGxiYWNrO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nIiwiZW5hYmxlUHJvZmlsaW5nIiwiZnJhbWVZaWVsZE1zIiwicHVzaCIsImhlYXAiLCJub2RlIiwiaW5kZXgiLCJsZW5ndGgiLCJzaWZ0VXAiLCJwZWVrIiwicG9wIiwiZmlyc3QiLCJsYXN0Iiwic2lmdERvd24iLCJpIiwicGFyZW50SW5kZXgiLCJwYXJlbnQiLCJjb21wYXJlIiwiaGFsZkxlbmd0aCIsImxlZnRJbmRleCIsImxlZnQiLCJyaWdodEluZGV4IiwicmlnaHQiLCJhIiwiYiIsImRpZmYiLCJzb3J0SW5kZXgiLCJpZCIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSIsIkxvd1ByaW9yaXR5IiwiSWRsZVByaW9yaXR5IiwibWFya1Rhc2tFcnJvcmVkIiwidGFzayIsIm1zIiwiaGFzUGVyZm9ybWFuY2VOb3ciLCJwZXJmb3JtYW5jZSIsIm5vdyIsImxvY2FsUGVyZm9ybWFuY2UiLCJleHBvcnRzIiwidW5zdGFibGVfbm93IiwibG9jYWxEYXRlIiwiRGF0ZSIsImluaXRpYWxUaW1lIiwibWF4U2lnbmVkMzFCaXRJbnQiLCJJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCIsIlVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCIsIk5PUk1BTF9QUklPUklUWV9USU1FT1VUIiwiTE9XX1BSSU9SSVRZX1RJTUVPVVQiLCJJRExFX1BSSU9SSVRZX1RJTUVPVVQiLCJ0YXNrUXVldWUiLCJ0aW1lclF1ZXVlIiwidGFza0lkQ291bnRlciIsImN1cnJlbnRUYXNrIiwiY3VycmVudFByaW9yaXR5TGV2ZWwiLCJpc1BlcmZvcm1pbmdXb3JrIiwiaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQiLCJpc0hvc3RUaW1lb3V0U2NoZWR1bGVkIiwibG9jYWxTZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsImxvY2FsQ2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibG9jYWxTZXRJbW1lZGlhdGUiLCJzZXRJbW1lZGlhdGUiLCJpc0lucHV0UGVuZGluZyIsIm5hdmlnYXRvciIsInNjaGVkdWxpbmciLCJ1bmRlZmluZWQiLCJiaW5kIiwiYWR2YW5jZVRpbWVycyIsImN1cnJlbnRUaW1lIiwidGltZXIiLCJjYWxsYmFjayIsInN0YXJ0VGltZSIsImV4cGlyYXRpb25UaW1lIiwiaGFuZGxlVGltZW91dCIsInJlcXVlc3RIb3N0Q2FsbGJhY2siLCJmbHVzaFdvcmsiLCJmaXJzdFRpbWVyIiwicmVxdWVzdEhvc3RUaW1lb3V0IiwiaGFzVGltZVJlbWFpbmluZyIsImNhbmNlbEhvc3RUaW1lb3V0IiwicHJldmlvdXNQcmlvcml0eUxldmVsIiwid29ya0xvb3AiLCJlcnJvciIsImlzUXVldWVkIiwic2hvdWxkWWllbGRUb0hvc3QiLCJwcmlvcml0eUxldmVsIiwiZGlkVXNlckNhbGxiYWNrVGltZW91dCIsImNvbnRpbnVhdGlvbkNhbGxiYWNrIiwidW5zdGFibGVfcnVuV2l0aFByaW9yaXR5IiwiZXZlbnRIYW5kbGVyIiwidW5zdGFibGVfbmV4dCIsInVuc3RhYmxlX3dyYXBDYWxsYmFjayIsInBhcmVudFByaW9yaXR5TGV2ZWwiLCJhcHBseSIsImFyZ3VtZW50cyIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJvcHRpb25zIiwiZGVsYXkiLCJ0aW1lb3V0IiwibmV3VGFzayIsInVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uIiwidW5zdGFibGVfY29udGludWVFeGVjdXRpb24iLCJ1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSIsInVuc3RhYmxlX2NhbmNlbENhbGxiYWNrIiwidW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwiLCJpc01lc3NhZ2VMb29wUnVubmluZyIsInNjaGVkdWxlZEhvc3RDYWxsYmFjayIsInRhc2tUaW1lb3V0SUQiLCJmcmFtZUludGVydmFsIiwidGltZUVsYXBzZWQiLCJyZXF1ZXN0UGFpbnQiLCJmb3JjZUZyYW1lUmF0ZSIsImZwcyIsImNvbnNvbGUiLCJNYXRoIiwiZmxvb3IiLCJwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUiLCJoYXNNb3JlV29yayIsInNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydCIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsInVuc3RhYmxlX1Byb2ZpbGluZyIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfTG93UHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwidW5zdGFibGVfZm9yY2VGcmFtZVJhdGUiLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMseUtBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vpc291bmQtYWdlbnQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanM/NmJhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction createStore(createState) {\n    let state;\n    const listeners = /* @__PURE__ */ new Set();\n    const setState = (partial, replace)=>{\n        const nextState = typeof partial === \"function\" ? partial(state) : partial;\n        if (nextState !== state) {\n            const previousState = state;\n            state = replace ? nextState : Object.assign({}, state, nextState);\n            listeners.forEach((listener)=>listener(state, previousState));\n        }\n    };\n    const getState = ()=>state;\n    const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is)=>{\n        console.warn(\"[DEPRECATED] Please use `subscribeWithSelector` middleware\");\n        let currentSlice = selector(state);\n        function listenerToAdd() {\n            const nextSlice = selector(state);\n            if (!equalityFn(currentSlice, nextSlice)) {\n                const previousSlice = currentSlice;\n                listener(currentSlice = nextSlice, previousSlice);\n            }\n        }\n        listeners.add(listenerToAdd);\n        return ()=>listeners.delete(listenerToAdd);\n    };\n    const subscribe = (listener, selector, equalityFn)=>{\n        if (selector || equalityFn) {\n            return subscribeWithSelector(listener, selector, equalityFn);\n        }\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    };\n    const destroy = ()=>listeners.clear();\n    const api = {\n        setState,\n        getState,\n        subscribe,\n        destroy\n    };\n    state = createState(setState, getState, api);\n    return api;\n}\nconst isSSR =  true || 0;\nconst useIsomorphicLayoutEffect = isSSR ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction create(createState) {\n    const api = typeof createState === \"function\" ? createStore(createState) : createState;\n    const useStore = (selector = api.getState, equalityFn = Object.is)=>{\n        const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((c)=>c + 1, 0);\n        const state = api.getState();\n        const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n        const selectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selector);\n        const equalityFnRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(equalityFn);\n        const erroredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n        const currentSliceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n        if (currentSliceRef.current === void 0) {\n            currentSliceRef.current = selector(state);\n        }\n        let newStateSlice;\n        let hasNewStateSlice = false;\n        if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {\n            newStateSlice = selector(state);\n            hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);\n        }\n        useIsomorphicLayoutEffect(()=>{\n            if (hasNewStateSlice) {\n                currentSliceRef.current = newStateSlice;\n            }\n            stateRef.current = state;\n            selectorRef.current = selector;\n            equalityFnRef.current = equalityFn;\n            erroredRef.current = false;\n        });\n        const stateBeforeSubscriptionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n        useIsomorphicLayoutEffect(()=>{\n            const listener = ()=>{\n                try {\n                    const nextState = api.getState();\n                    const nextStateSlice = selectorRef.current(nextState);\n                    if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {\n                        stateRef.current = nextState;\n                        currentSliceRef.current = nextStateSlice;\n                        forceUpdate();\n                    }\n                } catch (error) {\n                    erroredRef.current = true;\n                    forceUpdate();\n                }\n            };\n            const unsubscribe = api.subscribe(listener);\n            if (api.getState() !== stateBeforeSubscriptionRef.current) {\n                listener();\n            }\n            return unsubscribe;\n        }, []);\n        const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(sliceToReturn);\n        return sliceToReturn;\n    };\n    Object.assign(useStore, api);\n    useStore[Symbol.iterator] = function() {\n        console.warn(\"[useStore, api] = create() is deprecated and will be removed in v4\");\n        const items = [\n            useStore,\n            api\n        ];\n        return {\n            next () {\n                const done = items.length <= 0;\n                return {\n                    value: items.shift(),\n                    done\n                };\n            }\n        };\n    };\n    return useStore;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7QUFFdEYsU0FBU0ssWUFBWUMsV0FBVztJQUM5QixJQUFJQztJQUNKLE1BQU1DLFlBQVksYUFBYSxHQUFHLElBQUlDO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQ0MsU0FBU0M7UUFDekIsTUFBTUMsWUFBWSxPQUFPRixZQUFZLGFBQWFBLFFBQVFKLFNBQVNJO1FBQ25FLElBQUlFLGNBQWNOLE9BQU87WUFDdkIsTUFBTU8sZ0JBQWdCUDtZQUN0QkEsUUFBUUssVUFBVUMsWUFBWUUsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1QsT0FBT007WUFDdkRMLFVBQVVTLE9BQU8sQ0FBQyxDQUFDQyxXQUFhQSxTQUFTWCxPQUFPTztRQUNsRDtJQUNGO0lBQ0EsTUFBTUssV0FBVyxJQUFNWjtJQUN2QixNQUFNYSx3QkFBd0IsQ0FBQ0YsVUFBVUcsV0FBV0YsUUFBUSxFQUFFRyxhQUFhUCxPQUFPUSxFQUFFO1FBQ2xGQyxRQUFRQyxJQUFJLENBQUM7UUFDYixJQUFJQyxlQUFlTCxTQUFTZDtRQUM1QixTQUFTb0I7WUFDUCxNQUFNQyxZQUFZUCxTQUFTZDtZQUMzQixJQUFJLENBQUNlLFdBQVdJLGNBQWNFLFlBQVk7Z0JBQ3hDLE1BQU1DLGdCQUFnQkg7Z0JBQ3RCUixTQUFTUSxlQUFlRSxXQUFXQztZQUNyQztRQUNGO1FBQ0FyQixVQUFVc0IsR0FBRyxDQUFDSDtRQUNkLE9BQU8sSUFBTW5CLFVBQVV1QixNQUFNLENBQUNKO0lBQ2hDO0lBQ0EsTUFBTUssWUFBWSxDQUFDZCxVQUFVRyxVQUFVQztRQUNyQyxJQUFJRCxZQUFZQyxZQUFZO1lBQzFCLE9BQU9GLHNCQUFzQkYsVUFBVUcsVUFBVUM7UUFDbkQ7UUFDQWQsVUFBVXNCLEdBQUcsQ0FBQ1o7UUFDZCxPQUFPLElBQU1WLFVBQVV1QixNQUFNLENBQUNi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LE1BQU1HLE1BQU0sSUFBSTtnQkFDN0IsT0FBTztvQkFBRUMsT0FBT0osTUFBTUssS0FBSztvQkFBSUg7Z0JBQUs7WUFDdEM7UUFDRjtJQUNGO0lBQ0EsT0FBT3BCO0FBQ1Q7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdWlzb3VuZC1hZ2VudC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL2luZGV4LmpzPzMzMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVkdWNlciwgdXNlUmVmLCB1c2VEZWJ1Z1ZhbHVlLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gY3JlYXRlU3RvcmUoY3JlYXRlU3RhdGUpIHtcbiAgbGV0IHN0YXRlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzZXRTdGF0ZSA9IChwYXJ0aWFsLCByZXBsYWNlKSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIiA/IHBhcnRpYWwoc3RhdGUpIDogcGFydGlhbDtcbiAgICBpZiAobmV4dFN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xuICAgICAgc3RhdGUgPSByZXBsYWNlID8gbmV4dFN0YXRlIDogT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHN0YXRlLCBwcmV2aW91c1N0YXRlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHN0YXRlO1xuICBjb25zdCBzdWJzY3JpYmVXaXRoU2VsZWN0b3IgPSAobGlzdGVuZXIsIHNlbGVjdG9yID0gZ2V0U3RhdGUsIGVxdWFsaXR5Rm4gPSBPYmplY3QuaXMpID0+IHtcbiAgICBjb25zb2xlLndhcm4oXCJbREVQUkVDQVRFRF0gUGxlYXNlIHVzZSBgc3Vic2NyaWJlV2l0aFNlbGVjdG9yYCBtaWRkbGV3YXJlXCIpO1xuICAgIGxldCBjdXJyZW50U2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXJUb0FkZCgpIHtcbiAgICAgIGNvbnN0IG5leHRTbGljZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgIGlmICghZXF1YWxpdHlGbihjdXJyZW50U2xpY2UsIG5leHRTbGljZSkpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTbGljZSA9IGN1cnJlbnRTbGljZTtcbiAgICAgICAgbGlzdGVuZXIoY3VycmVudFNsaWNlID0gbmV4dFNsaWNlLCBwcmV2aW91c1NsaWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lclRvQWRkKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lclRvQWRkKTtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gKGxpc3RlbmVyLCBzZWxlY3RvciwgZXF1YWxpdHlGbikgPT4ge1xuICAgIGlmIChzZWxlY3RvciB8fCBlcXVhbGl0eUZuKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlV2l0aFNlbGVjdG9yKGxpc3RlbmVyLCBzZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gICAgfVxuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IGxpc3RlbmVycy5jbGVhcigpO1xuICBjb25zdCBhcGkgPSB7IHNldFN0YXRlLCBnZXRTdGF0ZSwgc3Vic2NyaWJlLCBkZXN0cm95IH07XG4gIHN0YXRlID0gY3JlYXRlU3RhdGUoc2V0U3RhdGUsIGdldFN0YXRlLCBhcGkpO1xuICByZXR1cm4gYXBpO1xufVxuXG5jb25zdCBpc1NTUiA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHwgL1NlcnZlclNpZGVSZW5kZXJpbmd8XkRlbm9cXC8vLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzU1NSID8gdXNlRWZmZWN0IDogdXNlTGF5b3V0RWZmZWN0O1xuZnVuY3Rpb24gY3JlYXRlKGNyZWF0ZVN0YXRlKSB7XG4gIGNvbnN0IGFwaSA9IHR5cGVvZiBjcmVhdGVTdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY3JlYXRlU3RvcmUoY3JlYXRlU3RhdGUpIDogY3JlYXRlU3RhdGU7XG4gIGNvbnN0IHVzZVN0b3JlID0gKHNlbGVjdG9yID0gYXBpLmdldFN0YXRlLCBlcXVhbGl0eUZuID0gT2JqZWN0LmlzKSA9PiB7XG4gICAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gdXNlUmVkdWNlcigoYykgPT4gYyArIDEsIDApO1xuICAgIGNvbnN0IHN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIGNvbnN0IHNlbGVjdG9yUmVmID0gdXNlUmVmKHNlbGVjdG9yKTtcbiAgICBjb25zdCBlcXVhbGl0eUZuUmVmID0gdXNlUmVmKGVxdWFsaXR5Rm4pO1xuICAgIGNvbnN0IGVycm9yZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGN1cnJlbnRTbGljZVJlZiA9IHVzZVJlZigpO1xuICAgIGlmIChjdXJyZW50U2xpY2VSZWYuY3VycmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBjdXJyZW50U2xpY2VSZWYuY3VycmVudCA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG5ld1N0YXRlU2xpY2U7XG4gICAgbGV0IGhhc05ld1N0YXRlU2xpY2UgPSBmYWxzZTtcbiAgICBpZiAoc3RhdGVSZWYuY3VycmVudCAhPT0gc3RhdGUgfHwgc2VsZWN0b3JSZWYuY3VycmVudCAhPT0gc2VsZWN0b3IgfHwgZXF1YWxpdHlGblJlZi5jdXJyZW50ICE9PSBlcXVhbGl0eUZuIHx8IGVycm9yZWRSZWYuY3VycmVudCkge1xuICAgICAgbmV3U3RhdGVTbGljZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgIGhhc05ld1N0YXRlU2xpY2UgPSAhZXF1YWxpdHlGbihjdXJyZW50U2xpY2VSZWYuY3VycmVudCwgbmV3U3RhdGVTbGljZSk7XG4gICAgfVxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGhhc05ld1N0YXRlU2xpY2UpIHtcbiAgICAgICAgY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPSBuZXdTdGF0ZVNsaWNlO1xuICAgICAgfVxuICAgICAgc3RhdGVSZWYuY3VycmVudCA9IHN0YXRlO1xuICAgICAgc2VsZWN0b3JSZWYuY3VycmVudCA9IHNlbGVjdG9yO1xuICAgICAgZXF1YWxpdHlGblJlZi5jdXJyZW50ID0gZXF1YWxpdHlGbjtcbiAgICAgIGVycm9yZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIGNvbnN0IHN0YXRlQmVmb3JlU3Vic2NyaXB0aW9uUmVmID0gdXNlUmVmKHN0YXRlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IG5leHRTdGF0ZVNsaWNlID0gc2VsZWN0b3JSZWYuY3VycmVudChuZXh0U3RhdGUpO1xuICAgICAgICAgIGlmICghZXF1YWxpdHlGblJlZi5jdXJyZW50KGN1cnJlbnRTbGljZVJlZi5jdXJyZW50LCBuZXh0U3RhdGVTbGljZSkpIHtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICBjdXJyZW50U2xpY2VSZWYuY3VycmVudCA9IG5leHRTdGF0ZVNsaWNlO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZXJyb3JlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBhcGkuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICAgIGlmIChhcGkuZ2V0U3RhdGUoKSAhPT0gc3RhdGVCZWZvcmVTdWJzY3JpcHRpb25SZWYuY3VycmVudCkge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzbGljZVRvUmV0dXJuID0gaGFzTmV3U3RhdGVTbGljZSA/IG5ld1N0YXRlU2xpY2UgOiBjdXJyZW50U2xpY2VSZWYuY3VycmVudDtcbiAgICB1c2VEZWJ1Z1ZhbHVlKHNsaWNlVG9SZXR1cm4pO1xuICAgIHJldHVybiBzbGljZVRvUmV0dXJuO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVN0b3JlLCBhcGkpO1xuICB1c2VTdG9yZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS53YXJuKFwiW3VzZVN0b3JlLCBhcGldID0gY3JlYXRlKCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY0XCIpO1xuICAgIGNvbnN0IGl0ZW1zID0gW3VzZVN0b3JlLCBhcGldO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBkb25lID0gaXRlbXMubGVuZ3RoIDw9IDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtcy5zaGlmdCgpLCBkb25lIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHVzZVN0b3JlO1xufVxuXG5leHBvcnQgeyBjcmVhdGUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiY3JlYXRlU3RvcmUiLCJjcmVhdGVTdGF0ZSIsInN0YXRlIiwibGlzdGVuZXJzIiwiU2V0Iiwic2V0U3RhdGUiLCJwYXJ0aWFsIiwicmVwbGFjZSIsIm5leHRTdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJPYmplY3QiLCJhc3NpZ24iLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJnZXRTdGF0ZSIsInN1YnNjcmliZVdpdGhTZWxlY3RvciIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsImlzIiwiY29uc29sZSIsIndhcm4iLCJjdXJyZW50U2xpY2UiLCJsaXN0ZW5lclRvQWRkIiwibmV4dFNsaWNlIiwicHJldmlvdXNTbGljZSIsImFkZCIsImRlbGV0ZSIsInN1YnNjcmliZSIsImRlc3Ryb3kiLCJjbGVhciIsImFwaSIsImlzU1NSIiwid2luZG93IiwibmF2aWdhdG9yIiwidGVzdCIsInVzZXJBZ2VudCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjcmVhdGUiLCJ1c2VTdG9yZSIsImZvcmNlVXBkYXRlIiwiYyIsInN0YXRlUmVmIiwic2VsZWN0b3JSZWYiLCJlcXVhbGl0eUZuUmVmIiwiZXJyb3JlZFJlZiIsImN1cnJlbnRTbGljZVJlZiIsImN1cnJlbnQiLCJuZXdTdGF0ZVNsaWNlIiwiaGFzTmV3U3RhdGVTbGljZSIsInN0YXRlQmVmb3JlU3Vic2NyaXB0aW9uUmVmIiwibmV4dFN0YXRlU2xpY2UiLCJlcnJvciIsInVuc3Vic2NyaWJlIiwic2xpY2VUb1JldHVybiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXRlbXMiLCJuZXh0IiwiZG9uZSIsImxlbmd0aCIsInZhbHVlIiwic2hpZnQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\n");

/***/ })

};
;