"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot";
exports.ids = ["vendor-chunks/valibot"];
exports.modules = {

/***/ "(ssr)/./node_modules/valibot/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/valibot/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIC_REGEX: () => (/* binding */ BIC_REGEX),\n/* harmony export */   CUID2_REGEX: () => (/* binding */ CUID2_REGEX),\n/* harmony export */   DECIMAL_REGEX: () => (/* binding */ DECIMAL_REGEX),\n/* harmony export */   EMAIL_REGEX: () => (/* binding */ EMAIL_REGEX),\n/* harmony export */   EMOJI_REGEX: () => (/* binding */ EMOJI_REGEX),\n/* harmony export */   HEXADECIMAL_REGEX: () => (/* binding */ HEXADECIMAL_REGEX),\n/* harmony export */   HEX_COLOR_REGEX: () => (/* binding */ HEX_COLOR_REGEX),\n/* harmony export */   IMEI_REGEX: () => (/* binding */ IMEI_REGEX),\n/* harmony export */   IPV4_REGEX: () => (/* binding */ IPV4_REGEX),\n/* harmony export */   IPV6_REGEX: () => (/* binding */ IPV6_REGEX),\n/* harmony export */   IP_REGEX: () => (/* binding */ IP_REGEX),\n/* harmony export */   ISO_DATE_REGEX: () => (/* binding */ ISO_DATE_REGEX),\n/* harmony export */   ISO_DATE_TIME_REGEX: () => (/* binding */ ISO_DATE_TIME_REGEX),\n/* harmony export */   ISO_TIMESTAMP_REGEX: () => (/* binding */ ISO_TIMESTAMP_REGEX),\n/* harmony export */   ISO_TIME_REGEX: () => (/* binding */ ISO_TIME_REGEX),\n/* harmony export */   ISO_TIME_SECOND_REGEX: () => (/* binding */ ISO_TIME_SECOND_REGEX),\n/* harmony export */   ISO_WEEK_REGEX: () => (/* binding */ ISO_WEEK_REGEX),\n/* harmony export */   MAC48_REGEX: () => (/* binding */ MAC48_REGEX),\n/* harmony export */   MAC64_REGEX: () => (/* binding */ MAC64_REGEX),\n/* harmony export */   MAC_REGEX: () => (/* binding */ MAC_REGEX),\n/* harmony export */   OCTAL_REGEX: () => (/* binding */ OCTAL_REGEX),\n/* harmony export */   ULID_REGEX: () => (/* binding */ ULID_REGEX),\n/* harmony export */   UUID_REGEX: () => (/* binding */ UUID_REGEX),\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   _addIssue: () => (/* binding */ _addIssue),\n/* harmony export */   _isLuhnAlgo: () => (/* binding */ _isLuhnAlgo),\n/* harmony export */   _isValidObjectKey: () => (/* binding */ _isValidObjectKey),\n/* harmony export */   _stringify: () => (/* binding */ _stringify),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   awaitAsync: () => (/* binding */ awaitAsync),\n/* harmony export */   bic: () => (/* binding */ bic),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   check: () => (/* binding */ check),\n/* harmony export */   checkAsync: () => (/* binding */ checkAsync),\n/* harmony export */   checkItems: () => (/* binding */ checkItems),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   creditCard: () => (/* binding */ creditCard),\n/* harmony export */   cuid2: () => (/* binding */ cuid2),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   deleteGlobalConfig: () => (/* binding */ deleteGlobalConfig),\n/* harmony export */   deleteGlobalMessage: () => (/* binding */ deleteGlobalMessage),\n/* harmony export */   deleteSchemaMessage: () => (/* binding */ deleteSchemaMessage),\n/* harmony export */   deleteSpecificMessage: () => (/* binding */ deleteSpecificMessage),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   entriesFromList: () => (/* binding */ entriesFromList),\n/* harmony export */   \"enum\": () => (/* binding */ enum_),\n/* harmony export */   enum_: () => (/* binding */ enum_),\n/* harmony export */   everyItem: () => (/* binding */ everyItem),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   file: () => (/* binding */ file),\n/* harmony export */   filterItems: () => (/* binding */ filterItems),\n/* harmony export */   findItem: () => (/* binding */ findItem),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   forwardAsync: () => (/* binding */ forwardAsync),\n/* harmony export */   \"function\": () => (/* binding */ function_),\n/* harmony export */   function_: () => (/* binding */ function_),\n/* harmony export */   getDefault: () => (/* binding */ getDefault),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getDefaultsAsync: () => (/* binding */ getDefaultsAsync),\n/* harmony export */   getDotPath: () => (/* binding */ getDotPath),\n/* harmony export */   getFallback: () => (/* binding */ getFallback),\n/* harmony export */   getFallbacks: () => (/* binding */ getFallbacks),\n/* harmony export */   getFallbacksAsync: () => (/* binding */ getFallbacksAsync),\n/* harmony export */   getGlobalConfig: () => (/* binding */ getGlobalConfig),\n/* harmony export */   getGlobalMessage: () => (/* binding */ getGlobalMessage),\n/* harmony export */   getSchemaMessage: () => (/* binding */ getSchemaMessage),\n/* harmony export */   getSpecificMessage: () => (/* binding */ getSpecificMessage),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   hexColor: () => (/* binding */ hexColor),\n/* harmony export */   hexadecimal: () => (/* binding */ hexadecimal),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersect: () => (/* binding */ intersect),\n/* harmony export */   intersectAsync: () => (/* binding */ intersectAsync),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isOfKind: () => (/* binding */ isOfKind),\n/* harmony export */   isOfType: () => (/* binding */ isOfType),\n/* harmony export */   isValiError: () => (/* binding */ isValiError),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   lazyAsync: () => (/* binding */ lazyAsync),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   looseObject: () => (/* binding */ looseObject),\n/* harmony export */   looseObjectAsync: () => (/* binding */ looseObjectAsync),\n/* harmony export */   looseTuple: () => (/* binding */ looseTuple),\n/* harmony export */   looseTupleAsync: () => (/* binding */ looseTupleAsync),\n/* harmony export */   mac: () => (/* binding */ mac),\n/* harmony export */   mac48: () => (/* binding */ mac48),\n/* harmony export */   mac64: () => (/* binding */ mac64),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   mapItems: () => (/* binding */ mapItems),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonEmpty: () => (/* binding */ nonEmpty),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   notBytes: () => (/* binding */ notBytes),\n/* harmony export */   notLength: () => (/* binding */ notLength),\n/* harmony export */   notSize: () => (/* binding */ notSize),\n/* harmony export */   notValue: () => (/* binding */ notValue),\n/* harmony export */   \"null\": () => (/* binding */ null_),\n/* harmony export */   null_: () => (/* binding */ null_),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   objectWithRest: () => (/* binding */ objectWithRest),\n/* harmony export */   objectWithRestAsync: () => (/* binding */ objectWithRestAsync),\n/* harmony export */   octal: () => (/* binding */ octal),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   parserAsync: () => (/* binding */ parserAsync),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   partialCheck: () => (/* binding */ partialCheck),\n/* harmony export */   partialCheckAsync: () => (/* binding */ partialCheckAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   picklist: () => (/* binding */ picklist),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   pipeAsync: () => (/* binding */ pipeAsync),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   rawCheck: () => (/* binding */ rawCheck),\n/* harmony export */   rawCheckAsync: () => (/* binding */ rawCheckAsync),\n/* harmony export */   rawTransform: () => (/* binding */ rawTransform),\n/* harmony export */   rawTransformAsync: () => (/* binding */ rawTransformAsync),\n/* harmony export */   readonly: () => (/* binding */ readonly),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   reduceItems: () => (/* binding */ reduceItems),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   safeParser: () => (/* binding */ safeParser),\n/* harmony export */   safeParserAsync: () => (/* binding */ safeParserAsync),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   setGlobalConfig: () => (/* binding */ setGlobalConfig),\n/* harmony export */   setGlobalMessage: () => (/* binding */ setGlobalMessage),\n/* harmony export */   setSchemaMessage: () => (/* binding */ setSchemaMessage),\n/* harmony export */   setSpecificMessage: () => (/* binding */ setSpecificMessage),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   someItem: () => (/* binding */ someItem),\n/* harmony export */   sortItems: () => (/* binding */ sortItems),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   strictObject: () => (/* binding */ strictObject),\n/* harmony export */   strictObjectAsync: () => (/* binding */ strictObjectAsync),\n/* harmony export */   strictTuple: () => (/* binding */ strictTuple),\n/* harmony export */   strictTupleAsync: () => (/* binding */ strictTupleAsync),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   trim: () => (/* binding */ trim),\n/* harmony export */   trimEnd: () => (/* binding */ trimEnd),\n/* harmony export */   trimStart: () => (/* binding */ trimStart),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   tupleWithRest: () => (/* binding */ tupleWithRest),\n/* harmony export */   tupleWithRestAsync: () => (/* binding */ tupleWithRestAsync),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   undefined: () => (/* binding */ undefined_),\n/* harmony export */   undefined_: () => (/* binding */ undefined_),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   variant: () => (/* binding */ variant),\n/* harmony export */   variantAsync: () => (/* binding */ variantAsync),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   void_: () => (/* binding */ void_)\n/* harmony export */ });\n// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n    return {\n        kind: \"transformation\",\n        type: \"await\",\n        reference: awaitAsync,\n        async: true,\n        async _run (dataset) {\n            dataset.value = await dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n/^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n    store = {\n        ...store,\n        ...config2\n    };\n}\nfunction getGlobalConfig(config2) {\n    return {\n        lang: config2?.lang ?? store?.lang,\n        message: config2?.message,\n        abortEarly: config2?.abortEarly ?? store?.abortEarly,\n        abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n    };\n}\nfunction deleteGlobalConfig() {\n    store = void 0;\n}\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n    if (!store2) store2 = /* @__PURE__ */ new Map();\n    store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n    return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n    store2?.delete(lang);\n}\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n    if (!store3) store3 = /* @__PURE__ */ new Map();\n    store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n    return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n    store3?.delete(lang);\n}\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n    if (!store4) store4 = /* @__PURE__ */ new Map();\n    if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n    store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n    return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n    store4?.get(reference)?.delete(lang);\n}\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n    const type = typeof input;\n    if (type === \"string\") {\n        return `\"${input}\"`;\n    }\n    if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n        return `${input}`;\n    }\n    if (type === \"object\" || type === \"function\") {\n        return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n    }\n    return type;\n}\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n    const input = other && \"input\" in other ? other.input : dataset.value;\n    const expected = other?.expected ?? context.expects ?? null;\n    const received = other?.received ?? _stringify(input);\n    const issue = {\n        kind: context.kind,\n        type: context.type,\n        input,\n        expected,\n        received,\n        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n        // @ts-expect-error\n        requirement: context.requirement,\n        path: other?.path,\n        issues: other?.issues,\n        lang: config2.lang,\n        abortEarly: config2.abortEarly,\n        abortPipeEarly: config2.abortPipeEarly\n    };\n    const isSchema = context.kind === \"schema\";\n    const message = other?.message ?? // @ts-expect-error\n    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n    if (message) {\n        issue.message = typeof message === \"function\" ? message(issue) : message;\n    }\n    if (isSchema) {\n        dataset.typed = false;\n    }\n    if (dataset.issues) {\n        dataset.issues.push(issue);\n    } else {\n        dataset.issues = [\n            issue\n        ];\n    }\n}\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n    const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n    let length2 = number2.length;\n    let bit = 1;\n    let sum = 0;\n    while(length2){\n        const value2 = +number2[--length2];\n        bit ^= 1;\n        sum += bit ? [\n            0,\n            2,\n            4,\n            6,\n            8,\n            1,\n            3,\n            5,\n            7,\n            9\n        ][value2] : value2;\n    }\n    return sum % 10 === 0;\n}\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n    return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n    const entries = {};\n    for (const key of list){\n        entries[key] = schema;\n    }\n    return entries;\n}\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n    if (issue.path) {\n        let key = \"\";\n        for (const item of issue.path){\n            if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n                if (key) {\n                    key += `.${item.key}`;\n                } else {\n                    key += item.key;\n                }\n            } else {\n                return null;\n            }\n        }\n        return key;\n    }\n    return null;\n}\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n    return object2.kind === kind;\n}\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n    return object2.type === type;\n}\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n    return error instanceof ValiError;\n}\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n    /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */ constructor(issues){\n        super(issues[0].message);\n        this.name = \"ValiError\";\n        this.issues = issues;\n    }\n};\n// src/actions/bic/bic.ts\nfunction bic(message) {\n    return {\n        kind: \"validation\",\n        type: \"bic\",\n        reference: bic,\n        async: false,\n        expects: null,\n        requirement: BIC_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"BIC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/brand/brand.ts\nfunction brand(name) {\n    return {\n        kind: \"transformation\",\n        type: \"brand\",\n        reference: brand,\n        async: false,\n        name,\n        _run (dataset) {\n            return dataset;\n        }\n    };\n}\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"bytes\",\n        reference: bytes,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 !== this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"check\",\n        reference: check,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"check\",\n        reference: checkAsync,\n        async: true,\n        expects: null,\n        requirement,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.typed && !await this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"check_items\",\n        reference: checkItems,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                for(let index = 0; index < dataset.value.length; index++){\n                    const item = dataset.value[index];\n                    if (!this.requirement(item, index, dataset.value)) {\n                        _addIssue(this, \"item\", dataset, config2, {\n                            input: item,\n                            path: [\n                                {\n                                    type: \"array\",\n                                    origin: \"value\",\n                                    input: dataset.value,\n                                    key: index,\n                                    value: item\n                                }\n                            ]\n                        });\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n    // American Express\n    /^3[47]\\d{13}$/u,\n    // Diners Club\n    /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n    // Discover\n    /^6(?:011|5\\d{2})\\d{12,15}$/u,\n    // JCB\n    /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n    // Mastercard\n    /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n    // UnionPay\n    /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n    // Visa\n    /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n    return {\n        kind: \"validation\",\n        type: \"credit_card\",\n        reference: creditCard,\n        async: false,\n        expects: null,\n        requirement (input) {\n            let sanitized;\n            return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n            (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n            PROVIDER_REGEX_LIST.some((regex2)=>regex2.test(sanitized)) && // Check if passes luhn algorithm\n            _isLuhnAlgo(sanitized);\n        },\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"credit card\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n    return {\n        kind: \"validation\",\n        type: \"cuid2\",\n        reference: cuid2,\n        async: false,\n        expects: null,\n        requirement: CUID2_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"Cuid2\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n    return {\n        kind: \"validation\",\n        type: \"decimal\",\n        reference: decimal,\n        async: false,\n        expects: null,\n        requirement: DECIMAL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"decimal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/email/email.ts\nfunction email(message) {\n    return {\n        kind: \"validation\",\n        type: \"email\",\n        reference: email,\n        expects: null,\n        async: false,\n        requirement: EMAIL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"email\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n    return {\n        kind: \"validation\",\n        type: \"emoji\",\n        reference: emoji,\n        async: false,\n        expects: null,\n        requirement: EMOJI_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"emoji\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/empty/empty.ts\nfunction empty(message) {\n    return {\n        kind: \"validation\",\n        type: \"empty\",\n        reference: empty,\n        async: false,\n        expects: \"0\",\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length > 0) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"ends_with\",\n        reference: endsWith,\n        async: false,\n        expects: `\"${requirement}\"`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n                _addIssue(this, \"end\", dataset, config2, {\n                    received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"every_item\",\n        reference: everyItem,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.every(this.requirement)) {\n                _addIssue(this, \"item\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n    const received = _stringify(requirement);\n    return {\n        kind: \"validation\",\n        type: \"excludes\",\n        reference: excludes,\n        async: false,\n        expects: `!${received}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.includes(this.requirement)) {\n                _addIssue(this, \"content\", dataset, config2, {\n                    received\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"filter_items\",\n        reference: filterItems,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.filter(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"find_item\",\n        reference: findItem,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.find(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/finite/finite.ts\nfunction finite(message) {\n    return {\n        kind: \"validation\",\n        type: \"finite\",\n        reference: finite,\n        async: false,\n        expects: null,\n        requirement: Number.isFinite,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"finite\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n    md4: 32,\n    md5: 32,\n    sha1: 40,\n    sha256: 64,\n    sha384: 96,\n    sha512: 128,\n    ripemd128: 32,\n    ripemd160: 40,\n    tiger128: 32,\n    tiger160: 40,\n    tiger192: 48,\n    crc32: 8,\n    crc32b: 8,\n    adler32: 8\n};\nfunction hash(types, message) {\n    return {\n        kind: \"validation\",\n        type: \"hash\",\n        reference: hash,\n        expects: null,\n        async: false,\n        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hash\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n    return {\n        kind: \"validation\",\n        type: \"hexadecimal\",\n        reference: hexadecimal,\n        async: false,\n        expects: null,\n        requirement: HEXADECIMAL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hexadecimal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n    return {\n        kind: \"validation\",\n        type: \"hex_color\",\n        reference: hexColor,\n        async: false,\n        expects: null,\n        requirement: HEX_COLOR_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hex color\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/imei/imei.ts\nfunction imei(message) {\n    return {\n        kind: \"validation\",\n        type: \"imei\",\n        reference: imei,\n        async: false,\n        expects: null,\n        requirement (input) {\n            return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n        },\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"IMEI\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n    const expects = _stringify(requirement);\n    return {\n        kind: \"validation\",\n        type: \"includes\",\n        reference: includes,\n        async: false,\n        expects,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.includes(this.requirement)) {\n                _addIssue(this, \"content\", dataset, config2, {\n                    received: `!${expects}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/integer/integer.ts\nfunction integer(message) {\n    return {\n        kind: \"validation\",\n        type: \"integer\",\n        reference: integer,\n        async: false,\n        expects: null,\n        requirement: Number.isInteger,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"integer\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ip/ip.ts\nfunction ip(message) {\n    return {\n        kind: \"validation\",\n        type: \"ip\",\n        reference: ip,\n        async: false,\n        expects: null,\n        requirement: IP_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IP\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n    return {\n        kind: \"validation\",\n        type: \"ipv4\",\n        reference: ipv4,\n        async: false,\n        expects: null,\n        requirement: IPV4_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IPv4\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n    return {\n        kind: \"validation\",\n        type: \"ipv6\",\n        reference: ipv6,\n        async: false,\n        expects: null,\n        requirement: IPV6_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IPv6\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_date\",\n        reference: isoDate,\n        async: false,\n        expects: null,\n        requirement: ISO_DATE_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"date\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_date_time\",\n        reference: isoDateTime,\n        async: false,\n        expects: null,\n        requirement: ISO_DATE_TIME_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"date-time\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_time\",\n        reference: isoTime,\n        async: false,\n        expects: null,\n        requirement: ISO_TIME_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"time\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_time_second\",\n        reference: isoTimeSecond,\n        async: false,\n        expects: null,\n        requirement: ISO_TIME_SECOND_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"time-second\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_timestamp\",\n        reference: isoTimestamp,\n        async: false,\n        expects: null,\n        requirement: ISO_TIMESTAMP_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"timestamp\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_week\",\n        reference: isoWeek,\n        async: false,\n        expects: null,\n        requirement: ISO_WEEK_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"week\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"length\",\n        reference: length,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length !== this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac/mac.ts\nfunction mac(message) {\n    return {\n        kind: \"validation\",\n        type: \"mac\",\n        reference: mac,\n        async: false,\n        expects: null,\n        requirement: MAC_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n    return {\n        kind: \"validation\",\n        type: \"mac48\",\n        reference: mac48,\n        async: false,\n        expects: null,\n        requirement: MAC48_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"48-bit MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n    return {\n        kind: \"validation\",\n        type: \"mac64\",\n        reference: mac64,\n        async: false,\n        expects: null,\n        requirement: MAC64_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"64-bit MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"map_items\",\n        reference: mapItems,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.map(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_bytes\",\n        reference: maxBytes,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 > this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_length\",\n        reference: maxLength,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length > this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_size\",\n        reference: maxSize,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size > this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_value\",\n        reference: maxValue,\n        async: false,\n        expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value > this.requirement) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"mime_type\",\n        reference: mimeType,\n        async: false,\n        expects: requirement.map((option)=>`\"${option}\"`).join(\" | \") || \"never\",\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n                _addIssue(this, \"MIME type\", dataset, config2, {\n                    received: `\"${dataset.value.type}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_bytes\",\n        reference: minBytes,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 < this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_length\",\n        reference: minLength,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length < this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_size\",\n        reference: minSize,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size < this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_value\",\n        reference: minValue,\n        async: false,\n        expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value < this.requirement) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"multiple_of\",\n        reference: multipleOf,\n        async: false,\n        expects: `%${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value % this.requirement !== 0) {\n                _addIssue(this, \"multiple\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n    return {\n        kind: \"validation\",\n        type: \"non_empty\",\n        reference: nonEmpty,\n        async: false,\n        expects: \"!0\",\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length === 0) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: \"0\"\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n    return {\n        kind: \"transformation\",\n        type: \"normalize\",\n        reference: normalize,\n        async: false,\n        form,\n        _run (dataset) {\n            dataset.value = dataset.value.normalize(this.form);\n            return dataset;\n        }\n    };\n}\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_bytes\",\n        reference: notBytes,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 === this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_length\",\n        reference: notLength,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length === this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_size\",\n        reference: notSize,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size === this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_value\",\n        reference: notValue,\n        async: false,\n        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/octal/octal.ts\nfunction octal(message) {\n    return {\n        kind: \"validation\",\n        type: \"octal\",\n        reference: octal,\n        async: false,\n        expects: null,\n        requirement: OCTAL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"octal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n    if (dataset.issues) {\n        for (const path of pathList){\n            for (const issue of dataset.issues){\n                let typed = false;\n                const bound = Math.min(path.length, issue.path?.length ?? 0);\n                for(let index = 0; index < bound; index++){\n                    if (path[index] !== issue.path[index].key) {\n                        typed = true;\n                        break;\n                    }\n                }\n                if (!typed) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"partial_check\",\n        reference: partialCheck,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n            !this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"partial_check\",\n        reference: partialCheckAsync,\n        async: true,\n        expects: null,\n        requirement,\n        message,\n        async _run (dataset, config2) {\n            if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n            !await this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n    return {\n        kind: \"validation\",\n        type: \"raw_check\",\n        reference: rawCheck,\n        async: false,\n        expects: null,\n        _run (dataset, config2) {\n            action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n            });\n            return dataset;\n        }\n    };\n}\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n    return {\n        kind: \"validation\",\n        type: \"raw_check\",\n        reference: rawCheckAsync,\n        async: true,\n        expects: null,\n        async _run (dataset, config2) {\n            await action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n            });\n            return dataset;\n        }\n    };\n}\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n    return {\n        kind: \"transformation\",\n        type: \"raw_transform\",\n        reference: rawTransform,\n        async: false,\n        _run (dataset, config2) {\n            const output = action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n                NEVER: null\n            });\n            if (dataset.issues) {\n                dataset.typed = false;\n            } else {\n                dataset.value = output;\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n    return {\n        kind: \"transformation\",\n        type: \"raw_transform\",\n        reference: rawTransformAsync,\n        async: true,\n        async _run (dataset, config2) {\n            const output = await action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n                NEVER: null\n            });\n            if (dataset.issues) {\n                dataset.typed = false;\n            } else {\n                dataset.value = output;\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n    return {\n        kind: \"transformation\",\n        type: \"readonly\",\n        reference: readonly,\n        async: false,\n        _run (dataset) {\n            return dataset;\n        }\n    };\n}\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n    return {\n        kind: \"transformation\",\n        type: \"reduce_items\",\n        reference: reduceItems,\n        async: false,\n        operation,\n        initial,\n        _run (dataset) {\n            dataset.value = dataset.value.reduce(this.operation, this.initial);\n            return dataset;\n        }\n    };\n}\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"regex\",\n        reference: regex,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"format\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n    return {\n        kind: \"validation\",\n        type: \"safe_integer\",\n        reference: safeInteger,\n        async: false,\n        expects: null,\n        requirement: Number.isSafeInteger,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"safe integer\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"size\",\n        reference: size,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size !== this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"some_item\",\n        reference: someItem,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.some(this.requirement)) {\n                _addIssue(this, \"item\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"sort_items\",\n        reference: sortItems,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.sort(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"starts_with\",\n        reference: startsWith,\n        async: false,\n        expects: `\"${requirement}\"`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n                _addIssue(this, \"start\", dataset, config2, {\n                    received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n    return {\n        kind: \"transformation\",\n        type: \"to_lower_case\",\n        reference: toLowerCase,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.toLowerCase();\n            return dataset;\n        }\n    };\n}\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n    return {\n        kind: \"transformation\",\n        type: \"to_max_value\",\n        reference: toMaxValue,\n        async: false,\n        requirement,\n        _run (dataset) {\n            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n    return {\n        kind: \"transformation\",\n        type: \"to_min_value\",\n        reference: toMinValue,\n        async: false,\n        requirement,\n        _run (dataset) {\n            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n    return {\n        kind: \"transformation\",\n        type: \"to_upper_case\",\n        reference: toUpperCase,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.toUpperCase();\n            return dataset;\n        }\n    };\n}\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"transform\",\n        reference: transform,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = this.operation(dataset.value);\n            return dataset;\n        }\n    };\n}\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"transform\",\n        reference: transformAsync,\n        async: true,\n        operation,\n        async _run (dataset) {\n            dataset.value = await this.operation(dataset.value);\n            return dataset;\n        }\n    };\n}\n// src/actions/trim/trim.ts\nfunction trim() {\n    return {\n        kind: \"transformation\",\n        type: \"trim\",\n        reference: trim,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.trim();\n            return dataset;\n        }\n    };\n}\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n    return {\n        kind: \"transformation\",\n        type: \"trim_end\",\n        reference: trimEnd,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.trimEnd();\n            return dataset;\n        }\n    };\n}\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n    return {\n        kind: \"transformation\",\n        type: \"trim_start\",\n        reference: trimStart,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.trimStart();\n            return dataset;\n        }\n    };\n}\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n    return {\n        kind: \"validation\",\n        type: \"ulid\",\n        reference: ulid,\n        async: false,\n        expects: null,\n        requirement: ULID_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"ULID\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/url/url.ts\nfunction url(message) {\n    return {\n        kind: \"validation\",\n        type: \"url\",\n        reference: url,\n        async: false,\n        expects: null,\n        requirement (input) {\n            try {\n                new URL(input);\n                return true;\n            } catch  {\n                return false;\n            }\n        },\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"URL\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n    return {\n        kind: \"validation\",\n        type: \"uuid\",\n        reference: uuid,\n        async: false,\n        expects: null,\n        requirement: UUID_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"UUID\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"value\",\n        reference: value,\n        async: false,\n        expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n    return {\n        ...schema,\n        _run (dataset, config_) {\n            return schema._run(dataset, {\n                ...config_,\n                ...config2\n            });\n        }\n    };\n}\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n    return typeof schema.fallback === \"function\" ? // @ts-expect-error\n    schema.fallback(dataset, config2) : // @ts-expect-error\n    schema.fallback;\n}\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        _run (dataset, config2) {\n            schema._run(dataset, config2);\n            return dataset.issues ? {\n                typed: true,\n                value: getFallback(this, dataset, config2)\n            } : dataset;\n        }\n    };\n}\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        async: true,\n        async _run (dataset, config2) {\n            schema._run(dataset, config2);\n            return dataset.issues ? // @ts-expect-error\n            {\n                typed: true,\n                value: await getFallback(this, dataset, config2)\n            } : dataset;\n        }\n    };\n}\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n    const flatErrors = {};\n    for (const issue of issues){\n        if (issue.path) {\n            const dotPath = getDotPath(issue);\n            if (dotPath) {\n                if (!flatErrors.nested) {\n                    flatErrors.nested = {};\n                }\n                if (flatErrors.nested[dotPath]) {\n                    flatErrors.nested[dotPath].push(issue.message);\n                } else {\n                    flatErrors.nested[dotPath] = [\n                        issue.message\n                    ];\n                }\n            } else {\n                if (flatErrors.other) {\n                    flatErrors.other.push(issue.message);\n                } else {\n                    flatErrors.other = [\n                        issue.message\n                    ];\n                }\n            }\n        } else {\n            if (flatErrors.root) {\n                flatErrors.root.push(issue.message);\n            } else {\n                flatErrors.root = [\n                    issue.message\n                ];\n            }\n        }\n    }\n    return flatErrors;\n}\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n    return {\n        ...action,\n        _run (dataset, config2) {\n            const prevIssues = dataset.issues && [\n                ...dataset.issues\n            ];\n            action._run(dataset, config2);\n            if (dataset.issues) {\n                for (const issue of dataset.issues){\n                    if (!prevIssues?.includes(issue)) {\n                        let pathInput = dataset.value;\n                        for (const key of pathKeys){\n                            const pathValue = pathInput[key];\n                            const pathItem = {\n                                type: \"unknown\",\n                                origin: \"value\",\n                                input: pathInput,\n                                key,\n                                value: pathValue\n                            };\n                            if (issue.path) {\n                                issue.path.push(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            if (!pathValue) {\n                                break;\n                            }\n                            pathInput = pathValue;\n                        }\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n    return {\n        ...action,\n        async: true,\n        async _run (dataset, config2) {\n            const prevIssues = dataset.issues && [\n                ...dataset.issues\n            ];\n            await action._run(dataset, config2);\n            if (dataset.issues) {\n                for (const issue of dataset.issues){\n                    if (!prevIssues?.includes(issue)) {\n                        let pathInput = dataset.value;\n                        for (const key of pathKeys){\n                            const pathValue = pathInput[key];\n                            const pathItem = {\n                                type: \"unknown\",\n                                origin: \"value\",\n                                input: pathInput,\n                                key,\n                                value: pathValue\n                            };\n                            if (issue.path) {\n                                issue.path.push(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            if (!pathValue) {\n                                break;\n                            }\n                            pathInput = pathValue;\n                        }\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n    return typeof schema.default === \"function\" ? // @ts-expect-error\n    schema.default(dataset, config2) : // @ts-expect-error\n    schema.default;\n}\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n    if (\"entries\" in schema) {\n        const object2 = {};\n        for(const key in schema.entries){\n            object2[key] = getDefaults(schema.entries[key]);\n        }\n        return object2;\n    }\n    if (\"items\" in schema) {\n        return schema.items.map(getDefaults);\n    }\n    return getDefault(schema);\n}\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n    if (\"entries\" in schema) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await getDefaultsAsync(value2)\n            ])));\n    }\n    if (\"items\" in schema) {\n        return Promise.all(schema.items.map(getDefaultsAsync));\n    }\n    return getDefault(schema);\n}\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n    if (\"entries\" in schema) {\n        const object2 = {};\n        for(const key in schema.entries){\n            object2[key] = getFallbacks(schema.entries[key]);\n        }\n        return object2;\n    }\n    if (\"items\" in schema) {\n        return schema.items.map(getFallbacks);\n    }\n    return getFallback(schema);\n}\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n    if (\"entries\" in schema) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await getFallbacksAsync(value2)\n            ])));\n    }\n    if (\"items\" in schema) {\n        return Promise.all(schema.items.map(getFallbacksAsync));\n    }\n    return getFallback(schema);\n}\n// src/methods/is/is.ts\nfunction is(schema, input) {\n    return !schema._run({\n        typed: false,\n        value: input\n    }, {\n        abortEarly: true\n    }).issues;\n}\n// src/schemas/any/any.ts\nfunction any() {\n    return {\n        kind: \"schema\",\n        type: \"any\",\n        reference: any,\n        expects: \"any\",\n        async: false,\n        _run (dataset) {\n            dataset.typed = true;\n            return dataset;\n        }\n    };\n}\n// src/schemas/array/array.ts\nfunction array(item, message) {\n    return {\n        kind: \"schema\",\n        type: \"array\",\n        reference: array,\n        expects: \"Array\",\n        async: false,\n        item,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < input.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.item._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n    return {\n        kind: \"schema\",\n        type: \"array\",\n        reference: arrayAsync,\n        expects: \"Array\",\n        async: true,\n        item,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(input.map((value2)=>this.item._run({\n                        typed: false,\n                        value: value2\n                    }, config2)));\n                for(let key = 0; key < itemDatasets.length; key++){\n                    const itemDataset = itemDatasets[key];\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: input[key]\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n    return {\n        kind: \"schema\",\n        type: \"bigint\",\n        reference: bigint,\n        expects: \"bigint\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"bigint\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n    return {\n        kind: \"schema\",\n        type: \"blob\",\n        reference: blob,\n        expects: \"Blob\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof Blob) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n    return {\n        kind: \"schema\",\n        type: \"boolean\",\n        reference: boolean,\n        expects: \"boolean\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"boolean\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n    return {\n        kind: \"schema\",\n        type: \"custom\",\n        reference: custom,\n        expects: \"unknown\",\n        async: false,\n        check: check2,\n        message,\n        _run (dataset, config2) {\n            if (this.check(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n    return {\n        kind: \"schema\",\n        type: \"custom\",\n        reference: customAsync,\n        expects: \"unknown\",\n        async: true,\n        check: check2,\n        message,\n        async _run (dataset, config2) {\n            if (await this.check(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/date/date.ts\nfunction date(message) {\n    return {\n        kind: \"schema\",\n        type: \"date\",\n        reference: date,\n        expects: \"Date\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof Date) {\n                if (!isNaN(dataset.value)) {\n                    dataset.typed = true;\n                } else {\n                    _addIssue(this, \"type\", dataset, config2, {\n                        received: '\"Invalid Date\"'\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n    const options = Object.entries(enum__).filter(([key])=>isNaN(+key)).map(([, value2])=>value2);\n    return {\n        kind: \"schema\",\n        type: \"enum\",\n        reference: enum_,\n        expects: options.map(_stringify).join(\" | \") || \"never\",\n        async: false,\n        enum: enum__,\n        options,\n        message,\n        _run (dataset, config2) {\n            if (this.options.includes(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/file/file.ts\nfunction file(message) {\n    return {\n        kind: \"schema\",\n        type: \"file\",\n        reference: file,\n        expects: \"File\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof File) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/function/function.ts\nfunction function_(message) {\n    return {\n        kind: \"schema\",\n        type: \"function\",\n        reference: function_,\n        expects: \"Function\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"function\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n    return {\n        kind: \"schema\",\n        type: \"instance\",\n        reference: instance,\n        expects: class_.name,\n        async: false,\n        class: class_,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof this.class) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n    if (typeof value1 === typeof value2) {\n        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n            return {\n                value: value1\n            };\n        }\n        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n            for(const key in value2){\n                if (key in value1) {\n                    const dataset = _merge(value1[key], value2[key]);\n                    if (dataset.issue) {\n                        return dataset;\n                    }\n                    value1[key] = dataset.value;\n                } else {\n                    value1[key] = value2[key];\n                }\n            }\n            return {\n                value: value1\n            };\n        }\n        if (Array.isArray(value1) && Array.isArray(value2)) {\n            if (value1.length === value2.length) {\n                for(let index = 0; index < value1.length; index++){\n                    const dataset = _merge(value1[index], value2[index]);\n                    if (dataset.issue) {\n                        return dataset;\n                    }\n                    value1[index] = dataset.value;\n                }\n                return {\n                    value: value1\n                };\n            }\n        }\n    }\n    return {\n        issue: true\n    };\n}\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"intersect\",\n        reference: intersect,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" & \") || \"never\",\n        async: false,\n        options,\n        message,\n        _run (dataset, config2) {\n            if (this.options.length) {\n                const input = dataset.value;\n                let outputs;\n                dataset.typed = true;\n                for (const schema of this.options){\n                    const optionDataset = schema._run({\n                        typed: false,\n                        value: input\n                    }, config2);\n                    if (optionDataset.issues) {\n                        if (dataset.issues) {\n                            dataset.issues.push(...optionDataset.issues);\n                        } else {\n                            dataset.issues = optionDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!optionDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (dataset.typed) {\n                        if (outputs) {\n                            outputs.push(optionDataset.value);\n                        } else {\n                            outputs = [\n                                optionDataset.value\n                            ];\n                        }\n                    }\n                }\n                if (dataset.typed) {\n                    dataset.value = outputs[0];\n                    for(let index = 1; index < outputs.length; index++){\n                        const mergeDataset = _merge(dataset.value, outputs[index]);\n                        if (mergeDataset.issue) {\n                            _addIssue(this, \"type\", dataset, config2, {\n                                received: \"unknown\"\n                            });\n                            break;\n                        }\n                        dataset.value = mergeDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"intersect\",\n        reference: intersectAsync,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" & \") || \"never\",\n        async: true,\n        options,\n        message,\n        async _run (dataset, config2) {\n            if (this.options.length) {\n                const input = dataset.value;\n                let outputs;\n                dataset.typed = true;\n                const optionDatasets = await Promise.all(this.options.map((schema)=>schema._run({\n                        typed: false,\n                        value: input\n                    }, config2)));\n                for (const optionDataset of optionDatasets){\n                    if (optionDataset.issues) {\n                        if (dataset.issues) {\n                            dataset.issues.push(...optionDataset.issues);\n                        } else {\n                            dataset.issues = optionDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!optionDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (dataset.typed) {\n                        if (outputs) {\n                            outputs.push(optionDataset.value);\n                        } else {\n                            outputs = [\n                                optionDataset.value\n                            ];\n                        }\n                    }\n                }\n                if (dataset.typed) {\n                    dataset.value = outputs[0];\n                    for(let index = 1; index < outputs.length; index++){\n                        const mergeDataset = _merge(dataset.value, outputs[index]);\n                        if (mergeDataset.issue) {\n                            _addIssue(this, \"type\", dataset, config2, {\n                                received: \"unknown\"\n                            });\n                            break;\n                        }\n                        dataset.value = mergeDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n    return {\n        kind: \"schema\",\n        type: \"lazy\",\n        reference: lazy,\n        expects: \"unknown\",\n        async: false,\n        getter,\n        _run (dataset, config2) {\n            return this.getter(dataset.value)._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n    return {\n        kind: \"schema\",\n        type: \"lazy\",\n        reference: lazyAsync,\n        expects: \"unknown\",\n        async: true,\n        getter,\n        async _run (dataset, config2) {\n            return (await this.getter(dataset.value))._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n    return {\n        kind: \"schema\",\n        type: \"literal\",\n        reference: literal,\n        expects: _stringify(literal_),\n        async: false,\n        literal: literal_,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === this.literal) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_object\",\n        reference: looseObject,\n        expects: \"Object\",\n        async: false,\n        entries,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            dataset.value[key] = input[key];\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_object\",\n        reference: looseObjectAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await schema._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            dataset.value[key] = input[key];\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_tuple\",\n        reference: looseTuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        dataset.value.push(input[key]);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_tuple\",\n        reference: looseTupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        dataset.value.push(input[key]);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"map\",\n        reference: map,\n        expects: \"Map\",\n        async: false,\n        key,\n        value: value2,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Map) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Map();\n                for (const [inputKey, inputValue] of input){\n                    const keyDataset = this.key._run({\n                        typed: false,\n                        value: inputKey\n                    }, config2);\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"key\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    const valueDataset = this.value._run({\n                        typed: false,\n                        value: inputValue\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"value\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.set(keyDataset.value, valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"map\",\n        reference: mapAsync,\n        expects: \"Map\",\n        async: true,\n        key,\n        value: value2,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Map) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Map();\n                const datasets = await Promise.all([\n                    ...input\n                ].map(([inputKey, inputValue])=>Promise.all([\n                        inputKey,\n                        inputValue,\n                        this.key._run({\n                            typed: false,\n                            value: inputKey\n                        }, config2),\n                        this.value._run({\n                            typed: false,\n                            value: inputValue\n                        }, config2)\n                    ])));\n                for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets){\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"key\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"value\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.set(keyDataset.value, valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n    return {\n        kind: \"schema\",\n        type: \"nan\",\n        reference: nan,\n        expects: \"NaN\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (Number.isNaN(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/never/never.ts\nfunction never(message) {\n    return {\n        kind: \"schema\",\n        type: \"never\",\n        reference: never,\n        expects: \"never\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            _addIssue(this, \"type\", dataset, config2);\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullable\",\n        reference: nonNullable,\n        expects: \"!null\",\n        async: false,\n        wrapped,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === null) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullable\",\n        reference: nonNullableAsync,\n        expects: \"!null\",\n        async: true,\n        wrapped,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.value === null) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullish\",\n        reference: nonNullish,\n        expects: \"!null & !undefined\",\n        async: false,\n        wrapped,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullish\",\n        reference: nonNullishAsync,\n        expects: \"!null & !undefined\",\n        async: true,\n        wrapped,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_optional\",\n        reference: nonOptional,\n        expects: \"!undefined\",\n        async: false,\n        wrapped,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_optional\",\n        reference: nonOptionalAsync,\n        expects: \"!undefined\",\n        async: true,\n        wrapped,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/null/null.ts\nfunction null_(message) {\n    return {\n        kind: \"schema\",\n        type: \"null\",\n        reference: null_,\n        expects: \"null\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === null) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullable\",\n        reference: nullable,\n        expects: `${wrapped.expects} | null`,\n        async: false,\n        wrapped,\n        _run (dataset, config2) {\n            if (dataset.value === null) {\n                if (\"default\" in this) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullable\",\n        reference: nullableAsync,\n        expects: `${wrapped.expects} | null`,\n        async: true,\n        wrapped,\n        async _run (dataset, config2) {\n            if (dataset.value === null) {\n                if (\"default\" in this) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullish\",\n        reference: nullish,\n        expects: `${wrapped.expects} | null | undefined`,\n        async: false,\n        wrapped,\n        _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null || dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullish\",\n        reference: nullishAsync,\n        expects: `${wrapped.expects} | null | undefined`,\n        async: true,\n        wrapped,\n        async _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null || dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/number/number.ts\nfunction number(message) {\n    return {\n        kind: \"schema\",\n        type: \"number\",\n        reference: number,\n        expects: \"number\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"object\",\n        reference: object,\n        expects: \"Object\",\n        async: false,\n        entries,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"object\",\n        reference: objectAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await schema._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"object_with_rest\",\n        reference: objectWithRest,\n        expects: \"Object\",\n        async: false,\n        entries,\n        rest,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            const value2 = input[key];\n                            const valueDataset = this.rest._run({\n                                typed: false,\n                                value: value2\n                            }, config2);\n                            if (valueDataset.issues) {\n                                const pathItem = {\n                                    type: \"object\",\n                                    origin: \"value\",\n                                    input,\n                                    key,\n                                    value: value2\n                                };\n                                for (const issue of valueDataset.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    dataset.issues?.push(issue);\n                                }\n                                if (!dataset.issues) {\n                                    dataset.issues = valueDataset.issues;\n                                }\n                                if (config2.abortEarly) {\n                                    dataset.typed = false;\n                                    break;\n                                }\n                            }\n                            if (!valueDataset.typed) {\n                                dataset.typed = false;\n                            }\n                            dataset.value[key] = valueDataset.value;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"object_with_rest\",\n        reference: objectWithRestAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        rest,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const [normalDatasets, restDatasets] = await Promise.all([\n                    // Parse schema of each normal entry\n                    Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                        const value2 = input[key];\n                        return [\n                            key,\n                            value2,\n                            await schema._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ];\n                    })),\n                    // Parse other entries with rest schema\n                    Promise.all(Object.entries(input).filter(([key])=>_isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value2])=>[\n                            key,\n                            value2,\n                            await this.rest._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ]))\n                ]);\n                for (const [key, value2, valueDataset] of normalDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for (const [key, value2, valueDataset] of restDatasets){\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"optional\",\n        reference: optional,\n        expects: `${wrapped.expects} | undefined`,\n        async: false,\n        wrapped,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"optional\",\n        reference: optionalAsync,\n        expects: `${wrapped.expects} | undefined`,\n        async: true,\n        wrapped,\n        async _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"picklist\",\n        reference: picklist,\n        expects: options.map(_stringify).join(\" | \") || \"never\",\n        async: false,\n        options,\n        message,\n        _run (dataset, config2) {\n            if (this.options.includes(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n    return {\n        kind: \"schema\",\n        type: \"promise\",\n        reference: promise,\n        expects: \"Promise\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof Promise) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"record\",\n        reference: record,\n        expects: \"Object\",\n        async: false,\n        key,\n        value: value2,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const entryKey in input){\n                    if (_isValidObjectKey(input, entryKey)) {\n                        const entryValue = input[entryKey];\n                        const keyDataset = this.key._run({\n                            typed: false,\n                            value: entryKey\n                        }, config2);\n                        if (keyDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"key\",\n                                input,\n                                key: entryKey,\n                                value: entryValue\n                            };\n                            for (const issue of keyDataset.issues){\n                                issue.path = [\n                                    pathItem\n                                ];\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = keyDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        const valueDataset = this.value._run({\n                            typed: false,\n                            value: entryValue\n                        }, config2);\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key: entryKey,\n                                value: entryValue\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!keyDataset.typed || !valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        if (keyDataset.typed) {\n                            dataset.value[keyDataset.value] = valueDataset.value;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"record\",\n        reference: recordAsync,\n        expects: \"Object\",\n        async: true,\n        key,\n        value: value2,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const datasets = await Promise.all(Object.entries(input).filter(([key2])=>_isValidObjectKey(input, key2)).map(([entryKey, entryValue])=>Promise.all([\n                        entryKey,\n                        entryValue,\n                        this.key._run({\n                            typed: false,\n                            value: entryKey\n                        }, config2),\n                        this.value._run({\n                            typed: false,\n                            value: entryValue\n                        }, config2)\n                    ])));\n                for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets){\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"key\",\n                            input,\n                            key: entryKey,\n                            value: entryValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            issue.path = [\n                                pathItem\n                            ];\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: entryKey,\n                            value: entryValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (keyDataset.typed) {\n                        dataset.value[keyDataset.value] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"set\",\n        reference: set,\n        expects: \"Set\",\n        async: false,\n        value: value2,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Set) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Set();\n                for (const inputValue of input){\n                    const valueDataset = this.value._run({\n                        typed: false,\n                        value: inputValue\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"set\",\n                            origin: \"value\",\n                            input,\n                            key: null,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.add(valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"set\",\n        reference: setAsync,\n        expects: \"Set\",\n        async: true,\n        value: value2,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Set) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Set();\n                const valueDatasets = await Promise.all([\n                    ...input\n                ].map(async (inputValue)=>[\n                        inputValue,\n                        await this.value._run({\n                            typed: false,\n                            value: inputValue\n                        }, config2)\n                    ]));\n                for (const [inputValue, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"set\",\n                            origin: \"value\",\n                            input,\n                            key: null,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.add(valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_object\",\n        reference: strictObject,\n        expects: \"Object\",\n        async: false,\n        entries,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (!(key in this.entries)) {\n                            const value2 = input[key];\n                            _addIssue(this, \"type\", dataset, config2, {\n                                input: value2,\n                                expected: \"never\",\n                                path: [\n                                    {\n                                        type: \"object\",\n                                        origin: \"value\",\n                                        input,\n                                        key,\n                                        value: value2\n                                    }\n                                ]\n                            });\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_object\",\n        reference: strictObjectAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await schema._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (!(key in this.entries)) {\n                            const value2 = input[key];\n                            _addIssue(this, \"type\", dataset, config2, {\n                                input: value2,\n                                expected: \"never\",\n                                path: [\n                                    {\n                                        type: \"object\",\n                                        origin: \"value\",\n                                        input,\n                                        key,\n                                        value: value2\n                                    }\n                                ]\n                            });\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_tuple\",\n        reference: strictTuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n                    const value2 = input[items.length];\n                    _addIssue(this, \"type\", dataset, config2, {\n                        input: value2,\n                        expected: \"never\",\n                        path: [\n                            {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key: this.items.length,\n                                value: value2\n                            }\n                        ]\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_tuple\",\n        reference: strictTupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n                    const value2 = input[items.length];\n                    _addIssue(this, \"type\", dataset, config2, {\n                        input: value2,\n                        expected: \"never\",\n                        path: [\n                            {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key: this.items.length,\n                                value: value2\n                            }\n                        ]\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/string/string.ts\nfunction string(message) {\n    return {\n        kind: \"schema\",\n        type: \"string\",\n        reference: string,\n        expects: \"string\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"string\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n    return {\n        kind: \"schema\",\n        type: \"symbol\",\n        reference: symbol,\n        expects: \"symbol\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"symbol\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple\",\n        reference: tuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple\",\n        reference: tupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple_with_rest\",\n        reference: tupleWithRest,\n        expects: \"Array\",\n        async: false,\n        items,\n        rest,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        const value2 = input[key];\n                        const itemDataset = this.rest._run({\n                            typed: false,\n                            value: value2\n                        }, config2);\n                        if (itemDataset.issues) {\n                            const pathItem = {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of itemDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = itemDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!itemDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value.push(itemDataset.value);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple_with_rest\",\n        reference: tupleWithRestAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        rest,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const [normalDatasets, restDatasets] = await Promise.all([\n                    // Parse schema of each normal item\n                    Promise.all(this.items.map(async (item, key)=>{\n                        const value2 = input[key];\n                        return [\n                            key,\n                            value2,\n                            await item._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ];\n                    })),\n                    // Parse other items with rest schema\n                    Promise.all(input.slice(this.items.length).map(async (value2, key)=>{\n                        return [\n                            key + this.items.length,\n                            value2,\n                            await this.rest._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ];\n                    }))\n                ]);\n                for (const [key, value2, itemDataset] of normalDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for (const [key, value2, itemDataset] of restDatasets){\n                        if (itemDataset.issues) {\n                            const pathItem = {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of itemDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = itemDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!itemDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value.push(itemDataset.value);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n    return {\n        kind: \"schema\",\n        type: \"undefined\",\n        reference: undefined_,\n        expects: \"undefined\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n    let issues;\n    if (datasets) {\n        for (const dataset of datasets){\n            if (issues) {\n                issues.push(...dataset.issues);\n            } else {\n                issues = dataset.issues;\n            }\n        }\n    }\n    return issues;\n}\n// src/schemas/union/union.ts\nfunction union(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"union\",\n        reference: union,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" | \") || \"never\",\n        async: false,\n        options,\n        message,\n        _run (dataset, config2) {\n            let validDataset;\n            let typedDatasets;\n            let untypedDatasets;\n            for (const schema of this.options){\n                const optionDataset = schema._run({\n                    typed: false,\n                    value: dataset.value\n                }, config2);\n                if (optionDataset.typed) {\n                    if (optionDataset.issues) {\n                        if (typedDatasets) {\n                            typedDatasets.push(optionDataset);\n                        } else {\n                            typedDatasets = [\n                                optionDataset\n                            ];\n                        }\n                    } else {\n                        validDataset = optionDataset;\n                        break;\n                    }\n                } else {\n                    if (untypedDatasets) {\n                        untypedDatasets.push(optionDataset);\n                    } else {\n                        untypedDatasets = [\n                            optionDataset\n                        ];\n                    }\n                }\n            }\n            if (validDataset) {\n                return validDataset;\n            }\n            if (typedDatasets) {\n                if (typedDatasets.length === 1) {\n                    return typedDatasets[0];\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(typedDatasets)\n                });\n                dataset.typed = true;\n            } else if (untypedDatasets?.length === 1) {\n                return untypedDatasets[0];\n            } else {\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(untypedDatasets)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"union\",\n        reference: unionAsync,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" | \") || \"never\",\n        async: true,\n        options,\n        message,\n        async _run (dataset, config2) {\n            let validDataset;\n            let typedDatasets;\n            let untypedDatasets;\n            for (const schema of this.options){\n                const optionDataset = await schema._run({\n                    typed: false,\n                    value: dataset.value\n                }, config2);\n                if (optionDataset.typed) {\n                    if (optionDataset.issues) {\n                        if (typedDatasets) {\n                            typedDatasets.push(optionDataset);\n                        } else {\n                            typedDatasets = [\n                                optionDataset\n                            ];\n                        }\n                    } else {\n                        validDataset = optionDataset;\n                        break;\n                    }\n                } else {\n                    if (untypedDatasets) {\n                        untypedDatasets.push(optionDataset);\n                    } else {\n                        untypedDatasets = [\n                            optionDataset\n                        ];\n                    }\n                }\n            }\n            if (validDataset) {\n                return validDataset;\n            }\n            if (typedDatasets) {\n                if (typedDatasets.length === 1) {\n                    return typedDatasets[0];\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(typedDatasets)\n                });\n                dataset.typed = true;\n            } else if (untypedDatasets?.length === 1) {\n                return untypedDatasets[0];\n            } else {\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(untypedDatasets)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n    return {\n        kind: \"schema\",\n        type: \"unknown\",\n        reference: unknown,\n        expects: \"unknown\",\n        async: false,\n        _run (dataset) {\n            dataset.typed = true;\n            return dataset;\n        }\n    };\n}\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n    for (const schema of options){\n        if (schema.type === \"variant\") {\n            _discriminators(key, schema.options, set2);\n        } else {\n            set2.add(schema.entries[key].expects);\n        }\n    }\n    return set2;\n}\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n    let expectedDiscriminators;\n    return {\n        kind: \"schema\",\n        type: \"variant\",\n        reference: variant,\n        expects: \"Object\",\n        async: false,\n        key,\n        options,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                const discriminator = input[this.key];\n                if (this.key in input) {\n                    let outputDataset;\n                    for (const schema of this.options){\n                        if (schema.type === \"variant\" || !schema.entries[this.key]._run({\n                            typed: false,\n                            value: discriminator\n                        }, config2).issues) {\n                            const optionDataset = schema._run({\n                                typed: false,\n                                value: input\n                            }, config2);\n                            if (!optionDataset.issues) {\n                                return optionDataset;\n                            }\n                            if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                                outputDataset = optionDataset;\n                            }\n                        }\n                    }\n                    if (outputDataset) {\n                        return outputDataset;\n                    }\n                }\n                if (!expectedDiscriminators) {\n                    expectedDiscriminators = [\n                        ..._discriminators(this.key, this.options)\n                    ].join(\" | \") || \"never\";\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    input: discriminator,\n                    expected: expectedDiscriminators,\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: this.key,\n                            value: discriminator\n                        }\n                    ]\n                });\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n    let expectedDiscriminators;\n    return {\n        kind: \"schema\",\n        type: \"variant\",\n        reference: variantAsync,\n        expects: \"Object\",\n        async: true,\n        key,\n        options,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                const discriminator = input[this.key];\n                if (this.key in input) {\n                    let outputDataset;\n                    for (const schema of this.options){\n                        if (schema.type === \"variant\" || !(await schema.entries[this.key]._run({\n                            typed: false,\n                            value: discriminator\n                        }, config2)).issues) {\n                            const optionDataset = await schema._run({\n                                typed: false,\n                                value: input\n                            }, config2);\n                            if (!optionDataset.issues) {\n                                return optionDataset;\n                            }\n                            if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                                outputDataset = optionDataset;\n                            }\n                        }\n                    }\n                    if (outputDataset) {\n                        return outputDataset;\n                    }\n                }\n                if (!expectedDiscriminators) {\n                    expectedDiscriminators = [\n                        ..._discriminators(this.key, this.options)\n                    ].join(\" | \") || \"never\";\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    input: discriminator,\n                    expected: expectedDiscriminators,\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: this.key,\n                            value: discriminator\n                        }\n                    ]\n                });\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/void/void.ts\nfunction void_(message) {\n    return {\n        kind: \"schema\",\n        type: \"void\",\n        reference: void_,\n        expects: \"void\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n    return picklist(Object.keys(schema.entries), message);\n}\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n    const entries = {\n        ...schema.entries\n    };\n    for (const key of keys){\n        delete entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n    const dataset = schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    if (dataset.issues) {\n        throw new ValiError(dataset.issues);\n    }\n    return dataset.value;\n}\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n    const dataset = await schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    if (dataset.issues) {\n        throw new ValiError(dataset.issues);\n    }\n    return dataset.value;\n}\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n    const func = (input)=>parse(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n    const func = (input)=>parseAsync(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n    const entries = {};\n    for (const key of keys){\n        entries[key] = schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n    return {\n        ...pipe2[0],\n        pipe: pipe2,\n        _run (dataset, config2) {\n            for(let index = 0; index < pipe2.length; index++){\n                if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n                    dataset.typed = false;\n                    break;\n                }\n                if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n                    dataset = pipe2[index]._run(dataset, config2);\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n    return {\n        ...pipe2[0],\n        pipe: pipe2,\n        async: true,\n        async _run (dataset, config2) {\n            for(let index = 0; index < pipe2.length; index++){\n                if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n                    dataset.typed = false;\n                    break;\n                }\n                if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n                    dataset = await pipe2[index]._run(dataset, config2);\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n    const keys = Array.isArray(arg2) ? arg2 : void 0;\n    const message = Array.isArray(arg2) ? arg3 : arg2;\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n    const keys = Array.isArray(arg2) ? arg2 : void 0;\n    const message = Array.isArray(arg2) ? arg3 : arg2;\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n    const dataset = schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    return {\n        typed: dataset.typed,\n        success: !dataset.issues,\n        output: dataset.value,\n        issues: dataset.issues\n    };\n}\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n    const dataset = await schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    return {\n        typed: dataset.typed,\n        success: !dataset.issues,\n        output: dataset.value,\n        issues: dataset.issues\n    };\n}\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n    const func = (input)=>safeParse(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n    const func = (input)=>safeParseAsync(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n    return schema.wrapped;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtDQUFrQztBQUNsQyxTQUFTQTtJQUNQLE9BQU87UUFDTEMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFdBQVdIO1FBQ1hJLE9BQU87UUFDUCxNQUFNQyxNQUFLQyxPQUFPO1lBQ2hCQSxRQUFRQyxLQUFLLEdBQUcsTUFBTUQsUUFBUUMsS0FBSztZQUNuQyxPQUFPRDtRQUNUO0lBQ0Y7QUFDRjtBQUVBLGVBQWU7QUFDZixJQUFJRSxZQUFZO0FBQ2hCLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsZ0JBQWdCO0FBQ3BCLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxvQkFBb0I7QUFDeEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsYUFDRiw0RUFBNEU7QUFDNUU7QUFFRixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLFdBQVc7QUFDZixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsc0JBQXNCO0FBQzFCLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyx3QkFBd0I7QUFDNUIsSUFBSUMsc0JBQXNCO0FBQzFCLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGFBQWE7QUFDakIsSUFB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QU87UUFBT25FLE9BQU9rRDtJQUFNLEdBQzdCdkIsZ0JBQWdCRDtJQUVsQixPQUFPO1FBQ0x5QyxPQUFPcEUsUUFBUW9FLEtBQUs7UUFDcEJvVSxTQUFTLENBQUN4WSxRQUFRa0UsTUFBTTtRQUN4QjRJLFFBQVE5TSxRQUFRQyxLQUFLO1FBQ3JCaUUsUUFBUWxFLFFBQVFrRSxNQUFNO0lBQ3hCO0FBQ0Y7QUFFQSx1Q0FBdUM7QUFDdkMsU0FBU3dVLFdBQVdyVCxNQUFNLEVBQUUxRCxPQUFPO0lBQ2pDLE1BQU1nVyxPQUFPLENBQUN4VSxRQUFVb1YsVUFBVWxULFFBQVFsQyxPQUFPeEI7SUFDakRnVyxLQUFLdFMsTUFBTSxHQUFHQTtJQUNkc1MsS0FBS2xMLE1BQU0sR0FBRzlLO0lBQ2QsT0FBT2dXO0FBQ1Q7QUFFQSw0Q0FBNEM7QUFDNUMsU0FBU2dCLGdCQUFnQnRULE1BQU0sRUFBRTFELE9BQU87SUFDdEMsTUFBTWdXLE9BQU8sQ0FBQ3hVLFFBQVVzVixlQUFlcFQsUUFBUWxDLE9BQU94QjtJQUN0RGdXLEtBQUt0UyxNQUFNLEdBQUdBO0lBQ2RzUyxLQUFLbEwsTUFBTSxHQUFHOUs7SUFDZCxPQUFPZ1c7QUFDVDtBQUVBLCtCQUErQjtBQUMvQixTQUFTaUIsT0FBT3ZULE1BQU07SUFDcEIsT0FBT0EsT0FBT3VPLE9BQU87QUFDdkI7QUF5T0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdWlzb3VuZC1hZ2VudC8uL25vZGVfbW9kdWxlcy92YWxpYm90L2Rpc3QvaW5kZXguanM/NDhkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYWN0aW9ucy9hd2FpdC9hd2FpdEFzeW5jLnRzXG5mdW5jdGlvbiBhd2FpdEFzeW5jKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImF3YWl0XCIsXG4gICAgcmVmZXJlbmNlOiBhd2FpdEFzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGRhdGFzZXQudmFsdWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9yZWdleC50c1xudmFyIEJJQ19SRUdFWCA9IC9eW0EtWl17Nn0oPyEwMClbQS1aXFxkXXsyfSg/OltBLVpcXGRdezN9KT8kL3U7XG52YXIgQ1VJRDJfUkVHRVggPSAvXlthLXpdW1xcZGEtel0qJC91O1xudmFyIERFQ0lNQUxfUkVHRVggPSAvXlxcZCskL3U7XG52YXIgRU1BSUxfUkVHRVggPSAvXltcXHcrLV0rKD86XFwuW1xcdystXSspKkBbXFxkYS16XSsoPzpbLi1dW1xcZGEtel0rKSpcXC5bYS16XXsyLH0kL2l1O1xudmFyIEVNT0pJX1JFR0VYID0gL15bXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY31cXHB7RW1vamlfQ29tcG9uZW50fV0rJC91O1xudmFyIEhFWEFERUNJTUFMX1JFR0VYID0gL14oPzowaHwweCk/W1xcZGEtZl0rJC9pdTtcbnZhciBIRVhfQ09MT1JfUkVHRVggPSAvXiMoPzpbXFxkYS1mXXszLDR9fFtcXGRhLWZdezZ9fFtcXGRhLWZdezh9KSQvaXU7XG52YXIgSU1FSV9SRUdFWCA9IC9eXFxkezE1fSR8XlxcZHsyfS1cXGR7Nn0tXFxkezZ9LVxcZCQvdTtcbnZhciBJUFY0X1JFR0VYID0gKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVkb3MtZGV0ZWN0b3Ivbm8tdW5zYWZlLXJlZ2V4IC0tIGZhbHNlIHBvc2l0aXZlXG4gIC9eKD86KD86WzEtOV18MVxcZHwyWzAtNF0pP1xcZHwyNVswLTVdKSg/OlxcLig/Oig/OlsxLTldfDFcXGR8MlswLTRdKT9cXGR8MjVbMC01XSkpezN9JC91XG4pO1xudmFyIElQVjZfUkVHRVggPSAvXig/Oig/OltcXGRhLWZdezEsNH06KXs3fVtcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsN306fCg/OltcXGRhLWZdezEsNH06KXsxLDZ9OltcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsNX0oPzo6W1xcZGEtZl17MSw0fSl7MSwyfXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDN9fCg/OltcXGRhLWZdezEsNH06KXsxLDN9KD86OltcXGRhLWZdezEsNH0pezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsMn0oPzo6W1xcZGEtZl17MSw0fSl7MSw1fXxbXFxkYS1mXXsxLDR9Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDZ9fDooPzooPzo6W1xcZGEtZl17MSw0fSl7MSw3fXw6KXxmZTgwOig/OjpbXFxkYS1mXXswLDR9KXswLDR9JVtcXGRhLXpdK3w6Oig/OmZ7NH0oPzo6MHsxLDR9KT86KT8oPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fTooPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKSkkL2l1O1xudmFyIElQX1JFR0VYID0gL14oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKD86XFwuKD86KD86WzEtOV18MVxcZHwyWzAtNF0pP1xcZHwyNVswLTVdKSl7M30kfF4oPzooPzpbXFxkYS1mXXsxLDR9Oil7N31bXFxkYS1mXXsxLDR9fCg/OltcXGRhLWZdezEsNH06KXsxLDd9OnwoPzpbXFxkYS1mXXsxLDR9Oil7MSw2fTpbXFxkYS1mXXsxLDR9fCg/OltcXGRhLWZdezEsNH06KXsxLDV9KD86OltcXGRhLWZdezEsNH0pezEsMn18KD86W1xcZGEtZl17MSw0fTopezEsNH0oPzo6W1xcZGEtZl17MSw0fSl7MSwzfXwoPzpbXFxkYS1mXXsxLDR9Oil7MSwzfSg/OjpbXFxkYS1mXXsxLDR9KXsxLDR9fCg/OltcXGRhLWZdezEsNH06KXsxLDJ9KD86OltcXGRhLWZdezEsNH0pezEsNX18W1xcZGEtZl17MSw0fTooPzo6W1xcZGEtZl17MSw0fSl7MSw2fXw6KD86KD86OltcXGRhLWZdezEsNH0pezEsN318Oil8ZmU4MDooPzo6W1xcZGEtZl17MCw0fSl7MCw0fSVbXFxkYS16XSt8OjooPzpmezR9KD86OjB7MSw0fSk/Oik/KD86KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZClcXC4pezN9KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZCl8KD86W1xcZGEtZl17MSw0fTopezEsNH06KD86KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZClcXC4pezN9KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZCkpJC9pdTtcbnZhciBJU09fREFURV9SRUdFWCA9IC9eXFxkezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKSQvdTtcbnZhciBJU09fREFURV9USU1FX1JFR0VYID0gL15cXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86WzEyXVxcZHwwWzEtOV18M1swMV0pVCg/OjBcXGR8MVxcZHwyWzAtM10pOlswLTVdXFxkJC91O1xudmFyIElTT19USU1FX1JFR0VYID0gL14oPzowXFxkfDFcXGR8MlswLTNdKTpbMC01XVxcZCQvdTtcbnZhciBJU09fVElNRV9TRUNPTkRfUkVHRVggPSAvXig/OjBcXGR8MVxcZHwyWzAtM10pKD86OlswLTVdXFxkKXsyfSQvdTtcbnZhciBJU09fVElNRVNUQU1QX1JFR0VYID0gL15cXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86WzEyXVxcZHwwWzEtOV18M1swMV0pVCg/OjBcXGR8MVxcZHwyWzAtM10pKD86OlswLTVdXFxkKXsyfSg/OlxcLlxcZHsxLDl9KT8oPzpafFsrLV0oPzowXFxkfDFcXGR8MlswLTNdKSg/Ojo/WzAtNV1cXGQpPykkL3U7XG52YXIgSVNPX1dFRUtfUkVHRVggPSAvXlxcZHs0fS1XKD86MFsxLTldfFsxLTRdXFxkfDVbMC0zXSkkL3U7XG52YXIgTUFDNDhfUkVHRVggPSAvXig/OltcXGRhLWZdezJ9Oil7NX1bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezJ9LSl7NX1bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezR9XFwuKXsyfVtcXGRhLWZdezR9JC9pdTtcbnZhciBNQUM2NF9SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs3fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs3fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezN9W1xcZGEtZl17NH0kfF4oPzpbXFxkYS1mXXs0fTopezN9W1xcZGEtZl17NH0kL2l1O1xudmFyIE1BQ19SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezJ9W1xcZGEtZl17NH0kfF4oPzpbXFxkYS1mXXsyfTopezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7M31bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezR9Oil7M31bXFxkYS1mXXs0fSQvaXU7XG52YXIgT0NUQUxfUkVHRVggPSAvXig/OjBvKT9bMC03XSskL2l1O1xudmFyIFVMSURfUkVHRVggPSAvXltcXGRhLWhqa21ucC10di16XXsyNn0kL2l1O1xudmFyIFVVSURfUkVHRVggPSAvXltcXGRhLWZdezh9KD86LVtcXGRhLWZdezR9KXszfS1bXFxkYS1mXXsxMn0kL2l1O1xuXG4vLyBzcmMvc3RvcmFnZXMvZ2xvYmFsQ29uZmlnL2dsb2JhbENvbmZpZy50c1xudmFyIHN0b3JlO1xuZnVuY3Rpb24gc2V0R2xvYmFsQ29uZmlnKGNvbmZpZzIpIHtcbiAgc3RvcmUgPSB7IC4uLnN0b3JlLCAuLi5jb25maWcyIH07XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxDb25maWcoY29uZmlnMikge1xuICByZXR1cm4ge1xuICAgIGxhbmc6IGNvbmZpZzI/LmxhbmcgPz8gc3RvcmU/LmxhbmcsXG4gICAgbWVzc2FnZTogY29uZmlnMj8ubWVzc2FnZSxcbiAgICBhYm9ydEVhcmx5OiBjb25maWcyPy5hYm9ydEVhcmx5ID8/IHN0b3JlPy5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBjb25maWcyPy5hYm9ydFBpcGVFYXJseSA/PyBzdG9yZT8uYWJvcnRQaXBlRWFybHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUdsb2JhbENvbmZpZygpIHtcbiAgc3RvcmUgPSB2b2lkIDA7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9nbG9iYWxNZXNzYWdlL2dsb2JhbE1lc3NhZ2UudHNcbnZhciBzdG9yZTI7XG5mdW5jdGlvbiBzZXRHbG9iYWxNZXNzYWdlKG1lc3NhZ2UsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTIpIHN0b3JlMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0b3JlMi5zZXQobGFuZywgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxNZXNzYWdlKGxhbmcpIHtcbiAgcmV0dXJuIHN0b3JlMj8uZ2V0KGxhbmcpO1xufVxuZnVuY3Rpb24gZGVsZXRlR2xvYmFsTWVzc2FnZShsYW5nKSB7XG4gIHN0b3JlMj8uZGVsZXRlKGxhbmcpO1xufVxuXG4vLyBzcmMvc3RvcmFnZXMvc2NoZW1hTWVzc2FnZS9zY2hlbWFNZXNzYWdlLnRzXG52YXIgc3RvcmUzO1xuZnVuY3Rpb24gc2V0U2NoZW1hTWVzc2FnZShtZXNzYWdlLCBsYW5nKSB7XG4gIGlmICghc3RvcmUzKSBzdG9yZTMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdG9yZTMuc2V0KGxhbmcsIG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hTWVzc2FnZShsYW5nKSB7XG4gIHJldHVybiBzdG9yZTM/LmdldChsYW5nKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVNjaGVtYU1lc3NhZ2UobGFuZykge1xuICBzdG9yZTM/LmRlbGV0ZShsYW5nKTtcbn1cblxuLy8gc3JjL3N0b3JhZ2VzL3NwZWNpZmljTWVzc2FnZS9zcGVjaWZpY01lc3NhZ2UudHNcbnZhciBzdG9yZTQ7XG5mdW5jdGlvbiBzZXRTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBtZXNzYWdlLCBsYW5nKSB7XG4gIGlmICghc3RvcmU0KSBzdG9yZTQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoIXN0b3JlNC5nZXQocmVmZXJlbmNlKSkgc3RvcmU0LnNldChyZWZlcmVuY2UsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBzdG9yZTQuZ2V0KHJlZmVyZW5jZSkuc2V0KGxhbmcsIG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lmaWNNZXNzYWdlKHJlZmVyZW5jZSwgbGFuZykge1xuICByZXR1cm4gc3RvcmU0Py5nZXQocmVmZXJlbmNlKT8uZ2V0KGxhbmcpO1xufVxuZnVuY3Rpb24gZGVsZXRlU3BlY2lmaWNNZXNzYWdlKHJlZmVyZW5jZSwgbGFuZykge1xuICBzdG9yZTQ/LmdldChyZWZlcmVuY2UpPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy91dGlscy9fc3RyaW5naWZ5L19zdHJpbmdpZnkudHNcbmZ1bmN0aW9uIF9zdHJpbmdpZnkoaW5wdXQpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHtpbnB1dH1cImA7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBgJHtpbnB1dH1gO1xuICB9XG4gIGlmICh0eXBlID09PSBcIm9iamVjdFwiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAoaW5wdXQgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KT8uY29uc3RydWN0b3I/Lm5hbWUpID8/IFwibnVsbFwiO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvX2FkZElzc3VlL19hZGRJc3N1ZS50c1xuZnVuY3Rpb24gX2FkZElzc3VlKGNvbnRleHQsIGxhYmVsLCBkYXRhc2V0LCBjb25maWcyLCBvdGhlcikge1xuICBjb25zdCBpbnB1dCA9IG90aGVyICYmIFwiaW5wdXRcIiBpbiBvdGhlciA/IG90aGVyLmlucHV0IDogZGF0YXNldC52YWx1ZTtcbiAgY29uc3QgZXhwZWN0ZWQgPSBvdGhlcj8uZXhwZWN0ZWQgPz8gY29udGV4dC5leHBlY3RzID8/IG51bGw7XG4gIGNvbnN0IHJlY2VpdmVkID0gb3RoZXI/LnJlY2VpdmVkID8/IF9zdHJpbmdpZnkoaW5wdXQpO1xuICBjb25zdCBpc3N1ZSA9IHtcbiAgICBraW5kOiBjb250ZXh0LmtpbmQsXG4gICAgdHlwZTogY29udGV4dC50eXBlLFxuICAgIGlucHV0LFxuICAgIGV4cGVjdGVkLFxuICAgIHJlY2VpdmVkLFxuICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bGFiZWx9OiAke2V4cGVjdGVkID8gYEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGJ1dCByYCA6IFwiUlwifWVjZWl2ZWQgJHtyZWNlaXZlZH1gLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXF1aXJlbWVudDogY29udGV4dC5yZXF1aXJlbWVudCxcbiAgICBwYXRoOiBvdGhlcj8ucGF0aCxcbiAgICBpc3N1ZXM6IG90aGVyPy5pc3N1ZXMsXG4gICAgbGFuZzogY29uZmlnMi5sYW5nLFxuICAgIGFib3J0RWFybHk6IGNvbmZpZzIuYWJvcnRFYXJseSxcbiAgICBhYm9ydFBpcGVFYXJseTogY29uZmlnMi5hYm9ydFBpcGVFYXJseVxuICB9O1xuICBjb25zdCBpc1NjaGVtYSA9IGNvbnRleHQua2luZCA9PT0gXCJzY2hlbWFcIjtcbiAgY29uc3QgbWVzc2FnZSA9IG90aGVyPy5tZXNzYWdlID8/IC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgY29udGV4dC5tZXNzYWdlID8/IGdldFNwZWNpZmljTWVzc2FnZShjb250ZXh0LnJlZmVyZW5jZSwgaXNzdWUubGFuZykgPz8gKGlzU2NoZW1hID8gZ2V0U2NoZW1hTWVzc2FnZShpc3N1ZS5sYW5nKSA6IG51bGwpID8/IGNvbmZpZzIubWVzc2FnZSA/PyBnZXRHbG9iYWxNZXNzYWdlKGlzc3VlLmxhbmcpO1xuICBpZiAobWVzc2FnZSkge1xuICAgIGlzc3VlLm1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZShpc3N1ZSkgOiBtZXNzYWdlO1xuICB9XG4gIGlmIChpc1NjaGVtYSkge1xuICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICBkYXRhc2V0Lmlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhc2V0Lmlzc3VlcyA9IFtpc3N1ZV07XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL19pc0x1aG5BbGdvL19pc0x1aG5BbGdvLnRzXG52YXIgTk9OX0RJR0lUX1JFR0VYID0gL1xcRC9ndTtcbmZ1bmN0aW9uIF9pc0x1aG5BbGdvKGlucHV0KSB7XG4gIGNvbnN0IG51bWJlcjIgPSBpbnB1dC5yZXBsYWNlKE5PTl9ESUdJVF9SRUdFWCwgXCJcIik7XG4gIGxldCBsZW5ndGgyID0gbnVtYmVyMi5sZW5ndGg7XG4gIGxldCBiaXQgPSAxO1xuICBsZXQgc3VtID0gMDtcbiAgd2hpbGUgKGxlbmd0aDIpIHtcbiAgICBjb25zdCB2YWx1ZTIgPSArbnVtYmVyMlstLWxlbmd0aDJdO1xuICAgIGJpdCBePSAxO1xuICAgIHN1bSArPSBiaXQgPyBbMCwgMiwgNCwgNiwgOCwgMSwgMywgNSwgNywgOV1bdmFsdWUyXSA6IHZhbHVlMjtcbiAgfVxuICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG59XG5cbi8vIHNyYy91dGlscy9faXNWYWxpZE9iamVjdEtleS9faXNWYWxpZE9iamVjdEtleS50c1xuZnVuY3Rpb24gX2lzVmFsaWRPYmplY3RLZXkob2JqZWN0Miwga2V5KSB7XG4gIHJldHVybiBPYmplY3QuaGFzT3duKG9iamVjdDIsIGtleSkgJiYga2V5ICE9PSBcIl9fcHJvdG9fX1wiICYmIGtleSAhPT0gXCJwcm90b3R5cGVcIiAmJiBrZXkgIT09IFwiY29uc3RydWN0b3JcIjtcbn1cblxuLy8gc3JjL3V0aWxzL2VudHJpZXNGcm9tTGlzdC9lbnRyaWVzRnJvbUxpc3QudHNcbmZ1bmN0aW9uIGVudHJpZXNGcm9tTGlzdChsaXN0LCBzY2hlbWEpIHtcbiAgY29uc3QgZW50cmllcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBsaXN0KSB7XG4gICAgZW50cmllc1trZXldID0gc2NoZW1hO1xuICB9XG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG4vLyBzcmMvdXRpbHMvZ2V0RG90UGF0aC9nZXREb3RQYXRoLnRzXG5mdW5jdGlvbiBnZXREb3RQYXRoKGlzc3VlKSB7XG4gIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgbGV0IGtleSA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGlzc3VlLnBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbS5rZXkgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGl0ZW0ua2V5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBrZXkgKz0gYC4ke2l0ZW0ua2V5fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ICs9IGl0ZW0ua2V5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL3V0aWxzL2lzT2ZLaW5kL2lzT2ZLaW5kLnRzXG5mdW5jdGlvbiBpc09mS2luZChraW5kLCBvYmplY3QyKSB7XG4gIHJldHVybiBvYmplY3QyLmtpbmQgPT09IGtpbmQ7XG59XG5cbi8vIHNyYy91dGlscy9pc09mVHlwZS9pc09mVHlwZS50c1xuZnVuY3Rpb24gaXNPZlR5cGUodHlwZSwgb2JqZWN0Mikge1xuICByZXR1cm4gb2JqZWN0Mi50eXBlID09PSB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNWYWxpRXJyb3IvaXNWYWxpRXJyb3IudHNcbmZ1bmN0aW9uIGlzVmFsaUVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIFZhbGlFcnJvcjtcbn1cblxuLy8gc3JjL3V0aWxzL1ZhbGlFcnJvci9WYWxpRXJyb3IudHNcbnZhciBWYWxpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIFRoZSBlcnJvciBpc3N1ZXMuXG4gICAqL1xuICBpc3N1ZXM7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgVmFsaWJvdCBlcnJvciB3aXRoIHVzZWZ1bCBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlzc3VlcyBUaGUgZXJyb3IgaXNzdWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoaXNzdWVzWzBdLm1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiVmFsaUVycm9yXCI7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9hY3Rpb25zL2JpYy9iaWMudHNcbmZ1bmN0aW9uIGJpYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJiaWNcIixcbiAgICByZWZlcmVuY2U6IGJpYyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogQklDX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkJJQ1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvYnJhbmQvYnJhbmQudHNcbmZ1bmN0aW9uIGJyYW5kKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJicmFuZFwiLFxuICAgIHJlZmVyZW5jZTogYnJhbmQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG5hbWUsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2J5dGVzL2J5dGVzLnRzXG5mdW5jdGlvbiBieXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IGJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGFzZXQudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aDIgIT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJieXRlc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7bGVuZ3RoMn1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvY2hlY2svY2hlY2sudHNcbmZ1bmN0aW9uIGNoZWNrKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjaGVja1wiLFxuICAgIHJlZmVyZW5jZTogY2hlY2ssXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jaGVjay9jaGVja0FzeW5jLnRzXG5mdW5jdGlvbiBjaGVja0FzeW5jKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjaGVja1wiLFxuICAgIHJlZmVyZW5jZTogY2hlY2tBc3luYyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhYXdhaXQgdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvY2hlY2tJdGVtcy9jaGVja0l0ZW1zLnRzXG5mdW5jdGlvbiBjaGVja0l0ZW1zKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjaGVja19pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogY2hlY2tJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRhdGFzZXQudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGFzZXQudmFsdWVbaW5kZXhdO1xuICAgICAgICAgIGlmICghdGhpcy5yZXF1aXJlbWVudChpdGVtLCBpbmRleCwgZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIml0ZW1cIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICBpbnB1dDogaXRlbSxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGRhdGFzZXQudmFsdWUsXG4gICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jcmVkaXRDYXJkL2NyZWRpdENhcmQudHNcbnZhciBDUkVESVRfQ0FSRF9SRUdFWCA9IC9eKD86XFxkezE0LDE5fXxcXGR7NH0oPzogXFxkezMsNn0pezIsNH18XFxkezR9KD86LVxcZHszLDZ9KXsyLDR9KSQvdTtcbnZhciBTQU5JVElaRV9SRUdFWCA9IC9bLSBdL2d1O1xudmFyIFBST1ZJREVSX1JFR0VYX0xJU1QgPSBbXG4gIC8vIEFtZXJpY2FuIEV4cHJlc3NcbiAgL14zWzQ3XVxcZHsxM30kL3UsXG4gIC8vIERpbmVycyBDbHViXG4gIC9eMyg/OjBbMC01XXxbNjhdXFxkKVxcZHsxMSwxM30kL3UsXG4gIC8vIERpc2NvdmVyXG4gIC9eNig/OjAxMXw1XFxkezJ9KVxcZHsxMiwxNX0kL3UsXG4gIC8vIEpDQlxuICAvXig/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9JC91LFxuICAvLyBNYXN0ZXJjYXJkXG4gIC9eNVsxLTVdXFxkezJ9fCg/OjIyMlxcZHwyMlszLTldXFxkfDJbMy02XVxcZHsyfXwyN1swMV1cXGR8MjcyMClcXGR7MTJ9JC91LFxuICAvLyBVbmlvblBheVxuICAvXig/OjZbMjddXFxkezE0LDE3fXw4MVxcZHsxNCwxN30pJC91LFxuICAvLyBWaXNhXG4gIC9eNFxcZHsxMn0oPzpcXGR7Myw2fSk/JC91XG5dO1xuZnVuY3Rpb24gY3JlZGl0Q2FyZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjcmVkaXRfY2FyZFwiLFxuICAgIHJlZmVyZW5jZTogY3JlZGl0Q2FyZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudChpbnB1dCkge1xuICAgICAgbGV0IHNhbml0aXplZDtcbiAgICAgIHJldHVybiBDUkVESVRfQ0FSRF9SRUdFWC50ZXN0KGlucHV0KSAmJiAvLyBSZW1vdmUgYW55IGh5cGhlbnMgYW5kIGJsYW5rc1xuICAgICAgKHNhbml0aXplZCA9IGlucHV0LnJlcGxhY2UoU0FOSVRJWkVfUkVHRVgsIFwiXCIpKSAmJiAvLyBDaGVjayBpZiBpdCBtYXRjaGVzIGEgcHJvdmlkZXJcbiAgICAgIFBST1ZJREVSX1JFR0VYX0xJU1Quc29tZSgocmVnZXgyKSA9PiByZWdleDIudGVzdChzYW5pdGl6ZWQpKSAmJiAvLyBDaGVjayBpZiBwYXNzZXMgbHVobiBhbGdvcml0aG1cbiAgICAgIF9pc0x1aG5BbGdvKHNhbml0aXplZCk7XG4gICAgfSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiY3JlZGl0IGNhcmRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2N1aWQyL2N1aWQyLnRzXG5mdW5jdGlvbiBjdWlkMihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjdWlkMlwiLFxuICAgIHJlZmVyZW5jZTogY3VpZDIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IENVSUQyX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkN1aWQyXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9kZWNpbWFsL2RlY2ltYWwudHNcbmZ1bmN0aW9uIGRlY2ltYWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZGVjaW1hbFwiLFxuICAgIHJlZmVyZW5jZTogZGVjaW1hbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogREVDSU1BTF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJkZWNpbWFsXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9lbWFpbC9lbWFpbC50c1xuZnVuY3Rpb24gZW1haWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZW1haWxcIixcbiAgICByZWZlcmVuY2U6IGVtYWlsLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50OiBFTUFJTF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJlbWFpbFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZW1vamkvZW1vamkudHNcbmZ1bmN0aW9uIGVtb2ppKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImVtb2ppXCIsXG4gICAgcmVmZXJlbmNlOiBlbW9qaSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogRU1PSklfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW1vamlcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2VtcHR5L2VtcHR5LnRzXG5mdW5jdGlvbiBlbXB0eShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJlbXB0eVwiLFxuICAgIHJlZmVyZW5jZTogZW1wdHksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IFwiMFwiLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5sZW5ndGh9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZW5kc1dpdGgvZW5kc1dpdGgudHNcbmZ1bmN0aW9uIGVuZHNXaXRoKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJlbmRzX3dpdGhcIixcbiAgICByZWZlcmVuY2U6IGVuZHNXaXRoLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgXCIke3JlcXVpcmVtZW50fVwiYCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuZW5kc1dpdGgodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW5kXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYFwiJHtkYXRhc2V0LnZhbHVlLnNsaWNlKC10aGlzLnJlcXVpcmVtZW50Lmxlbmd0aCl9XCJgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ldmVyeUl0ZW0vZXZlcnlJdGVtLnRzXG5mdW5jdGlvbiBldmVyeUl0ZW0ocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImV2ZXJ5X2l0ZW1cIixcbiAgICByZWZlcmVuY2U6IGV2ZXJ5SXRlbSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuZXZlcnkodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZXhjbHVkZXMvZXhjbHVkZXMudHNcbmZ1bmN0aW9uIGV4Y2x1ZGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIGNvbnN0IHJlY2VpdmVkID0gX3N0cmluZ2lmeShyZXF1aXJlbWVudCk7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJleGNsdWRlc1wiLFxuICAgIHJlZmVyZW5jZTogZXhjbHVkZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAhJHtyZWNlaXZlZH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmluY2x1ZGVzKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImNvbnRlbnRcIiwgZGF0YXNldCwgY29uZmlnMiwgeyByZWNlaXZlZCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZmlsdGVySXRlbXMvZmlsdGVySXRlbXMudHNcbmZ1bmN0aW9uIGZpbHRlckl0ZW1zKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImZpbHRlcl9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogZmlsdGVySXRlbXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLmZpbHRlcih0aGlzLm9wZXJhdGlvbik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2ZpbmRJdGVtL2ZpbmRJdGVtLnRzXG5mdW5jdGlvbiBmaW5kSXRlbShvcGVyYXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJmaW5kX2l0ZW1cIixcbiAgICByZWZlcmVuY2U6IGZpbmRJdGVtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcGVyYXRpb24sXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS5maW5kKHRoaXMub3BlcmF0aW9uKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZmluaXRlL2Zpbml0ZS50c1xuZnVuY3Rpb24gZmluaXRlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImZpbml0ZVwiLFxuICAgIHJlZmVyZW5jZTogZmluaXRlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBOdW1iZXIuaXNGaW5pdGUsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImZpbml0ZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaGFzaC9oYXNoLnRzXG52YXIgSEFTSF9MRU5HVEhTID0ge1xuICBtZDQ6IDMyLFxuICBtZDU6IDMyLFxuICBzaGExOiA0MCxcbiAgc2hhMjU2OiA2NCxcbiAgc2hhMzg0OiA5NixcbiAgc2hhNTEyOiAxMjgsXG4gIHJpcGVtZDEyODogMzIsXG4gIHJpcGVtZDE2MDogNDAsXG4gIHRpZ2VyMTI4OiAzMixcbiAgdGlnZXIxNjA6IDQwLFxuICB0aWdlcjE5MjogNDgsXG4gIGNyYzMyOiA4LFxuICBjcmMzMmI6IDgsXG4gIGFkbGVyMzI6IDhcbn07XG5mdW5jdGlvbiBoYXNoKHR5cGVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJoYXNoXCIsXG4gICAgcmVmZXJlbmNlOiBoYXNoLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50OiBSZWdFeHAoXG4gICAgICB0eXBlcy5tYXAoKHR5cGUpID0+IGBeW2EtZjAtOV17JHtIQVNIX0xFTkdUSFNbdHlwZV19fSRgKS5qb2luKFwifFwiKSxcbiAgICAgIFwiaXVcIlxuICAgICksXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaGFzaFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaGV4YWRlY2ltYWwvaGV4YWRlY2ltYWwudHNcbmZ1bmN0aW9uIGhleGFkZWNpbWFsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImhleGFkZWNpbWFsXCIsXG4gICAgcmVmZXJlbmNlOiBoZXhhZGVjaW1hbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSEVYQURFQ0lNQUxfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaGV4YWRlY2ltYWxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2hleENvbG9yL2hleENvbG9yLnRzXG5mdW5jdGlvbiBoZXhDb2xvcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJoZXhfY29sb3JcIixcbiAgICByZWZlcmVuY2U6IGhleENvbG9yLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBIRVhfQ09MT1JfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaGV4IGNvbG9yXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pbWVpL2ltZWkudHNcbmZ1bmN0aW9uIGltZWkobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaW1laVwiLFxuICAgIHJlZmVyZW5jZTogaW1laSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudChpbnB1dCkge1xuICAgICAgcmV0dXJuIElNRUlfUkVHRVgudGVzdChpbnB1dCkgJiYgX2lzTHVobkFsZ28oaW5wdXQpO1xuICAgIH0sXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIklNRUlcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2luY2x1ZGVzL2luY2x1ZGVzLnRzXG5mdW5jdGlvbiBpbmNsdWRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICBjb25zdCBleHBlY3RzID0gX3N0cmluZ2lmeShyZXF1aXJlbWVudCk7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpbmNsdWRlc1wiLFxuICAgIHJlZmVyZW5jZTogaW5jbHVkZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHMsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICFkYXRhc2V0LnZhbHVlLmluY2x1ZGVzKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImNvbnRlbnRcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgISR7ZXhwZWN0c31gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pbnRlZ2VyL2ludGVnZXIudHNcbmZ1bmN0aW9uIGludGVnZXIobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgIHJlZmVyZW5jZTogaW50ZWdlcixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTnVtYmVyLmlzSW50ZWdlcixcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW50ZWdlclwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXAvaXAudHNcbmZ1bmN0aW9uIGlwKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlwXCIsXG4gICAgcmVmZXJlbmNlOiBpcCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVBfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiSVBcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lwdjQvaXB2NC50c1xuZnVuY3Rpb24gaXB2NChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpcHY0XCIsXG4gICAgcmVmZXJlbmNlOiBpcHY0LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJUFY0X1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIklQdjRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lwdjYvaXB2Ni50c1xuZnVuY3Rpb24gaXB2NihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpcHY2XCIsXG4gICAgcmVmZXJlbmNlOiBpcHY2LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJUFY2X1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIklQdjZcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb0RhdGUvaXNvRGF0ZS50c1xuZnVuY3Rpb24gaXNvRGF0ZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fZGF0ZVwiLFxuICAgIHJlZmVyZW5jZTogaXNvRGF0ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVNPX0RBVEVfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZGF0ZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXNvRGF0ZVRpbWUvaXNvRGF0ZVRpbWUudHNcbmZ1bmN0aW9uIGlzb0RhdGVUaW1lKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb19kYXRlX3RpbWVcIixcbiAgICByZWZlcmVuY2U6IGlzb0RhdGVUaW1lLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fREFURV9USU1FX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImRhdGUtdGltZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXNvVGltZS9pc29UaW1lLnRzXG5mdW5jdGlvbiBpc29UaW1lKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb190aW1lXCIsXG4gICAgcmVmZXJlbmNlOiBpc29UaW1lLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRV9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0aW1lXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29UaW1lU2Vjb25kL2lzb1RpbWVTZWNvbmQudHNcbmZ1bmN0aW9uIGlzb1RpbWVTZWNvbmQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXNvX3RpbWVfc2Vjb25kXCIsXG4gICAgcmVmZXJlbmNlOiBpc29UaW1lU2Vjb25kLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRV9TRUNPTkRfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidGltZS1zZWNvbmRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb1RpbWVzdGFtcC9pc29UaW1lc3RhbXAudHNcbmZ1bmN0aW9uIGlzb1RpbWVzdGFtcChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fdGltZXN0YW1wXCIsXG4gICAgcmVmZXJlbmNlOiBpc29UaW1lc3RhbXAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19USU1FU1RBTVBfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidGltZXN0YW1wXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29XZWVrL2lzb1dlZWsudHNcbmZ1bmN0aW9uIGlzb1dlZWsobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXNvX3dlZWtcIixcbiAgICByZWZlcmVuY2U6IGlzb1dlZWssXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19XRUVLX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIndlZWtcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2xlbmd0aC9sZW5ndGgudHNcbmZ1bmN0aW9uIGxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibGVuZ3RoXCIsXG4gICAgcmVmZXJlbmNlOiBsZW5ndGgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoICE9PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImxlbmd0aFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUubGVuZ3RofWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21hYy9tYWMudHNcbmZ1bmN0aW9uIG1hYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYWNcIixcbiAgICByZWZlcmVuY2U6IG1hYyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTUFDX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIk1BQ1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWFjNDgvbWFjNDgudHNcbmZ1bmN0aW9uIG1hYzQ4KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1hYzQ4XCIsXG4gICAgcmVmZXJlbmNlOiBtYWM0OCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTUFDNDhfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiNDgtYml0IE1BQ1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWFjNjQvbWFjNjQudHNcbmZ1bmN0aW9uIG1hYzY0KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1hYzY0XCIsXG4gICAgcmVmZXJlbmNlOiBtYWM2NCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTUFDNjRfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiNjQtYml0IE1BQ1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWFwSXRlbXMvbWFwSXRlbXMudHNcbmZ1bmN0aW9uIG1hcEl0ZW1zKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcIm1hcF9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogbWFwSXRlbXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLm1hcCh0aGlzLm9wZXJhdGlvbik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heEJ5dGVzL21heEJ5dGVzLnRzXG5mdW5jdGlvbiBtYXhCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWF4X2J5dGVzXCIsXG4gICAgcmVmZXJlbmNlOiBtYXhCeXRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGFzZXQudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aDIgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiYnl0ZXNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2xlbmd0aDJ9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heExlbmd0aC9tYXhMZW5ndGgudHNcbmZ1bmN0aW9uIG1heExlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWF4X2xlbmd0aFwiLFxuICAgIHJlZmVyZW5jZTogbWF4TGVuZ3RoLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoID4gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXhTaXplL21heFNpemUudHNcbmZ1bmN0aW9uIG1heFNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1heF9zaXplXCIsXG4gICAgcmVmZXJlbmNlOiBtYXhTaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuc2l6ZSA+IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2l6ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUuc2l6ZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXhWYWx1ZS9tYXhWYWx1ZS50c1xuZnVuY3Rpb24gbWF4VmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1heF92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogbWF4VmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlID4gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbWVUeXBlL21pbWVUeXBlLnRzXG5mdW5jdGlvbiBtaW1lVHlwZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWltZV90eXBlXCIsXG4gICAgcmVmZXJlbmNlOiBtaW1lVHlwZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogcmVxdWlyZW1lbnQubWFwKChvcHRpb24pID0+IGBcIiR7b3B0aW9ufVwiYCkuam9pbihcIiB8IFwiKSB8fCBcIm5ldmVyXCIsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LmluY2x1ZGVzKGRhdGFzZXQudmFsdWUudHlwZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiTUlNRSB0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYFwiJHtkYXRhc2V0LnZhbHVlLnR5cGV9XCJgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW5CeXRlcy9taW5CeXRlcy50c1xuZnVuY3Rpb24gbWluQnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl9ieXRlc1wiLFxuICAgIHJlZmVyZW5jZTogbWluQnl0ZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoMiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhc2V0LnZhbHVlKS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGgyIDwgdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImJ5dGVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtsZW5ndGgyfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW5MZW5ndGgvbWluTGVuZ3RoLnRzXG5mdW5jdGlvbiBtaW5MZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl9sZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IG1pbkxlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYD49JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5sZW5ndGh9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWluU2l6ZS9taW5TaXplLnRzXG5mdW5jdGlvbiBtaW5TaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtaW5fc2l6ZVwiLFxuICAgIHJlZmVyZW5jZTogbWluU2l6ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYD49JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgPCB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInNpemVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLnNpemV9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWluVmFsdWUvbWluVmFsdWUudHNcbmZ1bmN0aW9uIG1pblZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtaW5fdmFsdWVcIixcbiAgICByZWZlcmVuY2U6IG1pblZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50IGluc3RhbmNlb2YgRGF0ZSA/IHJlcXVpcmVtZW50LnRvSlNPTigpIDogX3N0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZSA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tdWx0aXBsZU9mL211bHRpcGxlT2YudHNcbmZ1bmN0aW9uIG11bHRpcGxlT2YocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm11bHRpcGxlX29mXCIsXG4gICAgcmVmZXJlbmNlOiBtdWx0aXBsZU9mLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZSAlIHRoaXMucmVxdWlyZW1lbnQgIT09IDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibXVsdGlwbGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vbkVtcHR5L25vbkVtcHR5LnRzXG5mdW5jdGlvbiBub25FbXB0eShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJub25fZW1wdHlcIixcbiAgICByZWZlcmVuY2U6IG5vbkVtcHR5LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBcIiEwXCIsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImxlbmd0aFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IFwiMFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3JtYWxpemUvbm9ybWFsaXplLnRzXG5mdW5jdGlvbiBub3JtYWxpemUoZm9ybSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcIm5vcm1hbGl6ZVwiLFxuICAgIHJlZmVyZW5jZTogbm9ybWFsaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBmb3JtLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUubm9ybWFsaXplKHRoaXMuZm9ybSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdEJ5dGVzL25vdEJ5dGVzLnRzXG5mdW5jdGlvbiBub3RCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X2J5dGVzXCIsXG4gICAgcmVmZXJlbmNlOiBub3RCeXRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YXNldC52YWx1ZSkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoMiA9PT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImJ5dGVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtsZW5ndGgyfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3RMZW5ndGgvbm90TGVuZ3RoLnRzXG5mdW5jdGlvbiBub3RMZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF9sZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IG5vdExlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoID09PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImxlbmd0aFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUubGVuZ3RofWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdFNpemUvbm90U2l6ZS50c1xuZnVuY3Rpb24gbm90U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X3NpemVcIixcbiAgICByZWZlcmVuY2U6IG5vdFNpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAhJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2l6ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUuc2l6ZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3RWYWx1ZS9ub3RWYWx1ZS50c1xuZnVuY3Rpb24gbm90VmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogbm90VmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IHJlcXVpcmVtZW50IGluc3RhbmNlb2YgRGF0ZSA/IGAhJHtyZXF1aXJlbWVudC50b0pTT04oKX1gIDogYCEke19zdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIHRoaXMucmVxdWlyZW1lbnQgPD0gZGF0YXNldC52YWx1ZSAmJiB0aGlzLnJlcXVpcmVtZW50ID49IGRhdGFzZXQudmFsdWUpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9vY3RhbC9vY3RhbC50c1xuZnVuY3Rpb24gb2N0YWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwib2N0YWxcIixcbiAgICByZWZlcmVuY2U6IG9jdGFsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBPQ1RBTF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJvY3RhbFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcGFydGlhbENoZWNrL3V0aWxzL19pc1BhcnRpYWxseVR5cGVkL19pc1BhcnRpYWxseVR5cGVkLnRzXG5mdW5jdGlvbiBfaXNQYXJ0aWFsbHlUeXBlZChkYXRhc2V0LCBwYXRoTGlzdCkge1xuICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcbiAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gTWF0aC5taW4ocGF0aC5sZW5ndGgsIGlzc3VlLnBhdGg/Lmxlbmd0aCA/PyAwKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGJvdW5kOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHBhdGhbaW5kZXhdICE9PSBpc3N1ZS5wYXRoW2luZGV4XS5rZXkpIHtcbiAgICAgICAgICAgIHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvYWN0aW9ucy9wYXJ0aWFsQ2hlY2svcGFydGlhbENoZWNrLnRzXG5mdW5jdGlvbiBwYXJ0aWFsQ2hlY2socGF0aExpc3QsIHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJwYXJ0aWFsX2NoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiBwYXJ0aWFsQ2hlY2ssXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChfaXNQYXJ0aWFsbHlUeXBlZChkYXRhc2V0LCBwYXRoTGlzdCkgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3BhcnRpYWxDaGVjay9wYXJ0aWFsQ2hlY2tBc3luYy50c1xuZnVuY3Rpb24gcGFydGlhbENoZWNrQXN5bmMocGF0aExpc3QsIHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJwYXJ0aWFsX2NoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiBwYXJ0aWFsQ2hlY2tBc3luYyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoX2lzUGFydGlhbGx5VHlwZWQoZGF0YXNldCwgcGF0aExpc3QpICYmIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICFhd2FpdCB0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yYXdDaGVjay9yYXdDaGVjay50c1xuZnVuY3Rpb24gcmF3Q2hlY2soYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJyYXdfY2hlY2tcIixcbiAgICByZWZlcmVuY2U6IHJhd0NoZWNrLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgYWN0aW9uKHtcbiAgICAgICAgZGF0YXNldCxcbiAgICAgICAgY29uZmlnOiBjb25maWcyLFxuICAgICAgICBhZGRJc3N1ZTogKGluZm8pID0+IF9hZGRJc3N1ZSh0aGlzLCBpbmZvPy5sYWJlbCA/PyBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIsIGluZm8pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmF3Q2hlY2svcmF3Q2hlY2tBc3luYy50c1xuZnVuY3Rpb24gcmF3Q2hlY2tBc3luYyhhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInJhd19jaGVja1wiLFxuICAgIHJlZmVyZW5jZTogcmF3Q2hlY2tBc3luYyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgYXdhaXQgYWN0aW9uKHtcbiAgICAgICAgZGF0YXNldCxcbiAgICAgICAgY29uZmlnOiBjb25maWcyLFxuICAgICAgICBhZGRJc3N1ZTogKGluZm8pID0+IF9hZGRJc3N1ZSh0aGlzLCBpbmZvPy5sYWJlbCA/PyBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIsIGluZm8pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmF3VHJhbnNmb3JtL3Jhd1RyYW5zZm9ybS50c1xuZnVuY3Rpb24gcmF3VHJhbnNmb3JtKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJhd190cmFuc2Zvcm1cIixcbiAgICByZWZlcmVuY2U6IHJhd1RyYW5zZm9ybSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhY3Rpb24oe1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICAgIGFkZElzc3VlOiAoaW5mbykgPT4gX2FkZElzc3VlKHRoaXMsIGluZm8/LmxhYmVsID8/IFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMiwgaW5mbyksXG4gICAgICAgIE5FVkVSOiBudWxsXG4gICAgICB9KTtcbiAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gb3V0cHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yYXdUcmFuc2Zvcm0vcmF3VHJhbnNmb3JtQXN5bmMudHNcbmZ1bmN0aW9uIHJhd1RyYW5zZm9ybUFzeW5jKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJhd190cmFuc2Zvcm1cIixcbiAgICByZWZlcmVuY2U6IHJhd1RyYW5zZm9ybUFzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgYWN0aW9uKHtcbiAgICAgICAgZGF0YXNldCxcbiAgICAgICAgY29uZmlnOiBjb25maWcyLFxuICAgICAgICBhZGRJc3N1ZTogKGluZm8pID0+IF9hZGRJc3N1ZSh0aGlzLCBpbmZvPy5sYWJlbCA/PyBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIsIGluZm8pLFxuICAgICAgICBORVZFUjogbnVsbFxuICAgICAgfSk7XG4gICAgICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IG91dHB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmVhZG9ubHkvcmVhZG9ubHkudHNcbmZ1bmN0aW9uIHJlYWRvbmx5KCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJlYWRvbmx5XCIsXG4gICAgcmVmZXJlbmNlOiByZWFkb25seSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3JlZHVjZUl0ZW1zL3JlZHVjZUl0ZW1zLnRzXG5mdW5jdGlvbiByZWR1Y2VJdGVtcyhvcGVyYXRpb24sIGluaXRpYWwpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJyZWR1Y2VfaXRlbXNcIixcbiAgICByZWZlcmVuY2U6IHJlZHVjZUl0ZW1zLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcGVyYXRpb24sXG4gICAgaW5pdGlhbCxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnJlZHVjZSh0aGlzLm9wZXJhdGlvbiwgdGhpcy5pbml0aWFsKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmVnZXgvcmVnZXgudHNcbmZ1bmN0aW9uIHJlZ2V4KHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJyZWdleFwiLFxuICAgIHJlZmVyZW5jZTogcmVnZXgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZm9ybWF0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zYWZlSW50ZWdlci9zYWZlSW50ZWdlci50c1xuZnVuY3Rpb24gc2FmZUludGVnZXIobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwic2FmZV9pbnRlZ2VyXCIsXG4gICAgcmVmZXJlbmNlOiBzYWZlSW50ZWdlcixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTnVtYmVyLmlzU2FmZUludGVnZXIsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInNhZmUgaW50ZWdlclwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvc2l6ZS9zaXplLnRzXG5mdW5jdGlvbiBzaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzaXplXCIsXG4gICAgcmVmZXJlbmNlOiBzaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgIT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2l6ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUuc2l6ZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zb21lSXRlbS9zb21lSXRlbS50c1xuZnVuY3Rpb24gc29tZUl0ZW0ocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInNvbWVfaXRlbVwiLFxuICAgIHJlZmVyZW5jZTogc29tZUl0ZW0sXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICFkYXRhc2V0LnZhbHVlLnNvbWUodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvc29ydEl0ZW1zL3NvcnRJdGVtcy50c1xuZnVuY3Rpb24gc29ydEl0ZW1zKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInNvcnRfaXRlbXNcIixcbiAgICByZWZlcmVuY2U6IHNvcnRJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUuc29ydCh0aGlzLm9wZXJhdGlvbik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3N0YXJ0c1dpdGgvc3RhcnRzV2l0aC50c1xuZnVuY3Rpb24gc3RhcnRzV2l0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwic3RhcnRzX3dpdGhcIixcbiAgICByZWZlcmVuY2U6IHN0YXJ0c1dpdGgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGBcIiR7cmVxdWlyZW1lbnR9XCJgLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhZGF0YXNldC52YWx1ZS5zdGFydHNXaXRoKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInN0YXJ0XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYFwiJHtkYXRhc2V0LnZhbHVlLnNsaWNlKDAsIHRoaXMucmVxdWlyZW1lbnQubGVuZ3RoKX1cImBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RvTG93ZXJDYXNlL3RvTG93ZXJDYXNlLnRzXG5mdW5jdGlvbiB0b0xvd2VyQ2FzZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0b19sb3dlcl9jYXNlXCIsXG4gICAgcmVmZXJlbmNlOiB0b0xvd2VyQ2FzZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90b01heFZhbHVlL3RvTWF4VmFsdWUudHNcbmZ1bmN0aW9uIHRvTWF4VmFsdWUocmVxdWlyZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0b19tYXhfdmFsdWVcIixcbiAgICByZWZlcmVuY2U6IHRvTWF4VmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUgPiB0aGlzLnJlcXVpcmVtZW50ID8gdGhpcy5yZXF1aXJlbWVudCA6IGRhdGFzZXQudmFsdWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RvTWluVmFsdWUvdG9NaW5WYWx1ZS50c1xuZnVuY3Rpb24gdG9NaW5WYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX21pbl92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogdG9NaW5WYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZSA8IHRoaXMucmVxdWlyZW1lbnQgPyB0aGlzLnJlcXVpcmVtZW50IDogZGF0YXNldC52YWx1ZTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdG9VcHBlckNhc2UvdG9VcHBlckNhc2UudHNcbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX3VwcGVyX2Nhc2VcIixcbiAgICByZWZlcmVuY2U6IHRvVXBwZXJDYXNlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyYW5zZm9ybS90cmFuc2Zvcm0udHNcbmZ1bmN0aW9uIHRyYW5zZm9ybShvcGVyYXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0cmFuc2Zvcm1cIixcbiAgICByZWZlcmVuY2U6IHRyYW5zZm9ybSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IHRoaXMub3BlcmF0aW9uKGRhdGFzZXQudmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90cmFuc2Zvcm0vdHJhbnNmb3JtQXN5bmMudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybUFzeW5jKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRyYW5zZm9ybVwiLFxuICAgIHJlZmVyZW5jZTogdHJhbnNmb3JtQXN5bmMsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3BlcmF0aW9uLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IHRoaXMub3BlcmF0aW9uKGRhdGFzZXQudmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90cmltL3RyaW0udHNcbmZ1bmN0aW9uIHRyaW0oKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidHJpbVwiLFxuICAgIHJlZmVyZW5jZTogdHJpbSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50cmltKCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyaW1FbmQvdHJpbUVuZC50c1xuZnVuY3Rpb24gdHJpbUVuZCgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0cmltX2VuZFwiLFxuICAgIHJlZmVyZW5jZTogdHJpbUVuZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50cmltRW5kKCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyaW1TdGFydC90cmltU3RhcnQudHNcbmZ1bmN0aW9uIHRyaW1TdGFydCgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0cmltX3N0YXJ0XCIsXG4gICAgcmVmZXJlbmNlOiB0cmltU3RhcnQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUudHJpbVN0YXJ0KCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3VsaWQvdWxpZC50c1xuZnVuY3Rpb24gdWxpZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJ1bGlkXCIsXG4gICAgcmVmZXJlbmNlOiB1bGlkLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBVTElEX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIlVMSURcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3VybC91cmwudHNcbmZ1bmN0aW9uIHVybChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJ1cmxcIixcbiAgICByZWZlcmVuY2U6IHVybCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudChpbnB1dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFVSTChpbnB1dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJVUkxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3V1aWQvdXVpZC50c1xuZnVuY3Rpb24gdXVpZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJ1dWlkXCIsXG4gICAgcmVmZXJlbmNlOiB1dWlkLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBVVUlEX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIlVVSURcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3ZhbHVlL3ZhbHVlLnRzXG5mdW5jdGlvbiB2YWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICByZWZlcmVuY2U6IHZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiByZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IF9zdHJpbmdpZnkocmVxdWlyZW1lbnQpLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhKHRoaXMucmVxdWlyZW1lbnQgPD0gZGF0YXNldC52YWx1ZSAmJiB0aGlzLnJlcXVpcmVtZW50ID49IGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInZhbHVlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRhc2V0LnZhbHVlLnRvSlNPTigpIDogX3N0cmluZ2lmeShkYXRhc2V0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvY29uZmlnL2NvbmZpZy50c1xuZnVuY3Rpb24gY29uZmlnKHNjaGVtYSwgY29uZmlnMikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZ18pIHtcbiAgICAgIHJldHVybiBzY2hlbWEuX3J1bihkYXRhc2V0LCB7IC4uLmNvbmZpZ18sIC4uLmNvbmZpZzIgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFjay9nZXRGYWxsYmFjay50c1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2soc2NoZW1hLCBkYXRhc2V0LCBjb25maWcyKSB7XG4gIHJldHVybiB0eXBlb2Ygc2NoZW1hLmZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHNjaGVtYS5mYWxsYmFjayhkYXRhc2V0LCBjb25maWcyKVxuICApIDogKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBzY2hlbWEuZmFsbGJhY2tcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZmFsbGJhY2svZmFsbGJhY2sudHNcbmZ1bmN0aW9uIGZhbGxiYWNrKHNjaGVtYSwgZmFsbGJhY2syKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGZhbGxiYWNrOiBmYWxsYmFjazIsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBzY2hlbWEuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIHJldHVybiBkYXRhc2V0Lmlzc3VlcyA/IHsgdHlwZWQ6IHRydWUsIHZhbHVlOiBnZXRGYWxsYmFjayh0aGlzLCBkYXRhc2V0LCBjb25maWcyKSB9IDogZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZhbGxiYWNrL2ZhbGxiYWNrQXN5bmMudHNcbmZ1bmN0aW9uIGZhbGxiYWNrQXN5bmMoc2NoZW1hLCBmYWxsYmFjazIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZmFsbGJhY2s6IGZhbGxiYWNrMixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHNjaGVtYS5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQuaXNzdWVzID8gKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHsgdHlwZWQ6IHRydWUsIHZhbHVlOiBhd2FpdCBnZXRGYWxsYmFjayh0aGlzLCBkYXRhc2V0LCBjb25maWcyKSB9XG4gICAgICApIDogZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZsYXR0ZW4vZmxhdHRlbi50c1xuZnVuY3Rpb24gZmxhdHRlbihpc3N1ZXMpIHtcbiAgY29uc3QgZmxhdEVycm9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGlzc3VlIG9mIGlzc3Vlcykge1xuICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICBjb25zdCBkb3RQYXRoID0gZ2V0RG90UGF0aChpc3N1ZSk7XG4gICAgICBpZiAoZG90UGF0aCkge1xuICAgICAgICBpZiAoIWZsYXRFcnJvcnMubmVzdGVkKSB7XG4gICAgICAgICAgZmxhdEVycm9ycy5uZXN0ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhdEVycm9ycy5uZXN0ZWRbZG90UGF0aF0pIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtkb3RQYXRoXS5wdXNoKGlzc3VlLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXRFcnJvcnMubmVzdGVkW2RvdFBhdGhdID0gW2lzc3VlLm1lc3NhZ2VdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmxhdEVycm9ycy5vdGhlcikge1xuICAgICAgICAgIGZsYXRFcnJvcnMub3RoZXIucHVzaChpc3N1ZS5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLm90aGVyID0gW2lzc3VlLm1lc3NhZ2VdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmbGF0RXJyb3JzLnJvb3QpIHtcbiAgICAgICAgZmxhdEVycm9ycy5yb290LnB1c2goaXNzdWUubWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0RXJyb3JzLnJvb3QgPSBbaXNzdWUubWVzc2FnZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmbGF0RXJyb3JzO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mb3J3YXJkL2ZvcndhcmQudHNcbmZ1bmN0aW9uIGZvcndhcmQoYWN0aW9uLCBwYXRoS2V5cykge1xuICByZXR1cm4ge1xuICAgIC4uLmFjdGlvbixcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IHByZXZJc3N1ZXMgPSBkYXRhc2V0Lmlzc3VlcyAmJiBbLi4uZGF0YXNldC5pc3N1ZXNdO1xuICAgICAgYWN0aW9uLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgIGlmICghcHJldklzc3Vlcz8uaW5jbHVkZXMoaXNzdWUpKSB7XG4gICAgICAgICAgICBsZXQgcGF0aElucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhdGhLZXlzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhWYWx1ZSA9IHBhdGhJbnB1dFtrZXldO1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF0aElucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC5wdXNoKHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXBhdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhdGhJbnB1dCA9IHBhdGhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZm9yd2FyZC9mb3J3YXJkQXN5bmMudHNcbmZ1bmN0aW9uIGZvcndhcmRBc3luYyhhY3Rpb24sIHBhdGhLZXlzKSB7XG4gIHJldHVybiB7XG4gICAgLi4uYWN0aW9uLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgcHJldklzc3VlcyA9IGRhdGFzZXQuaXNzdWVzICYmIFsuLi5kYXRhc2V0Lmlzc3Vlc107XG4gICAgICBhd2FpdCBhY3Rpb24uX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgaWYgKCFwcmV2SXNzdWVzPy5pbmNsdWRlcyhpc3N1ZSkpIHtcbiAgICAgICAgICAgIGxldCBwYXRoSW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGF0aEtleXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aFZhbHVlID0gcGF0aElucHV0W2tleV07XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXRoSW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXRoVmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnB1c2gocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0L2dldERlZmF1bHQudHNcbmZ1bmN0aW9uIGdldERlZmF1bHQoc2NoZW1hLCBkYXRhc2V0LCBjb25maWcyKSB7XG4gIHJldHVybiB0eXBlb2Ygc2NoZW1hLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgc2NoZW1hLmRlZmF1bHQoZGF0YXNldCwgY29uZmlnMilcbiAgKSA6IChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgc2NoZW1hLmRlZmF1bHRcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RGVmYXVsdHMvZ2V0RGVmYXVsdHMudHNcbmZ1bmN0aW9uIGdldERlZmF1bHRzKHNjaGVtYSkge1xuICBpZiAoXCJlbnRyaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3Qgb2JqZWN0MiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5lbnRyaWVzKSB7XG4gICAgICBvYmplY3QyW2tleV0gPSBnZXREZWZhdWx0cyhzY2hlbWEuZW50cmllc1trZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDI7XG4gIH1cbiAgaWYgKFwiaXRlbXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcChnZXREZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGdldERlZmF1bHQoc2NoZW1hKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RGVmYXVsdHMvZ2V0RGVmYXVsdHNBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdHNBc3luYyhzY2hlbWEpIHtcbiAgaWYgKFwiZW50cmllc1wiIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBhd2FpdCBnZXREZWZhdWx0c0FzeW5jKHZhbHVlMilcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGlmIChcIml0ZW1zXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNjaGVtYS5pdGVtcy5tYXAoZ2V0RGVmYXVsdHNBc3luYykpO1xuICB9XG4gIHJldHVybiBnZXREZWZhdWx0KHNjaGVtYSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrcy9nZXRGYWxsYmFja3MudHNcbmZ1bmN0aW9uIGdldEZhbGxiYWNrcyhzY2hlbWEpIHtcbiAgaWYgKFwiZW50cmllc1wiIGluIHNjaGVtYSkge1xuICAgIGNvbnN0IG9iamVjdDIgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgICAgb2JqZWN0MltrZXldID0gZ2V0RmFsbGJhY2tzKHNjaGVtYS5lbnRyaWVzW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0MjtcbiAgfVxuICBpZiAoXCJpdGVtc1wiIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEuaXRlbXMubWFwKGdldEZhbGxiYWNrcyk7XG4gIH1cbiAgcmV0dXJuIGdldEZhbGxiYWNrKHNjaGVtYSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrcy9nZXRGYWxsYmFja3NBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmFsbGJhY2tzQXN5bmMoc2NoZW1hKSB7XG4gIGlmIChcImVudHJpZXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXdhaXQgZ2V0RmFsbGJhY2tzQXN5bmModmFsdWUyKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgaWYgKFwiaXRlbXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2NoZW1hLml0ZW1zLm1hcChnZXRGYWxsYmFja3NBc3luYykpO1xuICB9XG4gIHJldHVybiBnZXRGYWxsYmFjayhzY2hlbWEpO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9pcy9pcy50c1xuZnVuY3Rpb24gaXMoc2NoZW1hLCBpbnB1dCkge1xuICByZXR1cm4gIXNjaGVtYS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXQgfSwgeyBhYm9ydEVhcmx5OiB0cnVlIH0pLmlzc3Vlcztcbn1cblxuLy8gc3JjL3NjaGVtYXMvYW55L2FueS50c1xuZnVuY3Rpb24gYW55KCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJhbnlcIixcbiAgICByZWZlcmVuY2U6IGFueSxcbiAgICBleHBlY3RzOiBcImFueVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hcnJheS9hcnJheS50c1xuZnVuY3Rpb24gYXJyYXkoaXRlbSwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHJlZmVyZW5jZTogYXJyYXksXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW0uX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FycmF5L2FycmF5QXN5bmMudHNcbmZ1bmN0aW9uIGFycmF5QXN5bmMoaXRlbSwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHJlZmVyZW5jZTogYXJyYXlBc3luYyxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIGlucHV0Lm1hcCgodmFsdWUyKSA9PiB0aGlzLml0ZW0uX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgaXRlbURhdGFzZXRzLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IGl0ZW1EYXRhc2V0c1trZXldO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRba2V5XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2JpZ2ludC9iaWdpbnQudHNcbmZ1bmN0aW9uIGJpZ2ludChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgIHJlZmVyZW5jZTogYmlnaW50LFxuICAgIGV4cGVjdHM6IFwiYmlnaW50XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFzZXQudmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ibG9iL2Jsb2IudHNcbmZ1bmN0aW9uIGJsb2IobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJibG9iXCIsXG4gICAgcmVmZXJlbmNlOiBibG9iLFxuICAgIGV4cGVjdHM6IFwiQmxvYlwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYm9vbGVhbi9ib29sZWFuLnRzXG5mdW5jdGlvbiBib29sZWFuKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIHJlZmVyZW5jZTogYm9vbGVhbixcbiAgICBleHBlY3RzOiBcImJvb2xlYW5cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9jdXN0b20vY3VzdG9tLnRzXG5mdW5jdGlvbiBjdXN0b20oY2hlY2syLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgIHJlZmVyZW5jZTogY3VzdG9tLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBjaGVjazogY2hlY2syLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodGhpcy5jaGVjayhkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2N1c3RvbS9jdXN0b21Bc3luYy50c1xuZnVuY3Rpb24gY3VzdG9tQXN5bmMoY2hlY2syLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgIHJlZmVyZW5jZTogY3VzdG9tQXN5bmMsXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgY2hlY2s6IGNoZWNrMixcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGF3YWl0IHRoaXMuY2hlY2soZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9kYXRlL2RhdGUudHNcbmZ1bmN0aW9uIGRhdGUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJkYXRlXCIsXG4gICAgcmVmZXJlbmNlOiBkYXRlLFxuICAgIGV4cGVjdHM6IFwiRGF0ZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGlmICghaXNOYU4oZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiAnXCJJbnZhbGlkIERhdGVcIidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvZW51bS9lbnVtLnRzXG5mdW5jdGlvbiBlbnVtXyhlbnVtX18sIG1lc3NhZ2UpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5lbnRyaWVzKGVudW1fXykuZmlsdGVyKChba2V5XSkgPT4gaXNOYU4oK2tleSkpLm1hcCgoWywgdmFsdWUyXSkgPT4gdmFsdWUyKTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHJlZmVyZW5jZTogZW51bV8sXG4gICAgZXhwZWN0czogb3B0aW9ucy5tYXAoX3N0cmluZ2lmeSkuam9pbihcIiB8IFwiKSB8fCBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudW06IGVudW1fXyxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmluY2x1ZGVzKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvZmlsZS9maWxlLnRzXG5mdW5jdGlvbiBmaWxlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgIHJlZmVyZW5jZTogZmlsZSxcbiAgICBleHBlY3RzOiBcIkZpbGVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Z1bmN0aW9uL2Z1bmN0aW9uLnRzXG5mdW5jdGlvbiBmdW5jdGlvbl8obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIHJlZmVyZW5jZTogZnVuY3Rpb25fLFxuICAgIGV4cGVjdHM6IFwiRnVuY3Rpb25cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW5zdGFuY2UvaW5zdGFuY2UudHNcbmZ1bmN0aW9uIGluc3RhbmNlKGNsYXNzXywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJpbnN0YW5jZVwiLFxuICAgIHJlZmVyZW5jZTogaW5zdGFuY2UsXG4gICAgZXhwZWN0czogY2xhc3NfLm5hbWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGNsYXNzOiBjbGFzc18sXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgdGhpcy5jbGFzcykge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC91dGlscy9fbWVyZ2UvX21lcmdlLnRzXG5mdW5jdGlvbiBfbWVyZ2UodmFsdWUxLCB2YWx1ZTIpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZTEgPT09IHR5cGVvZiB2YWx1ZTIpIHtcbiAgICBpZiAodmFsdWUxID09PSB2YWx1ZTIgfHwgdmFsdWUxIGluc3RhbmNlb2YgRGF0ZSAmJiB2YWx1ZTIgaW5zdGFuY2VvZiBEYXRlICYmICt2YWx1ZTEgPT09ICt2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZTEgfTtcbiAgICB9XG4gICAgaWYgKHZhbHVlMSAmJiB2YWx1ZTIgJiYgdmFsdWUxLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgdmFsdWUyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlMikge1xuICAgICAgICBpZiAoa2V5IGluIHZhbHVlMSkge1xuICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBfbWVyZ2UodmFsdWUxW2tleV0sIHZhbHVlMltrZXldKTtcbiAgICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlMVtrZXldID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZTFba2V5XSA9IHZhbHVlMltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUxIH07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpKSB7XG4gICAgICBpZiAodmFsdWUxLmxlbmd0aCA9PT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmFsdWUxLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBfbWVyZ2UodmFsdWUxW2luZGV4XSwgdmFsdWUyW2luZGV4XSk7XG4gICAgICAgICAgaWYgKGRhdGFzZXQuaXNzdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZTFbaW5kZXhdID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGlzc3VlOiB0cnVlIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC9pbnRlcnNlY3QudHNcbmZ1bmN0aW9uIGludGVyc2VjdChvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImludGVyc2VjdFwiLFxuICAgIHJlZmVyZW5jZTogaW50ZXJzZWN0LFxuICAgIGV4cGVjdHM6IFsuLi5uZXcgU2V0KG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSldLmpvaW4oXCIgJiBcIikgfHwgXCJuZXZlclwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICAgIGxldCBvdXRwdXRzO1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9uRGF0YXNldCA9IHNjaGVtYS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dCB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMucHVzaCguLi5vcHRpb25EYXRhc2V0Lmlzc3Vlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IG9wdGlvbkRhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXRzKSB7XG4gICAgICAgICAgICAgIG91dHB1dHMucHVzaChvcHRpb25EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dHMgPSBbb3B0aW9uRGF0YXNldC52YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IG91dHB1dHNbMF07XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IG91dHB1dHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZURhdGFzZXQgPSBfbWVyZ2UoZGF0YXNldC52YWx1ZSwgb3V0cHV0c1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKG1lcmdlRGF0YXNldC5pc3N1ZSkge1xuICAgICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJ1bmtub3duXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZSA9IG1lcmdlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC9pbnRlcnNlY3RBc3luYy50c1xuZnVuY3Rpb24gaW50ZXJzZWN0QXN5bmMob3B0aW9ucywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJpbnRlcnNlY3RcIixcbiAgICByZWZlcmVuY2U6IGludGVyc2VjdEFzeW5jLFxuICAgIGV4cGVjdHM6IFsuLi5uZXcgU2V0KG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSldLmpvaW4oXCIgJiBcIikgfHwgXCJuZXZlclwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXAoXG4gICAgICAgICAgICAoc2NoZW1hKSA9PiBzY2hlbWEuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0IH0sIGNvbmZpZzIpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbkRhdGFzZXQgb2Ygb3B0aW9uRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAob3B0aW9uRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcy5wdXNoKC4uLm9wdGlvbkRhdGFzZXQuaXNzdWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gb3B0aW9uRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgaWYgKG91dHB1dHMpIHtcbiAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG9wdGlvbkRhdGFzZXQudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0cyA9IFtvcHRpb25EYXRhc2V0LnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gb3V0cHV0c1swXTtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgb3V0cHV0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlRGF0YXNldCA9IF9tZXJnZShkYXRhc2V0LnZhbHVlLCBvdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAobWVyZ2VEYXRhc2V0Lmlzc3VlKSB7XG4gICAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcInVua25vd25cIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gbWVyZ2VEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbGF6eS9sYXp5LnRzXG5mdW5jdGlvbiBsYXp5KGdldHRlcikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsYXp5XCIsXG4gICAgcmVmZXJlbmNlOiBsYXp5LFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBnZXR0ZXIsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoZGF0YXNldC52YWx1ZSkuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xhenkvbGF6eUFzeW5jLnRzXG5mdW5jdGlvbiBsYXp5QXN5bmMoZ2V0dGVyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxhenlcIixcbiAgICByZWZlcmVuY2U6IGxhenlBc3luYyxcbiAgICBleHBlY3RzOiBcInVua25vd25cIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBnZXR0ZXIsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0dGVyKGRhdGFzZXQudmFsdWUpKS5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbGl0ZXJhbC9saXRlcmFsLnRzXG5mdW5jdGlvbiBsaXRlcmFsKGxpdGVyYWxfLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICByZWZlcmVuY2U6IGxpdGVyYWwsXG4gICAgZXhwZWN0czogX3N0cmluZ2lmeShsaXRlcmFsXyksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxfLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdGhpcy5saXRlcmFsKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbG9vc2VPYmplY3QvbG9vc2VPYmplY3QudHNcbmZ1bmN0aW9uIGxvb3NlT2JqZWN0KGVudHJpZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibG9vc2Vfb2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBsb29zZU9iamVjdCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy5lbnRyaWVzW2tleV0uX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBrZXkpICYmICEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xvb3NlT2JqZWN0L2xvb3NlT2JqZWN0QXN5bmMudHNcbmZ1bmN0aW9uIGxvb3NlT2JqZWN0QXN5bmMoZW50cmllcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsb29zZV9vYmplY3RcIixcbiAgICByZWZlcmVuY2U6IGxvb3NlT2JqZWN0QXN5bmMsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgc2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICBhd2FpdCBzY2hlbWEuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVEYXRhc2V0XSBvZiB2YWx1ZURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQudmFsdWUgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChfaXNWYWxpZE9iamVjdEtleShpbnB1dCwga2V5KSAmJiAhKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IGlucHV0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sb29zZVR1cGxlL2xvb3NlVHVwbGUudHNcbmZ1bmN0aW9uIGxvb3NlVHVwbGUoaXRlbXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibG9vc2VfdHVwbGVcIixcbiAgICByZWZlcmVuY2U6IGxvb3NlVHVwbGUsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW1zW2tleV0uX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGg7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpbnB1dFtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xvb3NlVHVwbGUvbG9vc2VUdXBsZUFzeW5jLnRzXG5mdW5jdGlvbiBsb29zZVR1cGxlQXN5bmMoaXRlbXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibG9vc2VfdHVwbGVcIixcbiAgICByZWZlcmVuY2U6IGxvb3NlVHVwbGVBc3luYyxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbXMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBjb25zdCBpdGVtRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgIGF3YWl0IGl0ZW0uX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIGl0ZW1EYXRhc2V0cykge1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgPSB0aGlzLml0ZW1zLmxlbmd0aDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGlucHV0W2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbWFwL21hcC50c1xuZnVuY3Rpb24gbWFwKGtleSwgdmFsdWUyLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm1hcFwiLFxuICAgIHJlZmVyZW5jZTogbWFwLFxuICAgIGV4cGVjdHM6IFwiTWFwXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0gb2YgaW5wdXQpIHtcbiAgICAgICAgICBjb25zdCBrZXlEYXRhc2V0ID0gdGhpcy5rZXkuX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXRLZXkgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB0aGlzLnZhbHVlLl9ydW4oXG4gICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0VmFsdWUgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IGlucHV0S2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha2V5RGF0YXNldC50eXBlZCB8fCAhdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUuc2V0KGtleURhdGFzZXQudmFsdWUsIHZhbHVlRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXBBc3luYy50c1xuZnVuY3Rpb24gbWFwQXN5bmMoa2V5LCB2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibWFwXCIsXG4gICAgcmVmZXJlbmNlOiBtYXBBc3luYyxcbiAgICBleHBlY3RzOiBcIk1hcFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIFsuLi5pbnB1dF0ubWFwKFxuICAgICAgICAgICAgKFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0pID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgaW5wdXRLZXksXG4gICAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMua2V5Ll9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dEtleSB9LCBjb25maWcyKSxcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXRWYWx1ZSB9LCBjb25maWcyKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW1xuICAgICAgICAgIGlucHV0S2V5LFxuICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAga2V5RGF0YXNldCxcbiAgICAgICAgICB2YWx1ZURhdGFzZXRcbiAgICAgICAgXSBvZiBkYXRhc2V0cykge1xuICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleURhdGFzZXQudHlwZWQgfHwgIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnNldChrZXlEYXRhc2V0LnZhbHVlLCB2YWx1ZURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uYW4vbmFuLnRzXG5mdW5jdGlvbiBuYW4obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJuYW5cIixcbiAgICByZWZlcmVuY2U6IG5hbixcbiAgICBleHBlY3RzOiBcIk5hTlwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKE51bWJlci5pc05hTihkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25ldmVyL25ldmVyLnRzXG5mdW5jdGlvbiBuZXZlcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5ldmVyXCIsXG4gICAgcmVmZXJlbmNlOiBuZXZlcixcbiAgICBleHBlY3RzOiBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsYWJsZS9ub25OdWxsYWJsZS50c1xuZnVuY3Rpb24gbm9uTnVsbGFibGUod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICByZWZlcmVuY2U6IG5vbk51bGxhYmxlLFxuICAgIGV4cGVjdHM6IFwiIW51bGxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsYWJsZS9ub25OdWxsYWJsZUFzeW5jLnRzXG5mdW5jdGlvbiBub25OdWxsYWJsZUFzeW5jKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibm9uX251bGxhYmxlXCIsXG4gICAgcmVmZXJlbmNlOiBub25OdWxsYWJsZUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiIW51bGxcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaC50c1xuZnVuY3Rpb24gbm9uTnVsbGlzaCh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9udWxsaXNoXCIsXG4gICAgcmVmZXJlbmNlOiBub25OdWxsaXNoLFxuICAgIGV4cGVjdHM6IFwiIW51bGwgJiAhdW5kZWZpbmVkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsIHx8IGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaEFzeW5jLnRzXG5mdW5jdGlvbiBub25OdWxsaXNoQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fbnVsbGlzaFwiLFxuICAgIHJlZmVyZW5jZTogbm9uTnVsbGlzaEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiIW51bGwgJiAhdW5kZWZpbmVkXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uT3B0aW9uYWwvbm9uT3B0aW9uYWwudHNcbmZ1bmN0aW9uIG5vbk9wdGlvbmFsKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibm9uX29wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBub25PcHRpb25hbCxcbiAgICBleHBlY3RzOiBcIiF1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk9wdGlvbmFsL25vbk9wdGlvbmFsQXN5bmMudHNcbmZ1bmN0aW9uIG5vbk9wdGlvbmFsQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fb3B0aW9uYWxcIixcbiAgICByZWZlcmVuY2U6IG5vbk9wdGlvbmFsQXN5bmMsXG4gICAgZXhwZWN0czogXCIhdW5kZWZpbmVkXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGwvbnVsbC50c1xuZnVuY3Rpb24gbnVsbF8obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsXCIsXG4gICAgcmVmZXJlbmNlOiBudWxsXyxcbiAgICBleHBlY3RzOiBcIm51bGxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbGFibGUvbnVsbGFibGUudHNcbmZ1bmN0aW9uIG51bGxhYmxlKHdyYXBwZWQsIC4uLmFyZ3MpIHtcbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogbnVsbGFibGUsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGxgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIHRoaXMpIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gZ2V0RGVmYXVsdChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBkYXRhc2V0LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKDAgaW4gYXJncykge1xuICAgIHNjaGVtYS5kZWZhdWx0ID0gYXJnc1swXTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsYWJsZS9udWxsYWJsZUFzeW5jLnRzXG5mdW5jdGlvbiBudWxsYWJsZUFzeW5jKHdyYXBwZWQsIC4uLmFyZ3MpIHtcbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogbnVsbGFibGVBc3luYyxcbiAgICBleHBlY3RzOiBgJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbGAsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiB0aGlzKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgZGF0YXNldCxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG4gIGlmICgwIGluIGFyZ3MpIHtcbiAgICBzY2hlbWEuZGVmYXVsdCA9IGFyZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbGlzaC9udWxsaXNoLnRzXG5mdW5jdGlvbiBudWxsaXNoKHdyYXBwZWQsIC4uLmFyZ3MpIHtcbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsaXNoXCIsXG4gICAgcmVmZXJlbmNlOiBudWxsaXNoLFxuICAgIGV4cGVjdHM6IGAke3dyYXBwZWQuZXhwZWN0c30gfCBudWxsIHwgdW5kZWZpbmVkYCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsIHx8IGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gdGhpcykge1xuICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBnZXREZWZhdWx0KFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKDAgaW4gYXJncykge1xuICAgIHNjaGVtYS5kZWZhdWx0ID0gYXJnc1swXTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2hBc3luYy50c1xuZnVuY3Rpb24gbnVsbGlzaEFzeW5jKHdyYXBwZWQsIC4uLmFyZ3MpIHtcbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsaXNoXCIsXG4gICAgcmVmZXJlbmNlOiBudWxsaXNoQXN5bmMsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGwgfCB1bmRlZmluZWRgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIHRoaXMpIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gYXdhaXQgZ2V0RGVmYXVsdChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBkYXRhc2V0LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG4gIGlmICgwIGluIGFyZ3MpIHtcbiAgICBzY2hlbWEuZGVmYXVsdCA9IGFyZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVtYmVyL251bWJlci50c1xuZnVuY3Rpb24gbnVtYmVyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgcmVmZXJlbmNlOiBudW1iZXIsXG4gICAgZXhwZWN0czogXCJudW1iZXJcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vYmplY3Qvb2JqZWN0LnRzXG5mdW5jdGlvbiBvYmplY3QoZW50cmllcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICByZWZlcmVuY2U6IG9iamVjdCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy5lbnRyaWVzW2tleV0uX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0L29iamVjdEFzeW5jLnRzXG5mdW5jdGlvbiBvYmplY3RBc3luYyhlbnRyaWVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0QXN5bmMsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgc2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICBhd2FpdCBzY2hlbWEuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVEYXRhc2V0XSBvZiB2YWx1ZURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQudmFsdWUgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdFdpdGhSZXN0L29iamVjdFdpdGhSZXN0LnRzXG5mdW5jdGlvbiBvYmplY3RXaXRoUmVzdChlbnRyaWVzLCByZXN0LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9iamVjdF93aXRoX3Jlc3RcIixcbiAgICByZWZlcmVuY2U6IG9iamVjdFdpdGhSZXN0LFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudHJpZXMsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmVudHJpZXMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMuZW50cmllc1trZXldLl9ydW4oXG4gICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQudmFsdWUgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChfaXNWYWxpZE9iamVjdEtleShpbnB1dCwga2V5KSAmJiAhKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMucmVzdC5fcnVuKFxuICAgICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0V2l0aFJlc3Qvb2JqZWN0V2l0aFJlc3RBc3luYy50c1xuZnVuY3Rpb24gb2JqZWN0V2l0aFJlc3RBc3luYyhlbnRyaWVzLCByZXN0LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9iamVjdF93aXRoX3Jlc3RcIixcbiAgICByZWZlcmVuY2U6IG9iamVjdFdpdGhSZXN0QXN5bmMsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgW25vcm1hbERhdGFzZXRzLCByZXN0RGF0YXNldHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIFBhcnNlIHNjaGVtYSBvZiBlYWNoIG5vcm1hbCBlbnRyeVxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHNjaGVtYV0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIGF3YWl0IHNjaGVtYS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gUGFyc2Ugb3RoZXIgZW50cmllcyB3aXRoIHJlc3Qgc2NoZW1hXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhpbnB1dCkuZmlsdGVyKFxuICAgICAgICAgICAgICAoW2tleV0pID0+IF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBrZXkpICYmICEoa2V5IGluIHRoaXMuZW50cmllcylcbiAgICAgICAgICAgICkubWFwKFxuICAgICAgICAgICAgICBhc3luYyAoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXN0Ll9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgXSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCB2YWx1ZURhdGFzZXRdIG9mIG5vcm1hbERhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQudmFsdWUgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIHZhbHVlRGF0YXNldF0gb2YgcmVzdERhdGFzZXRzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb3B0aW9uYWwvb3B0aW9uYWwudHNcbmZ1bmN0aW9uIG9wdGlvbmFsKHdyYXBwZWQsIC4uLmFyZ3MpIHtcbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogb3B0aW9uYWwsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IHVuZGVmaW5lZGAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiB0aGlzKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgZGF0YXNldCxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKDAgaW4gYXJncykge1xuICAgIHNjaGVtYS5kZWZhdWx0ID0gYXJnc1swXTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vcHRpb25hbC9vcHRpb25hbEFzeW5jLnRzXG5mdW5jdGlvbiBvcHRpb25hbEFzeW5jKHdyYXBwZWQsIC4uLmFyZ3MpIHtcbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogb3B0aW9uYWxBc3luYyxcbiAgICBleHBlY3RzOiBgJHt3cmFwcGVkLmV4cGVjdHN9IHwgdW5kZWZpbmVkYCxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gdGhpcykge1xuICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBhd2FpdCBnZXREZWZhdWx0KFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG4gIGlmICgwIGluIGFyZ3MpIHtcbiAgICBzY2hlbWEuZGVmYXVsdCA9IGFyZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcGlja2xpc3QvcGlja2xpc3QudHNcbmZ1bmN0aW9uIHBpY2tsaXN0KG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicGlja2xpc3RcIixcbiAgICByZWZlcmVuY2U6IHBpY2tsaXN0LFxuICAgIGV4cGVjdHM6IG9wdGlvbnMubWFwKF9zdHJpbmdpZnkpLmpvaW4oXCIgfCBcIikgfHwgXCJuZXZlclwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmluY2x1ZGVzKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcHJvbWlzZS9wcm9taXNlLnRzXG5mdW5jdGlvbiBwcm9taXNlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicHJvbWlzZVwiLFxuICAgIHJlZmVyZW5jZTogcHJvbWlzZSxcbiAgICBleHBlY3RzOiBcIlByb21pc2VcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmQudHNcbmZ1bmN0aW9uIHJlY29yZChrZXksIHZhbHVlMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICByZWZlcmVuY2U6IHJlY29yZCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBrZXksXG4gICAgdmFsdWU6IHZhbHVlMixcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5S2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgaWYgKF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBlbnRyeUtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5VmFsdWUgPSBpbnB1dFtlbnRyeUtleV07XG4gICAgICAgICAgICBjb25zdCBrZXlEYXRhc2V0ID0gdGhpcy5rZXkuX3J1bihcbiAgICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBlbnRyeUtleSB9LFxuICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleTogZW50cnlLZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5VmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBrZXlEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB0aGlzLnZhbHVlLl9ydW4oXG4gICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogZW50cnlWYWx1ZSB9LFxuICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IGVudHJ5S2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeVZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXlEYXRhc2V0LnR5cGVkIHx8ICF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXlEYXRhc2V0LnZhbHVlXSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmRBc3luYy50c1xuZnVuY3Rpb24gcmVjb3JkQXN5bmMoa2V5LCB2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgcmVmZXJlbmNlOiByZWNvcmRBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5wdXQpLmZpbHRlcigoW2tleTJdKSA9PiBfaXNWYWxpZE9iamVjdEtleShpbnB1dCwga2V5MikpLm1hcChcbiAgICAgICAgICAgIChbZW50cnlLZXksIGVudHJ5VmFsdWVdKSA9PiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIGVudHJ5S2V5LFxuICAgICAgICAgICAgICBlbnRyeVZhbHVlLFxuICAgICAgICAgICAgICB0aGlzLmtleS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogZW50cnlLZXkgfSwgY29uZmlnMiksXG4gICAgICAgICAgICAgIHRoaXMudmFsdWUuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGVudHJ5VmFsdWUgfSwgY29uZmlnMilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtcbiAgICAgICAgICBlbnRyeUtleSxcbiAgICAgICAgICBlbnRyeVZhbHVlLFxuICAgICAgICAgIGtleURhdGFzZXQsXG4gICAgICAgICAgdmFsdWVEYXRhc2V0XG4gICAgICAgIF0gb2YgZGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAoa2V5RGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IGVudHJ5S2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZW50cnlWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2Yga2V5RGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBrZXlEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogZW50cnlLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBlbnRyeVZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrZXlEYXRhc2V0LnR5cGVkIHx8ICF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5RGF0YXNldC52YWx1ZV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zZXQvc2V0LnRzXG5mdW5jdGlvbiBzZXQodmFsdWUyLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIHJlZmVyZW5jZTogc2V0LFxuICAgIGV4cGVjdHM6IFwiU2V0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXRWYWx1ZSBvZiBpbnB1dCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMudmFsdWUuX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXRWYWx1ZSB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLmFkZCh2YWx1ZURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zZXQvc2V0QXN5bmMudHNcbmZ1bmN0aW9uIHNldEFzeW5jKHZhbHVlMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICByZWZlcmVuY2U6IHNldEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiU2V0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlMixcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIFsuLi5pbnB1dF0ubWFwKFxuICAgICAgICAgICAgYXN5bmMgKGlucHV0VmFsdWUpID0+IFtcbiAgICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy52YWx1ZS5fcnVuKFxuICAgICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXRWYWx1ZSB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBbaW5wdXRWYWx1ZSwgdmFsdWVEYXRhc2V0XSBvZiB2YWx1ZURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLmFkZCh2YWx1ZURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpY3RPYmplY3Qvc3RyaWN0T2JqZWN0LnRzXG5mdW5jdGlvbiBzdHJpY3RPYmplY3QoZW50cmllcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3Rfb2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpY3RPYmplY3QsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW50cmllcyxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmVudHJpZXMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMuZW50cmllc1trZXldLl9ydW4oXG4gICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQudmFsdWUgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICAgIGlucHV0OiB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpY3RPYmplY3Qvc3RyaWN0T2JqZWN0QXN5bmMudHNcbmZ1bmN0aW9uIHN0cmljdE9iamVjdEFzeW5jKGVudHJpZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3RyaWN0X29iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogc3RyaWN0T2JqZWN0QXN5bmMsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgc2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICBhd2FpdCBzY2hlbWEuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVEYXRhc2V0XSBvZiB2YWx1ZURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQudmFsdWUgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICAgIGlucHV0OiB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpY3RUdXBsZS9zdHJpY3RUdXBsZS50c1xuZnVuY3Rpb24gc3RyaWN0VHVwbGUoaXRlbXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3RyaWN0X3R1cGxlXCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpY3RUdXBsZSxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgdGhpcy5pdGVtcy5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMuaXRlbXNba2V5XS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShkYXRhc2V0Lmlzc3VlcyAmJiBjb25maWcyLmFib3J0RWFybHkpICYmIHRoaXMuaXRlbXMubGVuZ3RoIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRbaXRlbXMubGVuZ3RoXTtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIGlucHV0OiB2YWx1ZTIsXG4gICAgICAgICAgICBleHBlY3RlZDogXCJuZXZlclwiLFxuICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N0cmljdFR1cGxlL3N0cmljdFR1cGxlQXN5bmMudHNcbmZ1bmN0aW9uIHN0cmljdFR1cGxlQXN5bmMoaXRlbXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3RyaWN0X3R1cGxlXCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpY3RUdXBsZUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuaXRlbXMubWFwKGFzeW5jIChpdGVtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgYXdhaXQgaXRlbS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCBpdGVtRGF0YXNldF0gb2YgaXRlbURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGRhdGFzZXQuaXNzdWVzICYmIGNvbmZpZzIuYWJvcnRFYXJseSkgJiYgdGhpcy5pdGVtcy5sZW5ndGggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtpdGVtcy5sZW5ndGhdO1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgaW5wdXQ6IHZhbHVlMixcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcIm5ldmVyXCIsXG4gICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaW5nL3N0cmluZy50c1xuZnVuY3Rpb24gc3RyaW5nKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpbmcsXG4gICAgZXhwZWN0czogXCJzdHJpbmdcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N5bWJvbC9zeW1ib2wudHNcbmZ1bmN0aW9uIHN5bWJvbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInN5bWJvbFwiLFxuICAgIHJlZmVyZW5jZTogc3ltYm9sLFxuICAgIGV4cGVjdHM6IFwic3ltYm9sXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFzZXQudmFsdWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS90dXBsZS50c1xuZnVuY3Rpb24gdHVwbGUoaXRlbXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICByZWZlcmVuY2U6IHR1cGxlLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbXMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCB0aGlzLml0ZW1zLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gdGhpcy5pdGVtc1trZXldLl9ydW4oXG4gICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS90dXBsZUFzeW5jLnRzXG5mdW5jdGlvbiB0dXBsZUFzeW5jKGl0ZW1zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgcmVmZXJlbmNlOiB0dXBsZUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuaXRlbXMubWFwKGFzeW5jIChpdGVtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgYXdhaXQgaXRlbS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCBpdGVtRGF0YXNldF0gb2YgaXRlbURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZVdpdGhSZXN0L3R1cGxlV2l0aFJlc3QudHNcbmZ1bmN0aW9uIHR1cGxlV2l0aFJlc3QoaXRlbXMsIHJlc3QsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidHVwbGVfd2l0aF9yZXN0XCIsXG4gICAgcmVmZXJlbmNlOiB0dXBsZVdpdGhSZXN0LFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbXMsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW1zW2tleV0uX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGg7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMucmVzdC5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpO1xuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdHVwbGVXaXRoUmVzdC90dXBsZVdpdGhSZXN0QXN5bmMudHNcbmZ1bmN0aW9uIHR1cGxlV2l0aFJlc3RBc3luYyhpdGVtcywgcmVzdCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ0dXBsZV93aXRoX3Jlc3RcIixcbiAgICByZWZlcmVuY2U6IHR1cGxlV2l0aFJlc3RBc3luYyxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbXMsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGNvbnN0IFtub3JtYWxEYXRhc2V0cywgcmVzdERhdGFzZXRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAvLyBQYXJzZSBzY2hlbWEgb2YgZWFjaCBub3JtYWwgaXRlbVxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgdGhpcy5pdGVtcy5tYXAoYXN5bmMgKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgYXdhaXQgaXRlbS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgLy8gUGFyc2Ugb3RoZXIgaXRlbXMgd2l0aCByZXN0IHNjaGVtYVxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgaW5wdXQuc2xpY2UodGhpcy5pdGVtcy5sZW5ndGgpLm1hcChhc3luYyAodmFsdWUyLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXkgKyB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXN0Ll9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIGl0ZW1EYXRhc2V0XSBvZiBub3JtYWxEYXRhc2V0cykge1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIHJlc3REYXRhc2V0cykge1xuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5kZWZpbmVkL3VuZGVmaW5lZC50c1xuZnVuY3Rpb24gdW5kZWZpbmVkXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgIHJlZmVyZW5jZTogdW5kZWZpbmVkXyxcbiAgICBleHBlY3RzOiBcInVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuaW9uL3V0aWxzL19zdWJJc3N1ZXMvX3N1Yklzc3Vlcy50c1xuZnVuY3Rpb24gX3N1Yklzc3VlcyhkYXRhc2V0cykge1xuICBsZXQgaXNzdWVzO1xuICBpZiAoZGF0YXNldHMpIHtcbiAgICBmb3IgKGNvbnN0IGRhdGFzZXQgb2YgZGF0YXNldHMpIHtcbiAgICAgIGlmIChpc3N1ZXMpIHtcbiAgICAgICAgaXNzdWVzLnB1c2goLi4uZGF0YXNldC5pc3N1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNzdWVzID0gZGF0YXNldC5pc3N1ZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpc3N1ZXM7XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuaW9uL3VuaW9uLnRzXG5mdW5jdGlvbiB1bmlvbihvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgcmVmZXJlbmNlOiB1bmlvbixcbiAgICBleHBlY3RzOiBbLi4ubmV3IFNldChvcHRpb25zLm1hcCgob3B0aW9uKSA9PiBvcHRpb24uZXhwZWN0cykpXS5qb2luKFwiIHwgXCIpIHx8IFwibmV2ZXJcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgbGV0IHZhbGlkRGF0YXNldDtcbiAgICAgIGxldCB0eXBlZERhdGFzZXRzO1xuICAgICAgbGV0IHVudHlwZWREYXRhc2V0cztcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0ID0gc2NoZW1hLl9ydW4oXG4gICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBkYXRhc2V0LnZhbHVlIH0sXG4gICAgICAgICAgY29uZmlnMlxuICAgICAgICApO1xuICAgICAgICBpZiAob3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgIGlmIChvcHRpb25EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgICAgICAgdHlwZWREYXRhc2V0cy5wdXNoKG9wdGlvbkRhdGFzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZWREYXRhc2V0cyA9IFtvcHRpb25EYXRhc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWREYXRhc2V0ID0gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodW50eXBlZERhdGFzZXRzKSB7XG4gICAgICAgICAgICB1bnR5cGVkRGF0YXNldHMucHVzaChvcHRpb25EYXRhc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW50eXBlZERhdGFzZXRzID0gW29wdGlvbkRhdGFzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbGlkRGF0YXNldCkge1xuICAgICAgICByZXR1cm4gdmFsaWREYXRhc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgaWYgKHR5cGVkRGF0YXNldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVkRGF0YXNldHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgaXNzdWVzOiBfc3ViSXNzdWVzKHR5cGVkRGF0YXNldHMpXG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodW50eXBlZERhdGFzZXRzPy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHVudHlwZWREYXRhc2V0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIGlzc3VlczogX3N1Yklzc3Vlcyh1bnR5cGVkRGF0YXNldHMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmlvbi91bmlvbkFzeW5jLnRzXG5mdW5jdGlvbiB1bmlvbkFzeW5jKG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICByZWZlcmVuY2U6IHVuaW9uQXN5bmMsXG4gICAgZXhwZWN0czogWy4uLm5ldyBTZXQob3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmV4cGVjdHMpKV0uam9pbihcIiB8IFwiKSB8fCBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgbGV0IHZhbGlkRGF0YXNldDtcbiAgICAgIGxldCB0eXBlZERhdGFzZXRzO1xuICAgICAgbGV0IHVudHlwZWREYXRhc2V0cztcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0ID0gYXdhaXQgc2NoZW1hLl9ydW4oXG4gICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBkYXRhc2V0LnZhbHVlIH0sXG4gICAgICAgICAgY29uZmlnMlxuICAgICAgICApO1xuICAgICAgICBpZiAob3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgIGlmIChvcHRpb25EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgICAgICAgdHlwZWREYXRhc2V0cy5wdXNoKG9wdGlvbkRhdGFzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZWREYXRhc2V0cyA9IFtvcHRpb25EYXRhc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWREYXRhc2V0ID0gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodW50eXBlZERhdGFzZXRzKSB7XG4gICAgICAgICAgICB1bnR5cGVkRGF0YXNldHMucHVzaChvcHRpb25EYXRhc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW50eXBlZERhdGFzZXRzID0gW29wdGlvbkRhdGFzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbGlkRGF0YXNldCkge1xuICAgICAgICByZXR1cm4gdmFsaWREYXRhc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgaWYgKHR5cGVkRGF0YXNldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVkRGF0YXNldHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgaXNzdWVzOiBfc3ViSXNzdWVzKHR5cGVkRGF0YXNldHMpXG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodW50eXBlZERhdGFzZXRzPy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHVudHlwZWREYXRhc2V0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIGlzc3VlczogX3N1Yklzc3Vlcyh1bnR5cGVkRGF0YXNldHMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmtub3duL3Vua25vd24udHNcbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInVua25vd25cIixcbiAgICByZWZlcmVuY2U6IHVua25vd24sXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdXRpbHMvX2Rpc2NyaW1pbmF0b3JzL19kaXNjcmltaW5hdG9ycy50c1xuZnVuY3Rpb24gX2Rpc2NyaW1pbmF0b3JzKGtleSwgb3B0aW9ucywgc2V0MiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcbiAgZm9yIChjb25zdCBzY2hlbWEgb2Ygb3B0aW9ucykge1xuICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJ2YXJpYW50XCIpIHtcbiAgICAgIF9kaXNjcmltaW5hdG9ycyhrZXksIHNjaGVtYS5vcHRpb25zLCBzZXQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Mi5hZGQoc2NoZW1hLmVudHJpZXNba2V5XS5leHBlY3RzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNldDI7XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdmFyaWFudC50c1xuZnVuY3Rpb24gdmFyaWFudChrZXksIG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgbGV0IGV4cGVjdGVkRGlzY3JpbWluYXRvcnM7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInZhcmlhbnRcIixcbiAgICByZWZlcmVuY2U6IHZhcmlhbnQsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGlucHV0W3RoaXMua2V5XTtcbiAgICAgICAgaWYgKHRoaXMua2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgbGV0IG91dHB1dERhdGFzZXQ7XG4gICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwidmFyaWFudFwiIHx8ICFzY2hlbWEuZW50cmllc1t0aGlzLmtleV0uX3J1bihcbiAgICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBkaXNjcmltaW5hdG9yIH0sXG4gICAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICAgICkuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBzY2hlbWEuX3J1bihcbiAgICAgICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0IH0sXG4gICAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoIW9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbkRhdGFzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFvdXRwdXREYXRhc2V0IHx8ICFvdXRwdXREYXRhc2V0LnR5cGVkICYmIG9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXREYXRhc2V0ID0gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0RGF0YXNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dERhdGFzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZXhwZWN0ZWREaXNjcmltaW5hdG9ycykge1xuICAgICAgICAgIGV4cGVjdGVkRGlzY3JpbWluYXRvcnMgPSBbLi4uX2Rpc2NyaW1pbmF0b3JzKHRoaXMua2V5LCB0aGlzLm9wdGlvbnMpXS5qb2luKFwiIHwgXCIpIHx8IFwibmV2ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICBpbnB1dDogZGlzY3JpbWluYXRvcixcbiAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWREaXNjcmltaW5hdG9ycyxcbiAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdmFyaWFudC92YXJpYW50QXN5bmMudHNcbmZ1bmN0aW9uIHZhcmlhbnRBc3luYyhrZXksIG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgbGV0IGV4cGVjdGVkRGlzY3JpbWluYXRvcnM7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInZhcmlhbnRcIixcbiAgICByZWZlcmVuY2U6IHZhcmlhbnRBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBpbnB1dFt0aGlzLmtleV07XG4gICAgICAgIGlmICh0aGlzLmtleSBpbiBpbnB1dCkge1xuICAgICAgICAgIGxldCBvdXRwdXREYXRhc2V0O1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcInZhcmlhbnRcIiB8fCAhKGF3YWl0IHNjaGVtYS5lbnRyaWVzW3RoaXMua2V5XS5fcnVuKFxuICAgICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGRpc2NyaW1pbmF0b3IgfSxcbiAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgKSkuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBhd2FpdCBzY2hlbWEuX3J1bihcbiAgICAgICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0IH0sXG4gICAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoIW9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbkRhdGFzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFvdXRwdXREYXRhc2V0IHx8ICFvdXRwdXREYXRhc2V0LnR5cGVkICYmIG9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXREYXRhc2V0ID0gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0RGF0YXNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dERhdGFzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZXhwZWN0ZWREaXNjcmltaW5hdG9ycykge1xuICAgICAgICAgIGV4cGVjdGVkRGlzY3JpbWluYXRvcnMgPSBbLi4uX2Rpc2NyaW1pbmF0b3JzKHRoaXMua2V5LCB0aGlzLm9wdGlvbnMpXS5qb2luKFwiIHwgXCIpIHx8IFwibmV2ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICBpbnB1dDogZGlzY3JpbWluYXRvcixcbiAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWREaXNjcmltaW5hdG9ycyxcbiAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdm9pZC92b2lkLnRzXG5mdW5jdGlvbiB2b2lkXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInZvaWRcIixcbiAgICByZWZlcmVuY2U6IHZvaWRfLFxuICAgIGV4cGVjdHM6IFwidm9pZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2tleW9mL2tleW9mLnRzXG5mdW5jdGlvbiBrZXlvZihzY2hlbWEsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHBpY2tsaXN0KE9iamVjdC5rZXlzKHNjaGVtYS5lbnRyaWVzKSwgbWVzc2FnZSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL29taXQvb21pdC50c1xuZnVuY3Rpb24gb21pdChzY2hlbWEsIGtleXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHtcbiAgICAuLi5zY2hlbWEuZW50cmllc1xuICB9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZGVsZXRlIGVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4geyAuLi5zY2hlbWEsIGVudHJpZXMgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2UvcGFyc2UudHNcbmZ1bmN0aW9uIHBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpIHtcbiAgY29uc3QgZGF0YXNldCA9IHNjaGVtYS5fcnVuKFxuICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXQgfSxcbiAgICBnZXRHbG9iYWxDb25maWcoY29uZmlnMilcbiAgKTtcbiAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlFcnJvcihkYXRhc2V0Lmlzc3Vlcyk7XG4gIH1cbiAgcmV0dXJuIGRhdGFzZXQudmFsdWU7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlL3BhcnNlQXN5bmMudHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnMikge1xuICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgc2NoZW1hLl9ydW4oXG4gICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dCB9LFxuICAgIGdldEdsb2JhbENvbmZpZyhjb25maWcyKVxuICApO1xuICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaUVycm9yKGRhdGFzZXQuaXNzdWVzKTtcbiAgfVxuICByZXR1cm4gZGF0YXNldC52YWx1ZTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2VyL3BhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VyKHNjaGVtYSwgY29uZmlnMikge1xuICBjb25zdCBmdW5jID0gKGlucHV0KSA9PiBwYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcyKTtcbiAgZnVuYy5zY2hlbWEgPSBzY2hlbWE7XG4gIGZ1bmMuY29uZmlnID0gY29uZmlnMjtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlci9wYXJzZXJBc3luYy50c1xuZnVuY3Rpb24gcGFyc2VyQXN5bmMoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnMik7XG4gIGZ1bmMuc2NoZW1hID0gc2NoZW1hO1xuICBmdW5jLmNvbmZpZyA9IGNvbmZpZzI7XG4gIHJldHVybiBmdW5jO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJ0aWFsL3BhcnRpYWwudHNcbmZ1bmN0aW9uIHBhcnRpYWwoc2NoZW1hLCBrZXlzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzW2tleV0gPSAha2V5cyB8fCBrZXlzLmluY2x1ZGVzKGtleSkgPyBvcHRpb25hbChzY2hlbWEuZW50cmllc1trZXldKSA6IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHsgLi4uc2NoZW1hLCBlbnRyaWVzIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnRpYWwvcGFydGlhbEFzeW5jLnRzXG5mdW5jdGlvbiBwYXJ0aWFsQXN5bmMoc2NoZW1hLCBrZXlzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzW2tleV0gPSAha2V5cyB8fCBrZXlzLmluY2x1ZGVzKGtleSkgPyBvcHRpb25hbEFzeW5jKHNjaGVtYS5lbnRyaWVzW2tleV0pIDogc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4geyAuLi5zY2hlbWEsIGVudHJpZXMgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGljay9waWNrLnRzXG5mdW5jdGlvbiBwaWNrKHNjaGVtYSwga2V5cykge1xuICBjb25zdCBlbnRyaWVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBlbnRyaWVzW2tleV0gPSBzY2hlbWEuZW50cmllc1trZXldO1xuICB9XG4gIHJldHVybiB7IC4uLnNjaGVtYSwgZW50cmllcyB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waXBlL3BpcGUudHNcbmZ1bmN0aW9uIHBpcGUoLi4ucGlwZTIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5waXBlMlswXSxcbiAgICBwaXBlOiBwaXBlMixcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwaXBlMi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzICYmIChwaXBlMltpbmRleF0ua2luZCA9PT0gXCJzY2hlbWFcIiB8fCBwaXBlMltpbmRleF0ua2luZCA9PT0gXCJ0cmFuc2Zvcm1hdGlvblwiKSkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkgJiYgIWNvbmZpZzIuYWJvcnRQaXBlRWFybHkpIHtcbiAgICAgICAgICBkYXRhc2V0ID0gcGlwZTJbaW5kZXhdLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGlwZS9waXBlQXN5bmMudHNcbmZ1bmN0aW9uIHBpcGVBc3luYyguLi5waXBlMikge1xuICByZXR1cm4ge1xuICAgIC4uLnBpcGUyWzBdLFxuICAgIHBpcGU6IHBpcGUyLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBpcGUyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZXMgJiYgKHBpcGUyW2luZGV4XS5raW5kID09PSBcInNjaGVtYVwiIHx8IHBpcGUyW2luZGV4XS5raW5kID09PSBcInRyYW5zZm9ybWF0aW9uXCIpKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSAmJiAhY29uZmlnMi5hYm9ydFBpcGVFYXJseSkge1xuICAgICAgICAgIGRhdGFzZXQgPSBhd2FpdCBwaXBlMltpbmRleF0uX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9yZXF1aXJlZC9yZXF1aXJlZC50c1xuZnVuY3Rpb24gcmVxdWlyZWQoc2NoZW1hLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGFyZzIpID8gYXJnMiA6IHZvaWQgMDtcbiAgY29uc3QgbWVzc2FnZSA9IEFycmF5LmlzQXJyYXkoYXJnMikgPyBhcmczIDogYXJnMjtcbiAgY29uc3QgZW50cmllcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgIGVudHJpZXNba2V5XSA9ICFrZXlzIHx8IGtleXMuaW5jbHVkZXMoa2V5KSA/IG5vbk9wdGlvbmFsKHNjaGVtYS5lbnRyaWVzW2tleV0sIG1lc3NhZ2UpIDogc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4geyAuLi5zY2hlbWEsIGVudHJpZXMgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcmVxdWlyZWQvcmVxdWlyZWRBc3luYy50c1xuZnVuY3Rpb24gcmVxdWlyZWRBc3luYyhzY2hlbWEsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoYXJnMikgPyBhcmcyIDogdm9pZCAwO1xuICBjb25zdCBtZXNzYWdlID0gQXJyYXkuaXNBcnJheShhcmcyKSA/IGFyZzMgOiBhcmcyO1xuICBjb25zdCBlbnRyaWVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5lbnRyaWVzKSB7XG4gICAgZW50cmllc1trZXldID0gIWtleXMgfHwga2V5cy5pbmNsdWRlcyhrZXkpID8gbm9uT3B0aW9uYWxBc3luYyhzY2hlbWEuZW50cmllc1trZXldLCBtZXNzYWdlKSA6IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHsgLi4uc2NoZW1hLCBlbnRyaWVzIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2UudHNcbmZ1bmN0aW9uIHNhZmVQYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcyKSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzY2hlbWEuX3J1bihcbiAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0IH0sXG4gICAgZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZzIpXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZWQ6IGRhdGFzZXQudHlwZWQsXG4gICAgc3VjY2VzczogIWRhdGFzZXQuaXNzdWVzLFxuICAgIG91dHB1dDogZGF0YXNldC52YWx1ZSxcbiAgICBpc3N1ZXM6IGRhdGFzZXQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gc2FmZVBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnMikge1xuICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgc2NoZW1hLl9ydW4oXG4gICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dCB9LFxuICAgIGdldEdsb2JhbENvbmZpZyhjb25maWcyKVxuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGVkOiBkYXRhc2V0LnR5cGVkLFxuICAgIHN1Y2Nlc3M6ICFkYXRhc2V0Lmlzc3VlcyxcbiAgICBvdXRwdXQ6IGRhdGFzZXQudmFsdWUsXG4gICAgaXNzdWVzOiBkYXRhc2V0Lmlzc3Vlc1xuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9zYWZlUGFyc2VyL3NhZmVQYXJzZXIudHNcbmZ1bmN0aW9uIHNhZmVQYXJzZXIoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHNhZmVQYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcyKTtcbiAgZnVuYy5zY2hlbWEgPSBzY2hlbWE7XG4gIGZ1bmMuY29uZmlnID0gY29uZmlnMjtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZXIvc2FmZVBhcnNlckFzeW5jLnRzXG5mdW5jdGlvbiBzYWZlUGFyc2VyQXN5bmMoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHNhZmVQYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvdW53cmFwL3Vud3JhcC50c1xuZnVuY3Rpb24gdW53cmFwKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hLndyYXBwZWQ7XG59XG5leHBvcnQge1xuICBCSUNfUkVHRVgsXG4gIENVSUQyX1JFR0VYLFxuICBERUNJTUFMX1JFR0VYLFxuICBFTUFJTF9SRUdFWCxcbiAgRU1PSklfUkVHRVgsXG4gIEhFWEFERUNJTUFMX1JFR0VYLFxuICBIRVhfQ09MT1JfUkVHRVgsXG4gIElNRUlfUkVHRVgsXG4gIElQVjRfUkVHRVgsXG4gIElQVjZfUkVHRVgsXG4gIElQX1JFR0VYLFxuICBJU09fREFURV9SRUdFWCxcbiAgSVNPX0RBVEVfVElNRV9SRUdFWCxcbiAgSVNPX1RJTUVTVEFNUF9SRUdFWCxcbiAgSVNPX1RJTUVfUkVHRVgsXG4gIElTT19USU1FX1NFQ09ORF9SRUdFWCxcbiAgSVNPX1dFRUtfUkVHRVgsXG4gIE1BQzQ4X1JFR0VYLFxuICBNQUM2NF9SRUdFWCxcbiAgTUFDX1JFR0VYLFxuICBPQ1RBTF9SRUdFWCxcbiAgVUxJRF9SRUdFWCxcbiAgVVVJRF9SRUdFWCxcbiAgVmFsaUVycm9yLFxuICBfYWRkSXNzdWUsXG4gIF9pc0x1aG5BbGdvLFxuICBfaXNWYWxpZE9iamVjdEtleSxcbiAgX3N0cmluZ2lmeSxcbiAgYW55LFxuICBhcnJheSxcbiAgYXJyYXlBc3luYyxcbiAgYXdhaXRBc3luYyxcbiAgYmljLFxuICBiaWdpbnQsXG4gIGJsb2IsXG4gIGJvb2xlYW4sXG4gIGJyYW5kLFxuICBieXRlcyxcbiAgY2hlY2ssXG4gIGNoZWNrQXN5bmMsXG4gIGNoZWNrSXRlbXMsXG4gIGNvbmZpZyxcbiAgY3JlZGl0Q2FyZCxcbiAgY3VpZDIsXG4gIGN1c3RvbSxcbiAgY3VzdG9tQXN5bmMsXG4gIGRhdGUsXG4gIGRlY2ltYWwsXG4gIGRlbGV0ZUdsb2JhbENvbmZpZyxcbiAgZGVsZXRlR2xvYmFsTWVzc2FnZSxcbiAgZGVsZXRlU2NoZW1hTWVzc2FnZSxcbiAgZGVsZXRlU3BlY2lmaWNNZXNzYWdlLFxuICBlbWFpbCxcbiAgZW1vamksXG4gIGVtcHR5LFxuICBlbmRzV2l0aCxcbiAgZW50cmllc0Zyb21MaXN0LFxuICBlbnVtXyBhcyBlbnVtLFxuICBlbnVtXyxcbiAgZXZlcnlJdGVtLFxuICBleGNsdWRlcyxcbiAgZmFsbGJhY2ssXG4gIGZhbGxiYWNrQXN5bmMsXG4gIGZpbGUsXG4gIGZpbHRlckl0ZW1zLFxuICBmaW5kSXRlbSxcbiAgZmluaXRlLFxuICBmbGF0dGVuLFxuICBmb3J3YXJkLFxuICBmb3J3YXJkQXN5bmMsXG4gIGZ1bmN0aW9uXyBhcyBmdW5jdGlvbixcbiAgZnVuY3Rpb25fLFxuICBnZXREZWZhdWx0LFxuICBnZXREZWZhdWx0cyxcbiAgZ2V0RGVmYXVsdHNBc3luYyxcbiAgZ2V0RG90UGF0aCxcbiAgZ2V0RmFsbGJhY2ssXG4gIGdldEZhbGxiYWNrcyxcbiAgZ2V0RmFsbGJhY2tzQXN5bmMsXG4gIGdldEdsb2JhbENvbmZpZyxcbiAgZ2V0R2xvYmFsTWVzc2FnZSxcbiAgZ2V0U2NoZW1hTWVzc2FnZSxcbiAgZ2V0U3BlY2lmaWNNZXNzYWdlLFxuICBoYXNoLFxuICBoZXhDb2xvcixcbiAgaGV4YWRlY2ltYWwsXG4gIGltZWksXG4gIGluY2x1ZGVzLFxuICBpbnN0YW5jZSxcbiAgaW50ZWdlcixcbiAgaW50ZXJzZWN0LFxuICBpbnRlcnNlY3RBc3luYyxcbiAgaXAsXG4gIGlwdjQsXG4gIGlwdjYsXG4gIGlzLFxuICBpc09mS2luZCxcbiAgaXNPZlR5cGUsXG4gIGlzVmFsaUVycm9yLFxuICBpc29EYXRlLFxuICBpc29EYXRlVGltZSxcbiAgaXNvVGltZSxcbiAgaXNvVGltZVNlY29uZCxcbiAgaXNvVGltZXN0YW1wLFxuICBpc29XZWVrLFxuICBrZXlvZixcbiAgbGF6eSxcbiAgbGF6eUFzeW5jLFxuICBsZW5ndGgsXG4gIGxpdGVyYWwsXG4gIGxvb3NlT2JqZWN0LFxuICBsb29zZU9iamVjdEFzeW5jLFxuICBsb29zZVR1cGxlLFxuICBsb29zZVR1cGxlQXN5bmMsXG4gIG1hYyxcbiAgbWFjNDgsXG4gIG1hYzY0LFxuICBtYXAsXG4gIG1hcEFzeW5jLFxuICBtYXBJdGVtcyxcbiAgbWF4Qnl0ZXMsXG4gIG1heExlbmd0aCxcbiAgbWF4U2l6ZSxcbiAgbWF4VmFsdWUsXG4gIG1pbWVUeXBlLFxuICBtaW5CeXRlcyxcbiAgbWluTGVuZ3RoLFxuICBtaW5TaXplLFxuICBtaW5WYWx1ZSxcbiAgbXVsdGlwbGVPZixcbiAgbmFuLFxuICBuZXZlcixcbiAgbm9uRW1wdHksXG4gIG5vbk51bGxhYmxlLFxuICBub25OdWxsYWJsZUFzeW5jLFxuICBub25OdWxsaXNoLFxuICBub25OdWxsaXNoQXN5bmMsXG4gIG5vbk9wdGlvbmFsLFxuICBub25PcHRpb25hbEFzeW5jLFxuICBub3JtYWxpemUsXG4gIG5vdEJ5dGVzLFxuICBub3RMZW5ndGgsXG4gIG5vdFNpemUsXG4gIG5vdFZhbHVlLFxuICBudWxsXyBhcyBudWxsLFxuICBudWxsXyxcbiAgbnVsbGFibGUsXG4gIG51bGxhYmxlQXN5bmMsXG4gIG51bGxpc2gsXG4gIG51bGxpc2hBc3luYyxcbiAgbnVtYmVyLFxuICBvYmplY3QsXG4gIG9iamVjdEFzeW5jLFxuICBvYmplY3RXaXRoUmVzdCxcbiAgb2JqZWN0V2l0aFJlc3RBc3luYyxcbiAgb2N0YWwsXG4gIG9taXQsXG4gIG9wdGlvbmFsLFxuICBvcHRpb25hbEFzeW5jLFxuICBwYXJzZSxcbiAgcGFyc2VBc3luYyxcbiAgcGFyc2VyLFxuICBwYXJzZXJBc3luYyxcbiAgcGFydGlhbCxcbiAgcGFydGlhbEFzeW5jLFxuICBwYXJ0aWFsQ2hlY2ssXG4gIHBhcnRpYWxDaGVja0FzeW5jLFxuICBwaWNrLFxuICBwaWNrbGlzdCxcbiAgcGlwZSxcbiAgcGlwZUFzeW5jLFxuICBwcm9taXNlLFxuICByYXdDaGVjayxcbiAgcmF3Q2hlY2tBc3luYyxcbiAgcmF3VHJhbnNmb3JtLFxuICByYXdUcmFuc2Zvcm1Bc3luYyxcbiAgcmVhZG9ubHksXG4gIHJlY29yZCxcbiAgcmVjb3JkQXN5bmMsXG4gIHJlZHVjZUl0ZW1zLFxuICByZWdleCxcbiAgcmVxdWlyZWQsXG4gIHJlcXVpcmVkQXN5bmMsXG4gIHNhZmVJbnRlZ2VyLFxuICBzYWZlUGFyc2UsXG4gIHNhZmVQYXJzZUFzeW5jLFxuICBzYWZlUGFyc2VyLFxuICBzYWZlUGFyc2VyQXN5bmMsXG4gIHNldCxcbiAgc2V0QXN5bmMsXG4gIHNldEdsb2JhbENvbmZpZyxcbiAgc2V0R2xvYmFsTWVzc2FnZSxcbiAgc2V0U2NoZW1hTWVzc2FnZSxcbiAgc2V0U3BlY2lmaWNNZXNzYWdlLFxuICBzaXplLFxuICBzb21lSXRlbSxcbiAgc29ydEl0ZW1zLFxuICBzdGFydHNXaXRoLFxuICBzdHJpY3RPYmplY3QsXG4gIHN0cmljdE9iamVjdEFzeW5jLFxuICBzdHJpY3RUdXBsZSxcbiAgc3RyaWN0VHVwbGVBc3luYyxcbiAgc3RyaW5nLFxuICBzeW1ib2wsXG4gIHRvTG93ZXJDYXNlLFxuICB0b01heFZhbHVlLFxuICB0b01pblZhbHVlLFxuICB0b1VwcGVyQ2FzZSxcbiAgdHJhbnNmb3JtLFxuICB0cmFuc2Zvcm1Bc3luYyxcbiAgdHJpbSxcbiAgdHJpbUVuZCxcbiAgdHJpbVN0YXJ0LFxuICB0dXBsZSxcbiAgdHVwbGVBc3luYyxcbiAgdHVwbGVXaXRoUmVzdCxcbiAgdHVwbGVXaXRoUmVzdEFzeW5jLFxuICB1bGlkLFxuICB1bmRlZmluZWRfIGFzIHVuZGVmaW5lZCxcbiAgdW5kZWZpbmVkXyxcbiAgdW5pb24sXG4gIHVuaW9uQXN5bmMsXG4gIHVua25vd24sXG4gIHVud3JhcCxcbiAgdXJsLFxuICB1dWlkLFxuICB2YWx1ZSxcbiAgdmFyaWFudCxcbiAgdmFyaWFudEFzeW5jLFxuICB2b2lkXyBhcyB2b2lkLFxuICB2b2lkX1xufTtcbiJdLCJuYW1lcyI6WyJhd2FpdEFzeW5jIiwia2luZCIsInR5cGUiLCJyZWZlcmVuY2UiLCJhc3luYyIsIl9ydW4iLCJkYXRhc2V0IiwidmFsdWUiLCJCSUNfUkVHRVgiLCJDVUlEMl9SRUdFWCIsIkRFQ0lNQUxfUkVHRVgiLCJFTUFJTF9SRUdFWCIsIkVNT0pJX1JFR0VYIiwiSEVYQURFQ0lNQUxfUkVHRVgiLCJIRVhfQ09MT1JfUkVHRVgiLCJJTUVJX1JFR0VYIiwiSVBWNF9SRUdFWCIsIklQVjZfUkVHRVgiLCJJUF9SRUdFWCIsIklTT19EQVRFX1JFR0VYIiwiSVNPX0RBVEVfVElNRV9SRUdFWCIsIklTT19USU1FX1JFR0VYIiwiSVNPX1RJTUVfU0VDT05EX1JFR0VYIiwiSVNPX1RJTUVTVEFNUF9SRUdFWCIsIklTT19XRUVLX1JFR0VYIiwiTUFDNDhfUkVHRVgiLCJNQUM2NF9SRUdFWCIsIk1BQ19SRUdFWCIsIk9DVEFMX1JFR0VYIiwiVUxJRF9SRUdFWCIsIlVVSURfUkVHRVgiLCJzdG9yZSIsInNldEdsb2JhbENvbmZpZyIsImNvbmZpZzIiLCJnZXRHbG9iYWxDb25maWciLCJsYW5nIiwibWVzc2FnZSIsImFib3J0RWFybHkiLCJhYm9ydFBpcGVFYXJseSIsImRlbGV0ZUdsb2JhbENvbmZpZyIsInN0b3JlMiIsInNldEdsb2JhbE1lc3NhZ2UiLCJNYXAiLCJzZXQiLCJnZXRHbG9iYWxNZXNzYWdlIiwiZ2V0IiwiZGVsZXRlR2xvYmFsTWVzc2FnZSIsImRlbGV0ZSIsInN0b3JlMyIsInNldFNjaGVtYU1lc3NhZ2UiLCJnZXRTY2hlbWFNZXNzYWdlIiwiZGVsZXRlU2NoZW1hTWVzc2FnZSIsInN0b3JlNCIsInNldFNwZWNpZmljTWVzc2FnZSIsImdldFNwZWNpZmljTWVzc2FnZSIsImRlbGV0ZVNwZWNpZmljTWVzc2FnZSIsIl9zdHJpbmdpZnkiLCJpbnB1dCIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2FkZElzc3VlIiwiY29udGV4dCIsImxhYmVsIiwib3RoZXIiLCJleHBlY3RlZCIsImV4cGVjdHMiLCJyZWNlaXZlZCIsImlzc3VlIiwicmVxdWlyZW1lbnQiLCJwYXRoIiwiaXNzdWVzIiwiaXNTY2hlbWEiLCJ0eXBlZCIsInB1c2giLCJOT05fRElHSVRfUkVHRVgiLCJfaXNMdWhuQWxnbyIsIm51bWJlcjIiLCJyZXBsYWNlIiwibGVuZ3RoMiIsImxlbmd0aCIsImJpdCIsInN1bSIsInZhbHVlMiIsIl9pc1ZhbGlkT2JqZWN0S2V5Iiwib2JqZWN0MiIsImtleSIsImhhc093biIsImVudHJpZXNGcm9tTGlzdCIsImxpc3QiLCJzY2hlbWEiLCJlbnRyaWVzIiwiZ2V0RG90UGF0aCIsIml0ZW0iLCJpc09mS2luZCIsImlzT2ZUeXBlIiwiaXNWYWxpRXJyb3IiLCJlcnJvciIsIlZhbGlFcnJvciIsIkVycm9yIiwiYmljIiwidGVzdCIsImJyYW5kIiwiYnl0ZXMiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImNoZWNrIiwiY2hlY2tBc3luYyIsImNoZWNrSXRlbXMiLCJpbmRleCIsIm9yaWdpbiIsIkNSRURJVF9DQVJEX1JFR0VYIiwiU0FOSVRJWkVfUkVHRVgiLCJQUk9WSURFUl9SRUdFWF9MSVNUIiwiY3JlZGl0Q2FyZCIsInNhbml0aXplZCIsInNvbWUiLCJyZWdleDIiLCJjdWlkMiIsImRlY2ltYWwiLCJlbWFpbCIsImVtb2ppIiwiZW1wdHkiLCJlbmRzV2l0aCIsInNsaWNlIiwiZXZlcnlJdGVtIiwiZXZlcnkiLCJleGNsdWRlcyIsImluY2x1ZGVzIiwiZmlsdGVySXRlbXMiLCJvcGVyYXRpb24iLCJmaWx0ZXIiLCJmaW5kSXRlbSIsImZpbmQiLCJmaW5pdGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkhBU0hfTEVOR1RIUyIsIm1kNCIsIm1kNSIsInNoYTEiLCJzaGEyNTYiLCJzaGEzODQiLCJzaGE1MTIiLCJyaXBlbWQxMjgiLCJyaXBlbWQxNjAiLCJ0aWdlcjEyOCIsInRpZ2VyMTYwIiwidGlnZXIxOTIiLCJjcmMzMiIsImNyYzMyYiIsImFkbGVyMzIiLCJoYXNoIiwidHlwZXMiLCJSZWdFeHAiLCJtYXAiLCJqb2luIiwiaGV4YWRlY2ltYWwiLCJoZXhDb2xvciIsImltZWkiLCJpbnRlZ2VyIiwiaXNJbnRlZ2VyIiwiaXAiLCJpcHY0IiwiaXB2NiIsImlzb0RhdGUiLCJpc29EYXRlVGltZSIsImlzb1RpbWUiLCJpc29UaW1lU2Vjb25kIiwiaXNvVGltZXN0YW1wIiwiaXNvV2VlayIsIm1hYyIsIm1hYzQ4IiwibWFjNjQiLCJtYXBJdGVtcyIsIm1heEJ5dGVzIiwibWF4TGVuZ3RoIiwibWF4U2l6ZSIsInNpemUiLCJtYXhWYWx1ZSIsIkRhdGUiLCJ0b0pTT04iLCJtaW1lVHlwZSIsIm9wdGlvbiIsIm1pbkJ5dGVzIiwibWluTGVuZ3RoIiwibWluU2l6ZSIsIm1pblZhbHVlIiwibXVsdGlwbGVPZiIsIm5vbkVtcHR5Iiwibm9ybWFsaXplIiwiZm9ybSIsIm5vdEJ5dGVzIiwibm90TGVuZ3RoIiwibm90U2l6ZSIsIm5vdFZhbHVlIiwib2N0YWwiLCJfaXNQYXJ0aWFsbHlUeXBlZCIsInBhdGhMaXN0IiwiYm91bmQiLCJNYXRoIiwibWluIiwicGFydGlhbENoZWNrIiwicGFydGlhbENoZWNrQXN5bmMiLCJyYXdDaGVjayIsImFjdGlvbiIsImNvbmZpZyIsImFkZElzc3VlIiwiaW5mbyIsInJhd0NoZWNrQXN5bmMiLCJyYXdUcmFuc2Zvcm0iLCJvdXRwdXQiLCJORVZFUiIsInJhd1RyYW5zZm9ybUFzeW5jIiwicmVhZG9ubHkiLCJyZWR1Y2VJdGVtcyIsImluaXRpYWwiLCJyZWR1Y2UiLCJyZWdleCIsInNhZmVJbnRlZ2VyIiwiaXNTYWZlSW50ZWdlciIsInNvbWVJdGVtIiwic29ydEl0ZW1zIiwic29ydCIsInN0YXJ0c1dpdGgiLCJ0b0xvd2VyQ2FzZSIsInRvTWF4VmFsdWUiLCJ0b01pblZhbHVlIiwidG9VcHBlckNhc2UiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Bc3luYyIsInRyaW0iLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidWxpZCIsInVybCIsIlVSTCIsInV1aWQiLCJjb25maWdfIiwiZ2V0RmFsbGJhY2siLCJmYWxsYmFjayIsImZhbGxiYWNrMiIsImZhbGxiYWNrQXN5bmMiLCJmbGF0dGVuIiwiZmxhdEVycm9ycyIsImRvdFBhdGgiLCJuZXN0ZWQiLCJyb290IiwiZm9yd2FyZCIsInBhdGhLZXlzIiwicHJldklzc3VlcyIsInBhdGhJbnB1dCIsInBhdGhWYWx1ZSIsInBhdGhJdGVtIiwiZm9yd2FyZEFzeW5jIiwiZ2V0RGVmYXVsdCIsImRlZmF1bHQiLCJnZXREZWZhdWx0cyIsIml0ZW1zIiwiZ2V0RGVmYXVsdHNBc3luYyIsImZyb21FbnRyaWVzIiwiUHJvbWlzZSIsImFsbCIsImdldEZhbGxiYWNrcyIsImdldEZhbGxiYWNrc0FzeW5jIiwiaXMiLCJhbnkiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW1EYXRhc2V0IiwidW5zaGlmdCIsImFycmF5QXN5bmMiLCJpdGVtRGF0YXNldHMiLCJiaWdpbnQiLCJibG9iIiwiQmxvYiIsImJvb2xlYW4iLCJjdXN0b20iLCJjaGVjazIiLCJjdXN0b21Bc3luYyIsImRhdGUiLCJpc05hTiIsImVudW1fIiwiZW51bV9fIiwib3B0aW9ucyIsImVudW0iLCJmaWxlIiwiRmlsZSIsImZ1bmN0aW9uXyIsImluc3RhbmNlIiwiY2xhc3NfIiwiY2xhc3MiLCJfbWVyZ2UiLCJ2YWx1ZTEiLCJpbnRlcnNlY3QiLCJTZXQiLCJvdXRwdXRzIiwib3B0aW9uRGF0YXNldCIsIm1lcmdlRGF0YXNldCIsImludGVyc2VjdEFzeW5jIiwib3B0aW9uRGF0YXNldHMiLCJsYXp5IiwiZ2V0dGVyIiwibGF6eUFzeW5jIiwibGl0ZXJhbCIsImxpdGVyYWxfIiwibG9vc2VPYmplY3QiLCJ2YWx1ZURhdGFzZXQiLCJsb29zZU9iamVjdEFzeW5jIiwidmFsdWVEYXRhc2V0cyIsImxvb3NlVHVwbGUiLCJsb29zZVR1cGxlQXN5bmMiLCJpbnB1dEtleSIsImlucHV0VmFsdWUiLCJrZXlEYXRhc2V0IiwibWFwQXN5bmMiLCJkYXRhc2V0cyIsIm5hbiIsIm5ldmVyIiwibm9uTnVsbGFibGUiLCJ3cmFwcGVkIiwibm9uTnVsbGFibGVBc3luYyIsIm5vbk51bGxpc2giLCJub25OdWxsaXNoQXN5bmMiLCJub25PcHRpb25hbCIsIm5vbk9wdGlvbmFsQXN5bmMiLCJudWxsXyIsIm51bGxhYmxlIiwiYXJncyIsIm51bGxhYmxlQXN5bmMiLCJudWxsaXNoIiwibnVsbGlzaEFzeW5jIiwibnVtYmVyIiwib2JqZWN0Iiwib2JqZWN0QXN5bmMiLCJvYmplY3RXaXRoUmVzdCIsInJlc3QiLCJvYmplY3RXaXRoUmVzdEFzeW5jIiwibm9ybWFsRGF0YXNldHMiLCJyZXN0RGF0YXNldHMiLCJvcHRpb25hbCIsIm9wdGlvbmFsQXN5bmMiLCJwaWNrbGlzdCIsInByb21pc2UiLCJyZWNvcmQiLCJlbnRyeUtleSIsImVudHJ5VmFsdWUiLCJyZWNvcmRBc3luYyIsImtleTIiLCJhZGQiLCJzZXRBc3luYyIsInN0cmljdE9iamVjdCIsInN0cmljdE9iamVjdEFzeW5jIiwic3RyaWN0VHVwbGUiLCJzdHJpY3RUdXBsZUFzeW5jIiwic3RyaW5nIiwic3ltYm9sIiwidHVwbGUiLCJ0dXBsZUFzeW5jIiwidHVwbGVXaXRoUmVzdCIsInR1cGxlV2l0aFJlc3RBc3luYyIsInVuZGVmaW5lZF8iLCJfc3ViSXNzdWVzIiwidW5pb24iLCJ2YWxpZERhdGFzZXQiLCJ0eXBlZERhdGFzZXRzIiwidW50eXBlZERhdGFzZXRzIiwidW5pb25Bc3luYyIsInVua25vd24iLCJfZGlzY3JpbWluYXRvcnMiLCJzZXQyIiwidmFyaWFudCIsImV4cGVjdGVkRGlzY3JpbWluYXRvcnMiLCJkaXNjcmltaW5hdG9yIiwib3V0cHV0RGF0YXNldCIsInZhcmlhbnRBc3luYyIsInZvaWRfIiwia2V5b2YiLCJrZXlzIiwib21pdCIsInBhcnNlIiwicGFyc2VBc3luYyIsInBhcnNlciIsImZ1bmMiLCJwYXJzZXJBc3luYyIsInBhcnRpYWwiLCJwYXJ0aWFsQXN5bmMiLCJwaWNrIiwicGlwZSIsInBpcGUyIiwicGlwZUFzeW5jIiwicmVxdWlyZWQiLCJhcmcyIiwiYXJnMyIsInJlcXVpcmVkQXN5bmMiLCJzYWZlUGFyc2UiLCJzdWNjZXNzIiwic2FmZVBhcnNlQXN5bmMiLCJzYWZlUGFyc2VyIiwic2FmZVBhcnNlckFzeW5jIiwidW53cmFwIiwiZnVuY3Rpb24iLCJudWxsIiwidW5kZWZpbmVkIiwidm9pZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valibot/dist/index.js\n");

/***/ })

};
;