"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr)) return false;\n    if (arr.length === 0) return true;\n    if (isString) {\n        return arr.every((item)=>typeof item === \"string\");\n    } else {\n        return arr.every((item)=>Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== \"function\") throw new Error(\"function expected\");\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== \"string\") throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\nconst assertNumber = anumber;\nfunction aArr(input) {\n    if (!Array.isArray(input)) throw new Error(\"array expected\");\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === \"string\" ? letters.split(\"\") : letters;\n    const len = lettersA.length;\n    astrArr(\"alphabet\", lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i)=>[\n            l,\n            i\n        ]));\n    return {\n        encode: (digits)=>{\n            aArr(digits);\n            return digits.map((i)=>{\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input)=>{\n            aArr(input);\n            return input.map((letter)=>{\n                astr(\"alphabet.decode\", letter);\n                const i = indexes.get(letter);\n                if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    astr(\"join\", separator);\n    return {\n        encode: (from)=>{\n            astrArr(\"join.decode\", from);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            astr(\"join.decode\", to);\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    anumber(bits);\n    astr(\"padding\", chr);\n    return {\n        encode (data) {\n            astrArr(\"padding.encode\", data);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            astrArr(\"padding.decode\", input);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"padding: invalid, string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0) throw new Error(\"padding: invalid, string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    afn(fn);\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d)=>{\n        anumber(d);\n        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < dlen; i++){\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (()=>{\n    let res = [];\n    for(let i = 0; i < 40; i++)res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */ function convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data){\n        anumber(n);\n        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined) throw new Error(\"invalid carry\");\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits)=>{\n            anumArr(\"radix.decode\", digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            anumArr(\"radix2.decode\", digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding.\n */ const base16 = chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nconst base32 = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nconst base32nopad = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), join(\"\"));\nconst base32hex = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nconst base32hexnopad = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), join(\"\"));\nconst base32crockford = chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\n/**\n * base64 with padding. For no padding, use `base64nopad`.\n * @example\n * const b = base64.decode('A951'); // Uint8Array.from([ 3, 222, 117 ])\n * base64.encode(b); // 'A951'\n */ const base64 = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\n/**\n * base64 without padding.\n */ const base64nopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), join(\"\"));\nconst base64url = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nconst base64urlnopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\n/**\n * Base58: base64 without characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n */ const base58 = genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nconst base58flickr = genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nconst base58xrp = genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\n/**\n * XMR version of base58.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */ const base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */ const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % powers[30]\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr(\"bech32.encode prefix\", prefix);\n        if (isBytes(words)) words = Array.from(words);\n        anumArr(\"bech32.encode\", words);\n        const plen = prefix.length;\n        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr(\"bech32.decode input\", str);\n        const slen = str.length;\n        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\n/**\n * Low-level bech32 operations. Operates on words.\n */ const bech32 = genBech32(\"bech32\");\nconst bech32m = genBech32(\"bech32m\");\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n */ const utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\n/**\n * hex string decoder.\n * @example\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n */ const hex = chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtFQUFrRSxHQUNsRSxTQUFTQSxRQUFRQyxDQUFDO0lBQ2QsT0FBT0EsYUFBYUMsY0FBZUMsWUFBWUMsTUFBTSxDQUFDSCxNQUFNQSxFQUFFSSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN2RjtBQUNBLFNBQVNDLFVBQVVDLFFBQVEsRUFBRUMsR0FBRztJQUM1QixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsTUFDZixPQUFPO0lBQ1gsSUFBSUEsSUFBSUcsTUFBTSxLQUFLLEdBQ2YsT0FBTztJQUNYLElBQUlKLFVBQVU7UUFDVixPQUFPQyxJQUFJSSxLQUFLLENBQUMsQ0FBQ0MsT0FBUyxPQUFPQSxTQUFTO0lBQy9DLE9BQ0s7UUFDRCxPQUFPTCxJQUFJSSxLQUFLLENBQUMsQ0FBQ0MsT0FBU0MsT0FBT0MsYUFBYSxDQUFDRjtJQUNwRDtBQUNKO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVNHLElBQUlDLEtBQUs7SUFDZCxJQUFJLE9BQU9BLFVBQVUsWUFDakIsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLE9BQU87QUFDWDtBQUNBLFNBQVNDLEtBQUtDLEtBQUssRUFBRUgsS0FBSztJQUN0QixJQUFJLE9BQU9BLFVBQVUsVUFDakIsTUFBTSxJQUFJQyxNQUFNLENBQUMsRUFBRUUsTUFBTSxpQkFBaUIsQ0FBQztJQUMvQyxPQUFPO0FBQ1g7QUFDQSxTQUFTQyxRQUFRQyxDQUFDO0lBQ2QsSUFBSSxDQUFDUixPQUFPQyxhQUFhLENBQUNPLElBQ3RCLE1BQU0sSUFBSUosTUFBTSxDQUFDLGlCQUFpQixFQUFFSSxFQUFFLENBQUM7QUFDL0M7QUFDTyxNQUFNQyxlQUFlRixRQUFRO0FBQ3BDLFNBQVNHLEtBQUtQLEtBQUs7SUFDZixJQUFJLENBQUNSLE1BQU1DLE9BQU8sQ0FBQ08sUUFDZixNQUFNLElB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InNvdXJjZXMiOlsid2VicGFjazovL3N1aXNvdW5kLWFnZW50Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanM/ZTc5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuZnVuY3Rpb24gaXNBcnJheU9mKGlzU3RyaW5nLCBhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFyci5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcnIuZXZlcnkoKGl0ZW0pID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKTtcbiAgICB9XG59XG4vLyBubyBhYnl0ZXM6IHNlZW1zIHRvIGhhdmUgMTAlIHNsb3dkb3duLiBXaHk/IVxuZnVuY3Rpb24gYWZuKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBleHBlY3RlZCcpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXN0cihsYWJlbCwgaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfTogc3RyaW5nIGV4cGVjdGVkYCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0IGNvbnN0IGFzc2VydE51bWJlciA9IGFudW1iZXI7XG5mdW5jdGlvbiBhQXJyKGlucHV0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYXN0ckFycihsYWJlbCwgaW5wdXQpIHtcbiAgICBpZiAoIWlzQXJyYXlPZih0cnVlLCBpbnB1dCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IGFycmF5IG9mIHN0cmluZ3MgZXhwZWN0ZWRgKTtcbn1cbmZ1bmN0aW9uIGFudW1BcnIobGFiZWwsIGlucHV0KSB7XG4gICAgaWYgKCFpc0FycmF5T2YoZmFsc2UsIGlucHV0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfTogYXJyYXkgb2YgbnVtYmVycyBleHBlY3RlZGApO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgY29uc3QgaWQgPSAoYSkgPT4gYTtcbiAgICAvLyBXcmFwIGNhbGwgaW4gY2xvc3VyZSBzbyBKSVQgY2FuIGlubGluZSBjYWxsc1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbLTFdLmVuY29kZShhcmdzWy0yXS5lbmNvZGUoWy4uLl0pKVxuICAgIGNvbnN0IGVuY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmVuY29kZSkucmVkdWNlUmlnaHQod3JhcCwgaWQpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWzBdLmRlY29kZShhcmdzWzFdLmRlY29kZSguLi4pKVxuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmRlY29kZSkucmVkdWNlKHdyYXAsIGlkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGludGVnZXIgcmFkaXggcmVwcmVzZW50YXRpb24gdG8gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhbHBoYWJldCBhbmQgYmFjay5cbiAqIENvdWxkIGFsc28gYmUgYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFscGhhYmV0KGxldHRlcnMpIHtcbiAgICAvLyBtYXBwaW5nIDEgdG8gXCJiXCJcbiAgICBjb25zdCBsZXR0ZXJzQSA9IHR5cGVvZiBsZXR0ZXJzID09PSAnc3RyaW5nJyA/IGxldHRlcnMuc3BsaXQoJycpIDogbGV0dGVycztcbiAgICBjb25zdCBsZW4gPSBsZXR0ZXJzQS5sZW5ndGg7XG4gICAgYXN0ckFycignYWxwaGFiZXQnLCBsZXR0ZXJzQSk7XG4gICAgLy8gbWFwcGluZyBcImJcIiB0byAxXG4gICAgY29uc3QgaW5kZXhlcyA9IG5ldyBNYXAobGV0dGVyc0EubWFwKChsLCBpKSA9PiBbbCwgaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGFBcnIoZGlnaXRzKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpKSB8fCBpIDwgMCB8fCBpID49IGxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5lbmNvZGU6IGRpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQgXCIke2l9XCIuIEFsbG93ZWQ6ICR7bGV0dGVyc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGV0dGVyc0FbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGFBcnIoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgYXN0cignYWxwaGFiZXQuZGVjb2RlJywgbGV0dGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gaW5kZXhlcy5nZXQobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2xldHRlcnN9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgYXN0cignam9pbicsIHNlcGFyYXRvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgYXN0ckFycignam9pbi5kZWNvZGUnLCBmcm9tKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGFzdHIoJ2pvaW4uZGVjb2RlJywgdG8pO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGFkIHN0cmluZ3MgYXJyYXkgc28gaXQgaGFzIGludGVnZXIgbnVtYmVyIG9mIGJpdHNcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYW51bWJlcihiaXRzKTtcbiAgICBhc3RyKCdwYWRkaW5nJywgY2hyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgYXN0ckFycigncGFkZGluZy5lbmNvZGUnLCBkYXRhKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBhc3RyQXJyKCdwYWRkaW5nLmRlY29kZScsIGlucHV0KTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmc6IGludmFsaWQsIHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGVuZCAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZSA9IGxhc3QgKiBiaXRzO1xuICAgICAgICAgICAgICAgIGlmIChieXRlICUgOCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nOiBpbnZhbGlkLCBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGFmbihmbik7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIC8vIGJhc2UgMSBpcyBpbXBvc3NpYmxlXG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogaW52YWxpZCBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IGludmFsaWQgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgYUFycihkYXRhKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhLCAoZCkgPT4ge1xuICAgICAgICBhbnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGludGVnZXI6ICR7ZH1gKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG4gICAgY29uc3QgZGxlbiA9IGRpZ2l0cy5sZW5ndGg7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGZyb21DYXJyeSA9IGZyb20gKiBjYXJyeTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb21DYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgZnJvbUNhcnJ5IC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbUNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXYgPSBkaWdpdEJhc2UgLyB0bztcbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gTWF0aC5mbG9vcihkaXYpO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gcm91bmRlZDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocm91bmRlZCkgfHwgcm91bmRlZCAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3VuZGVkKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IChhLCBiKSA9PiAoYiA9PT0gMCA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG5jb25zdCBwb3dlcnMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKVxuICAgICAgICByZXMucHVzaCgyICoqIGkpO1xuICAgIHJldHVybiByZXM7XG59KSgpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgYUFycihkYXRhKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDsgLy8gYml0d2lzZSBwb3NpdGlvbiBpbiBjdXJyZW50IGVsZW1lbnRcbiAgICBjb25zdCBtYXggPSBwb3dlcnNbZnJvbV07XG4gICAgY29uc3QgbWFzayA9IHBvd2Vyc1t0b10gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFudW1iZXIobik7XG4gICAgICAgIGlmIChuID49IG1heClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY29uc3QgcG93ID0gcG93ZXJzW3Bvc107XG4gICAgICAgIGlmIChwb3cgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjYXJyeScpO1xuICAgICAgICBjYXJyeSAmPSBwb3cgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSA+IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYW51bWJlcihudW0pO1xuICAgIGNvbnN0IF8yNTYgPSAyICoqIDg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIF8yNTYsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgYW51bUFycigncmFkaXguZGVjb2RlJywgZGlnaXRzKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCBfMjU2KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogSWYgYm90aCBiYXNlcyBhcmUgcG93ZXIgb2Ygc2FtZSBudW1iZXIgKGxpa2UgYDIqKjggPC0+IDIqKjY0YCksXG4gKiB0aGVyZSBpcyBhIGxpbmVhciBhbGdvcml0aG0uIEZvciBub3cgd2UgaGF2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgcG93ZXItb2YtdHdvIGJhc2VzIG9ubHkuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYW51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgYW51bUFycigncmFkaXgyLmRlY29kZScsIGRpZ2l0cyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBhZm4oZm4pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFudW1iZXIobGVuKTtcbiAgICBhZm4oZm4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICAgIGFscGhhYmV0LCBjaGFpbiwgY2hlY2tzdW0sIGNvbnZlcnRSYWRpeCwgY29udmVydFJhZGl4MiwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyxcbn07XG4vLyBSRkMgNDY0OCBha2EgUkZDIDM1NDhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBiYXNlMTYgZW5jb2RpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzIgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMybm9wYWQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleG5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmNyb2NrZm9yZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG4vKipcbiAqIGJhc2U2NCB3aXRoIHBhZGRpbmcuIEZvciBubyBwYWRkaW5nLCB1c2UgYGJhc2U2NG5vcGFkYC5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCBiID0gYmFzZTY0LmRlY29kZSgnQTk1MScpOyAvLyBVaW50OEFycmF5LmZyb20oWyAzLCAyMjIsIDExNyBdKVxuICogYmFzZTY0LmVuY29kZShiKTsgLy8gJ0E5NTEnXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTY0IHdpdGhvdXQgcGFkZGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsbm9wYWQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG4vKipcbiAqIEJhc2U1ODogYmFzZTY0IHdpdGhvdXQgY2hhcmFjdGVycyArLCAvLCAwLCBPLCBJLCBsLlxuICogUXVhZHJhdGljIChPKG5eMikpIC0gc28sIGNhbid0IGJlIHVzZWQgb24gbGFyZ2UgaW5wdXRzLlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4ID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5leHBvcnQgY29uc3QgYmFzZTU4ZmxpY2tyID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyBEYXRhIGxlbiAoaW5kZXgpIC0+IGVuY29kZWQgYmxvY2sgbGVuXG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG4vKipcbiAqIFhNUiB2ZXJzaW9uIG9mIGJhc2U1OC5cbiAqIERvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4gKiBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBjcmVhdGVCYXNlNThjaGVjayA9IChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGJhc2U1OCk7XG4vKipcbiAqIFVzZSBgY3JlYXRlQmFzZTU4Y2hlY2tgIGluc3RlYWQuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgZW5jb2RpbmdDb25zdCA9IDEpIHtcbiAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJlZml4ICgke3ByZWZpeH0pYCk7XG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gICAgZm9yIChsZXQgdiBvZiB3b3JkcylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICAgIHJldHVybiBCRUNIX0FMUEhBQkVULmVuY29kZShjb252ZXJ0UmFkaXgyKFtjaGsgJSBwb3dlcnNbMzBdXSwgMzAsIDUsIGZhbHNlKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGFzdHIoJ2JlY2gzMi5lbmNvZGUgcHJlZml4JywgcHJlZml4KTtcbiAgICAgICAgaWYgKGlzQnl0ZXMod29yZHMpKVxuICAgICAgICAgICAgd29yZHMgPSBBcnJheS5mcm9tKHdvcmRzKTtcbiAgICAgICAgYW51bUFycignYmVjaDMyLmVuY29kZScsIHdvcmRzKTtcbiAgICAgICAgY29uc3QgcGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgICAgIGlmIChwbGVuID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcmVmaXggbGVuZ3RoICR7cGxlbn1gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcGxlbiArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0obG93ZXJlZCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgcmV0dXJuIGAke2xvd2VyZWR9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7c3VtfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgYXN0cignYmVjaDMyLmRlY29kZSBpbnB1dCcsIHN0cik7XG4gICAgICAgIGNvbnN0IHNsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICBpZiAoc2xlbiA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzbGVuID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBzdHJpbmcgbGVuZ3RoOiAke3NsZW59ICgke3N0cn0pLiBFeHBlY3RlZCAoOC4uJHtsaW1pdH0pYCk7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBsb3dlcmVkLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBsb3dlcmVkLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGxvd2VyZWQuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoZGF0YSkuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIWRhdGEuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUZyb21CeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUocHJlZml4LCB0b1dvcmRzKGJ5dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGVGcm9tQnl0ZXMsXG4gICAgICAgIGRlY29kZVRvQnl0ZXMsXG4gICAgICAgIGRlY29kZVVuc2FmZSxcbiAgICAgICAgZnJvbVdvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIHRvV29yZHMsXG4gICAgfTtcbn1cbi8qKlxuICogTG93LWxldmVsIGJlY2gzMiBvcGVyYXRpb25zLiBPcGVyYXRlcyBvbiB3b3Jkcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGJlY2gzMiA9IGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnQgY29uc3QgYmVjaDMybSA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuLyoqXG4gKiBVVEYtOC10by1ieXRlIGRlY29kZXIuIFVzZXMgYnVpbHQtaW4gVGV4dERlY29kZXIgLyBUZXh0RW5jb2Rlci5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCBiID0gdXRmOC5kZWNvZGUoXCJoZXlcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMTA0LCAxMDEsIDEyMSBdKVxuICogY29uc3Qgc3RyID0gdXRmOC5lbmNvZGUoYik7IC8vIFwiaGV5XCJcbiAqL1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuLyoqXG4gKiBoZXggc3RyaW5nIGRlY29kZXIuXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYiA9IGhleC5kZWNvZGUoXCIwMTAyZmZcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMSwgMiwgMjU1IF0pXG4gKiBjb25zdCBzdHIgPSBoZXguZW5jb2RlKGIpOyAvLyBcIjAxMDJmZlwiXG4gKi9cbmV4cG9ydCBjb25zdCBoZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImlzQXJyYXlPZiIsImlzU3RyaW5nIiwiYXJyIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZXZlcnkiLCJpdGVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImFmbiIsImlucHV0IiwiRXJyb3IiLCJhc3RyIiwibGFiZWwiLCJhbnVtYmVyIiwibiIsImFzc2VydE51bWJlciIsImFBcnIiLCJhc3RyQXJyIiwiYW51bUFyciIsImNoYWluIiwiYXJncyIsImlkIiwid3JhcCIsImIiLCJjIiwiZW5jb2RlIiwibWFwIiwieCIsInJlZHVjZVJpZ2h0IiwiZGVjb2RlIiwicmVkdWNlIiwiYWxwaGFiZXQiLCJsZXR0ZXJzIiwibGV0dGVyc0EiLCJzcGxpdCIsImxlbiIsImluZGV4ZXMiLCJNYXAiLCJsIiwiaSIsImRpZ2l0cyIsImxldHRlciIsImdldCIsInVuZGVmaW5lZCIsImpvaW4iLCJzZXBhcmF0b3IiLCJmcm9tIiwidG8iLCJwYWRkaW5nIiwiYml0cyIsImNociIsImRhdGEiLCJwdXNoIiwiZW5kIiwibGFzdCIsImJ5dGUiLCJzbGljZSIsIm5vcm1hbGl6ZSIsImZuIiwiY29udmVydFJhZGl4IiwicG9zIiwicmVzIiwiZCIsImRsZW4iLCJjYXJyeSIsImRvbmUiLCJkaWdpdCIsImZyb21DYXJyeSIsImRpZ2l0QmFzZSIsImRpdiIsInJvdW5kZWQiLCJNYXRoIiwiZmxvb3IiLCJyZXZlcnNlIiwiZ2NkIiwicmFkaXgyY2FycnkiLCJwb3dlcnMiLCJjb252ZXJ0UmFkaXgyIiwibWF4IiwibWFzayIsInBvdyIsInJhZGl4IiwibnVtIiwiXzI1NiIsImJ5dGVzIiwicmFkaXgyIiwicmV2UGFkZGluZyIsInVuc2FmZVdyYXBwZXIiLCJhcHBseSIsImUiLCJjaGVja3N1bSIsInN1bSIsInNldCIsInBheWxvYWQiLCJvbGRDaGVja3N1bSIsIm5ld0NoZWNrc3VtIiwidXRpbHMiLCJiYXNlMTYiLCJiYXNlMzIiLCJiYXNlMzJub3BhZCIsImJhc2UzMmhleCIsImJhc2UzMmhleG5vcGFkIiwiYmFzZTMyY3JvY2tmb3JkIiwicyIsInRvVXBwZXJDYXNlIiwicmVwbGFjZSIsImJhc2U2NCIsImJhc2U2NG5vcGFkIiwiYmFzZTY0dXJsIiwiYmFzZTY0dXJsbm9wYWQiLCJnZW5CYXNlNTgiLCJhYmMiLCJiYXNlNTgiLCJiYXNlNThmbGlja3IiLCJiYXNlNTh4cnAiLCJYTVJfQkxPQ0tfTEVOIiwiYmFzZTU4eG1yIiwiYmxvY2siLCJzdWJhcnJheSIsInBhZFN0YXJ0Iiwic3RyIiwiYmxvY2tMZW4iLCJpbmRleE9mIiwiaiIsImNvbmNhdCIsImNyZWF0ZUJhc2U1OGNoZWNrIiwic2hhMjU2IiwiYmFzZTU4Y2hlY2siLCJCRUNIX0FMUEhBQkVUIiwiUE9MWU1PRF9HRU5FUkFUT1JTIiwiYmVjaDMyUG9seW1vZCIsInByZSIsImNoayIsImJlY2hDaGVja3N1bSIsInByZWZpeCIsIndvcmRzIiwiZW5jb2RpbmdDb25zdCIsImNoYXJDb2RlQXQiLCJ2IiwiZ2VuQmVjaDMyIiwiZW5jb2RpbmciLCJFTkNPRElOR19DT05TVCIsIl93b3JkcyIsImZyb21Xb3JkcyIsInRvV29yZHMiLCJmcm9tV29yZHNVbnNhZmUiLCJsaW1pdCIsInBsZW4iLCJUeXBlRXJyb3IiLCJhY3R1YWxMZW5ndGgiLCJsb3dlcmVkIiwidG9Mb3dlckNhc2UiLCJzbGVuIiwic2VwSW5kZXgiLCJsYXN0SW5kZXhPZiIsImVuZHNXaXRoIiwiZGVjb2RlVW5zYWZlIiwiZGVjb2RlVG9CeXRlcyIsImVuY29kZUZyb21CeXRlcyIsImJlY2gzMiIsImJlY2gzMm0iLCJ1dGY4IiwiVGV4dERlY29kZXIiLCJUZXh0RW5jb2RlciIsImhleCIsIkNPREVSUyIsImNvZGVyVHlwZUVycm9yIiwiYnl0ZXNUb1N0cmluZyIsInR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInN0cmluZ1RvQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entropyToMnemonic: () => (/* binding */ entropyToMnemonic),\n/* harmony export */   generateMnemonic: () => (/* binding */ generateMnemonic),\n/* harmony export */   mnemonicToEntropy: () => (/* binding */ mnemonicToEntropy),\n/* harmony export */   mnemonicToSeed: () => (/* binding */ mnemonicToSeed),\n/* harmony export */   mnemonicToSeedSync: () => (/* binding */ mnemonicToSeedSync),\n/* harmony export */   validateMnemonic: () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/**\n * Audited & minimal JS implementation of\n * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @module\n * @example\n```js\nimport * as bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nconst mn = bip39.generateMnemonic(wordlist);\nconsole.log(mn);\nconst ent = bip39.mnemonicToEntropy(mn, wordlist)\nbip39.entropyToMnemonic(ent, wordlist);\nbip39.validateMnemonic(mn, wordlist);\nawait bip39.mnemonicToSeed(mn, 'password');\nbip39.mnemonicToSeedSync(mn, 'password');\n\n// Wordlists\nimport { wordlist as czech } from '@scure/bip39/wordlists/czech';\nimport { wordlist as english } from '@scure/bip39/wordlists/english';\nimport { wordlist as french } from '@scure/bip39/wordlists/french';\nimport { wordlist as italian } from '@scure/bip39/wordlists/italian';\nimport { wordlist as japanese } from '@scure/bip39/wordlists/japanese';\nimport { wordlist as korean } from '@scure/bip39/wordlists/korean';\nimport { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';\nimport { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';\nimport { wordlist as spanish } from '@scure/bip39/wordlists/spanish';\nimport { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';\n```\n */ /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ \n\n\n\n\n\n// Japanese wordlist\nconst isJapanese = (wordlist)=>wordlist[0] === \"\";\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== \"string\") throw new TypeError(\"invalid mnemonic type: \" + typeof str);\n    return str.normalize(\"NFKD\");\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(\" \");\n    if (![\n        12,\n        15,\n        18,\n        21,\n        24\n    ].includes(words.length)) throw new Error(\"Invalid mnemonic\");\n    return {\n        nfkd: norm,\n        words\n    };\n}\nfunction aentropy(ent) {\n    (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__.abytes)(ent, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function generateMnemonic(wordlist, strength = 128) {\n    (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__.anumber)(strength);\n    if (strength % 32 !== 0 || strength > 256) throw new TypeError(\"Invalid entropy\");\n    return entropyToMnemonic((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy)=>{\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([\n        (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy)[0] >> bitsLeft << bitsLeft\n    ]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== \"string\") throw new Error(\"Wordlist: expected array of 2048 strings\");\n    wordlist.forEach((i)=>{\n        if (typeof i !== \"string\") throw new Error(\"wordlist: non-string element: \" + i);\n    });\n    return _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.chain(_scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.checksum(1, calcChecksum), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.radix2(11, true), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */ function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? \"\" : \" \");\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */ function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase)=>nfkd(\"mnemonic\" + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeed(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2Async)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeedSync(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRCQyxHQUNELHVGQUF1RixHQUMvQjtBQUNHO0FBQ2I7QUFDQTtBQUNJO0FBQ0Q7QUFDakQsb0JBQW9CO0FBQ3BCLE1BQU1TLGFBQWEsQ0FBQ0MsV0FBYUEsUUFBUSxDQUFDLEVBQUUsS0FBSztBQUNqRCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELG9GQUFvRjtBQUNwRiwrQ0FBK0M7QUFDL0MsU0FBU0MsS0FBS0MsR0FBRztJQUNiLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUMsVUFBVSw0QkFBNEIsT0FBT0Q7SUFDM0QsT0FBT0EsSUFBSUUsU0FBUyxDQUFDO0FBQ3pCO0FBQ0EsU0FBU0EsVUFBVUYsR0FBRztJQUNsQixNQUFNRyxPQUFPSixLQUFLQztJQUNsQixNQUFNSSxRQUFRRCxLQUFLRSxLQUFLLENBQUM7SUFDekIsSUFBSSxDQUFDO1FBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHLENBQUNDLFFBQVEsQ0FBQ0YsTUFBTUcsTUFBTSxHQUMzQyxNQUFNLElBQUlDLE1BQU07SUFDcEIsT0FBTztRQUFFVCxNQUFNSTtRQUFNQztJQUFNO0FBQy9CO0FBQ0EsU0FBU0ssU0FBU0MsR0FBRztJQUNqQnRCLDREQUFNQSxDQUFDc0IsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJO0FBQ2hDO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNDLGlCQUFpQmIsUUFBUSxFQUFFYyxXQUFXLEdBQUc7SUFDckR2Qiw2REFBT0EsQ0FBQ3VCO0lBQ1IsSUFBSUEsV0FBVyxPQUFPLEtBQUtBLFdBQVcsS0FDbEMsTUFBTSxJQUFJWCxVQUFVO0lBQ3hCLE9BQU9ZLGtCQUFrQm5CLGdFQUFXQSxDQUFDa0IsV0FBVyxJQUFJZDtBQUN4RDtBQUNBLE1BQU1nQixlQUFlLENBQUNDO0lBQ2xCLHFDQUFxQztJQUNyQyxNQUFNQyxXQUFXLElBQUlELFFBQVFSLE1BQU0sR0FBRztJQUN0Qyx5Q0FBeUM7SUFDekMsbURBQW1EO0lBQ25ELE9BQU8sSUFBSVUsV0FBVztRQUFFekIsNERBQU1BLENBQUN1QixRQUFRLENBQUMsRUFBRSxJQUFJQyxZQUFhQTtLQUFTO0FBQ3hFO0FBQ0EsU0FBU0UsU0FBU3BCLFFBQVE7SUFDdEIsSUFBSSxDQUFDcUIsTUFBTUMsT0FBTyxDQUFDdEIsYUFBYUEsU0FBU1MsTUFBTSxLQUFLLFFBQVEsT0FBT1QsUUFBUSxDQUFDLEVBQUUsS0FBSyxVQUMvRSxNQUFNLElBQUlVLE1BQU07SUFDcEJWLFNBQVN1QixPQUFPLENBQUMsQ0FBQ0M7UUFDZCxJQUFJLE9BQU9BLE1BQU0sVUFDYixNQUFNLElBQUlkLE1BQU0sbUNBQW1DYztJQUMzRDtJQUNBLE9BQU8xQiw4Q0FBU0EsQ0FBQzJCLEtBQUssQ0FBQzNCLDhDQUFTQSxDQUFDNEIsUUFBUSxDQUFDLEdBQUdWLGVBQWVsQiw4Q0FBU0EsQ0FBQzZCLE1BQU0sQ0FBQyxJQUFJLE9BQU83Qiw4Q0FBU0EsQ0FBQzhCLFFBQVEsQ0FBQzVCO0FBQy9HO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBUzZCLGtCQUFrQkMsUUFBUSxFQUFFOUIsUUFBUTtJQUNoRCxNQUFNLEVBQUVNLEtBQUssRUFBRSxHQUFHRixVQUFVMEI7SUFDNUIsTUFBTWIsVUFBVUcsU0FBU3BCLFVBQVUrQixNQUFNLENBQUN6QjtJQUMxQ0ssU0FBU007SUFDVCxPQUFPQTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0Ysa0JBQWtCRSxPQUFPLEVBQUVqQixRQUFRO0lBQy9DVyxTQUFTTTtJQUNULE1BQU1YLFFBQVFjLFNBQVNwQixVQUFVZ0MsTUFBTSxDQUFDZjtJQUN4QyxPQUFPWCxNQUFNMkIsSUFBSSxDQUFDbEMsV0FBV0MsWUFBWSxNQUFXO0FBQ3hEO0FBQ0E7O0NBRUMsR0FDTSxTQUFTa0MsaUJBQWlCSixRQUFRLEVBQUU5QixRQUFRO0lBQy9DLElBQUk7UUFDQTZCLGtCQUFrQkMsVUFBVTlCO0lBQ2hDLEVBQ0EsT0FBT21DLEdBQUc7UUFDTixPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxNQUFNQyxRQUFRLENBQUNDLGFBQWVwQyxLQUFLLGFBQWFvQztBQUNoRDs7Ozs7Ozs7O0NBU0MsR0FDTSxTQUFTQyxlQUFlUixRQUFRLEVBQUVPLGFBQWEsRUFBRTtJQUNwRCxPQUFPNUMsaUVBQVdBLENBQUNFLHdEQUFNQSxFQUFFUyxVQUFVMEIsVUFBVTdCLElBQUksRUFBRW1DLE1BQU1DLGFBQWE7UUFBRUUsR0FBRztRQUFNQyxPQUFPO0lBQUc7QUFDakc7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxTQUFTQyxtQkFBbUJYLFFBQVEsRUFBRU8sYUFBYSxFQUFFO0lBQ3hELE9BQU83Qyw0REFBTUEsQ0FBQ0csd0RBQU1BLEVBQUVTLFVBQVUwQixVQUFVN0IsSUFBSSxFQUFFbUMsTUFBTUMsYUFBYTtRQUFFRSxHQUFHO1FBQU1DLE9BQU87SUFBRztBQUM1RiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1aXNvdW5kLWFnZW50Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9lc20vaW5kZXguanM/NTJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGltcGxlbWVudGF0aW9uIG9mXG4gKiBbQklQMzkgbW5lbW9uaWMgcGhyYXNlc10oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzOS5tZWRpYXdpa2kpLlxuICogQG1vZHVsZVxuICogQGV4YW1wbGVcbmBgYGpzXG5pbXBvcnQgKiBhcyBiaXAzOSBmcm9tICdAc2N1cmUvYmlwMzknO1xuaW1wb3J0IHsgd29yZGxpc3QgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2VuZ2xpc2gnO1xuY29uc3QgbW4gPSBiaXAzOS5nZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0KTtcbmNvbnNvbGUubG9nKG1uKTtcbmNvbnN0IGVudCA9IGJpcDM5Lm1uZW1vbmljVG9FbnRyb3B5KG1uLCB3b3JkbGlzdClcbmJpcDM5LmVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuYmlwMzkudmFsaWRhdGVNbmVtb25pYyhtbiwgd29yZGxpc3QpO1xuYXdhaXQgYmlwMzkubW5lbW9uaWNUb1NlZWQobW4sICdwYXNzd29yZCcpO1xuYmlwMzkubW5lbW9uaWNUb1NlZWRTeW5jKG1uLCAncGFzc3dvcmQnKTtcblxuLy8gV29yZGxpc3RzXG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBjemVjaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvY3plY2gnO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgZW5nbGlzaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZW5nbGlzaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBmcmVuY2ggfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2ZyZW5jaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBpdGFsaWFuIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9pdGFsaWFuJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGphcGFuZXNlIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9qYXBhbmVzZSc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBrb3JlYW4gfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2tvcmVhbic7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBwb3J0dWd1ZXNlIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9wb3J0dWd1ZXNlJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIHNpbXBsaWZpZWRDaGluZXNlIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9zaW1wbGlmaWVkLWNoaW5lc2UnO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgc3BhbmlzaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvc3BhbmlzaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyB0cmFkaXRpb25hbENoaW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3RyYWRpdGlvbmFsLWNoaW5lc2UnO1xuYGBgXG4gKi9cbi8qISBzY3VyZS1iaXAzOSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdHJpY2lvIFBhbGxhZGlubywgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFudW1iZXIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL19hc3NlcnQnO1xuaW1wb3J0IHsgcGJrZGYyLCBwYmtkZjJBc3luYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcGJrZGYyJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhNTEyJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB1dGlscyBhcyBiYXNlVXRpbHMgfSBmcm9tICdAc2N1cmUvYmFzZSc7XG4vLyBKYXBhbmVzZSB3b3JkbGlzdFxuY29uc3QgaXNKYXBhbmVzZSA9ICh3b3JkbGlzdCkgPT4gd29yZGxpc3RbMF0gPT09ICdcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRmXFx1MzA1N1xcdTMwOTMnO1xuLy8gTm9ybWFsaXphdGlvbiByZXBsYWNlcyBlcXVpdmFsZW50IHNlcXVlbmNlcyBvZiBjaGFyYWN0ZXJzXG4vLyBzbyB0aGF0IGFueSB0d28gdGV4dHMgdGhhdCBhcmUgZXF1aXZhbGVudCB3aWxsIGJlIHJlZHVjZWRcbi8vIHRvIHRoZSBzYW1lIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzLCBjYWxsZWQgdGhlIG5vcm1hbCBmb3JtIG9mIHRoZSBvcmlnaW5hbCB0ZXh0LlxuLy8gaHR0cHM6Ly90b25za3kubWUvYmxvZy91bmljb2RlLyN3aHktaXMtYS0tLS1cbmZ1bmN0aW9uIG5ma2Qoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG1uZW1vbmljIHR5cGU6ICcgKyB0eXBlb2Ygc3RyKTtcbiAgICByZXR1cm4gc3RyLm5vcm1hbGl6ZSgnTkZLRCcpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHN0cikge1xuICAgIGNvbnN0IG5vcm0gPSBuZmtkKHN0cik7XG4gICAgY29uc3Qgd29yZHMgPSBub3JtLnNwbGl0KCcgJyk7XG4gICAgaWYgKCFbMTIsIDE1LCAxOCwgMjEsIDI0XS5pbmNsdWRlcyh3b3Jkcy5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW5lbW9uaWMnKTtcbiAgICByZXR1cm4geyBuZmtkOiBub3JtLCB3b3JkcyB9O1xufVxuZnVuY3Rpb24gYWVudHJvcHkoZW50KSB7XG4gICAgYWJ5dGVzKGVudCwgMTYsIDIwLCAyNCwgMjgsIDMyKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgeCByYW5kb20gd29yZHMuIFVzZXMgQ3J5cHRvZ3JhcGhpY2FsbHktU2VjdXJlIFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yLlxuICogQHBhcmFtIHdvcmRsaXN0IGltcG9ydGVkIHdvcmRsaXN0IGZvciBzcGVjaWZpYyBsYW5ndWFnZVxuICogQHBhcmFtIHN0cmVuZ3RoIG1uZW1vbmljIHN0cmVuZ3RoIDEyOC0yNTYgYml0c1xuICogQGV4YW1wbGVcbiAqIGdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QsIDEyOClcbiAqIC8vICdsZWdhbCB3aW5uZXIgdGhhbmsgeWVhciB3YXZlIHNhdXNhZ2Ugd29ydGggdXNlZnVsIGxlZ2FsIHdpbm5lciB0aGFuayB5ZWxsb3cnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCBzdHJlbmd0aCA9IDEyOCkge1xuICAgIGFudW1iZXIoc3RyZW5ndGgpO1xuICAgIGlmIChzdHJlbmd0aCAlIDMyICE9PSAwIHx8IHN0cmVuZ3RoID4gMjU2KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGVudHJvcHknKTtcbiAgICByZXR1cm4gZW50cm9weVRvTW5lbW9uaWMocmFuZG9tQnl0ZXMoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuY29uc3QgY2FsY0NoZWNrc3VtID0gKGVudHJvcHkpID0+IHtcbiAgICAvLyBDaGVja3N1bSBpcyBlbnQubGVuZ3RoLzQgYml0cyBsb25nXG4gICAgY29uc3QgYml0c0xlZnQgPSA4IC0gZW50cm9weS5sZW5ndGggLyA0O1xuICAgIC8vIFplcm8gcmlnaHRtb3N0IFwiYml0c0xlZnRcIiBiaXRzIGluIGJ5dGVcbiAgICAvLyBGb3IgZXhhbXBsZTogYml0c0xlZnQ9NCB2YWw9MTAxMTExMDEgLT4gMTAxMTAwMDBcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhzaGEyNTYoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMjA0OCB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmRsaXN0OiBleHBlY3RlZCBhcnJheSBvZiAyMDQ4IHN0cmluZ3MnKTtcbiAgICB3b3JkbGlzdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmRsaXN0OiBub24tc3RyaW5nIGVsZW1lbnQ6ICcgKyBpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZVV0aWxzLmNoYWluKGJhc2VVdGlscy5jaGVja3N1bSgxLCBjYWxjQ2hlY2tzdW0pLCBiYXNlVXRpbHMucmFkaXgyKDExLCB0cnVlKSwgYmFzZVV0aWxzLmFscGhhYmV0KHdvcmRsaXN0KSk7XG59XG4vKipcbiAqIFJldmVyc2libGU6IENvbnZlcnRzIG1uZW1vbmljIHN0cmluZyB0byByYXcgZW50cm9weSBpbiBmb3JtIG9mIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBtbmVtb25pY1RvRW50cm9weShtbmVtLCB3b3JkbGlzdClcbiAqIC8vIFByb2R1Y2VzXG4gKiBuZXcgVWludDhBcnJheShbXG4gKiAgIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsXG4gKiAgIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2ZcbiAqIF0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBub3JtYWxpemUobW5lbW9uaWMpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZGVjb2RlKHdvcmRzKTtcbiAgICBhZW50cm9weShlbnRyb3B5KTtcbiAgICByZXR1cm4gZW50cm9weTtcbn1cbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgcmF3IGVudHJvcHkgaW4gZm9ybSBvZiBieXRlIGFycmF5IHRvIG1uZW1vbmljIHN0cmluZy5cbiAqIEBwYXJhbSBlbnRyb3B5IGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIDEyLTI0IHdvcmRzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW50ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLFxuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmXG4gKiBdKTtcbiAqIGVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuICogLy8gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgYWVudHJvcHkoZW50cm9weSk7XG4gICAgY29uc3Qgd29yZHMgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZW5jb2RlKGVudHJvcHkpO1xuICAgIHJldHVybiB3b3Jkcy5qb2luKGlzSmFwYW5lc2Uod29yZGxpc3QpID8gJ1xcdTMwMDAnIDogJyAnKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIG1uZW1vbmljIGZvciBiZWluZyAxMi0yNCB3b3JkcyBjb250YWluZWQgaW4gYHdvcmRsaXN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHBzYWx0ID0gKHBhc3NwaHJhc2UpID0+IG5ma2QoJ21uZW1vbmljJyArIHBhc3NwaHJhc2UpO1xuLyoqXG4gKiBJcnJldmVyc2libGU6IFVzZXMgS0RGIHRvIGRlcml2ZSA2NCBieXRlcyBvZiBrZXkgZGF0YSBmcm9tIG1uZW1vbmljICsgb3B0aW9uYWwgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSBwYXNzcGhyYXNlIHN0cmluZyB0aGF0IHdpbGwgYWRkaXRpb25hbGx5IHByb3RlY3QgdGhlIGtleVxuICogQHJldHVybnMgNjQgYnl0ZXMgb2Yga2V5IGRhdGFcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBhd2FpdCBtbmVtb25pY1RvU2VlZChtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYywgcGFzc3BocmFzZSA9ICcnKSB7XG4gICAgcmV0dXJuIHBia2RmMkFzeW5jKHNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBwc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG4vKipcbiAqIElycmV2ZXJzaWJsZTogVXNlcyBLREYgdG8gZGVyaXZlIDY0IGJ5dGVzIG9mIGtleSBkYXRhIGZyb20gbW5lbW9uaWMgKyBvcHRpb25hbCBwYXNzd29yZC5cbiAqIEBwYXJhbSBtbmVtb25pYyAxMi0yNCB3b3Jkc1xuICogQHBhcmFtIHBhc3NwaHJhc2Ugc3RyaW5nIHRoYXQgd2lsbCBhZGRpdGlvbmFsbHkgcHJvdGVjdCB0aGUga2V5XG4gKiBAcmV0dXJucyA2NCBieXRlcyBvZiBrZXkgZGF0YVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1uZW0gPSAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93JztcbiAqIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvU2VlZFN5bmMobW5lbW9uaWMsIHBhc3NwaHJhc2UgPSAnJykge1xuICAgIHJldHVybiBwYmtkZjIoc2hhNTEyLCBub3JtYWxpemUobW5lbW9uaWMpLm5ma2QsIHBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbiJdLCJuYW1lcyI6WyJhYnl0ZXMiLCJhbnVtYmVyIiwicGJrZGYyIiwicGJrZGYyQXN5bmMiLCJzaGEyNTYiLCJzaGE1MTIiLCJyYW5kb21CeXRlcyIsInV0aWxzIiwiYmFzZVV0aWxzIiwiaXNKYXBhbmVzZSIsIndvcmRsaXN0IiwibmZrZCIsInN0ciIsIlR5cGVFcnJvciIsIm5vcm1hbGl6ZSIsIm5vcm0iLCJ3b3JkcyIsInNwbGl0IiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJFcnJvciIsImFlbnRyb3B5IiwiZW50IiwiZ2VuZXJhdGVNbmVtb25pYyIsInN0cmVuZ3RoIiwiZW50cm9weVRvTW5lbW9uaWMiLCJjYWxjQ2hlY2tzdW0iLCJlbnRyb3B5IiwiYml0c0xlZnQiLCJVaW50OEFycmF5IiwiZ2V0Q29kZXIiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwiaSIsImNoYWluIiwiY2hlY2tzdW0iLCJyYWRpeDIiLCJhbHBoYWJldCIsIm1uZW1vbmljVG9FbnRyb3B5IiwibW5lbW9uaWMiLCJkZWNvZGUiLCJlbmNvZGUiLCJqb2luIiwidmFsaWRhdGVNbmVtb25pYyIsImUiLCJwc2FsdCIsInBhc3NwaHJhc2UiLCJtbmVtb25pY1RvU2VlZCIsImMiLCJka0xlbiIsIm1uZW1vbmljVG9TZWVkU3luYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/esm/index.js\n");

/***/ })

};
;